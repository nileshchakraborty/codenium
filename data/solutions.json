{
    "solutions": {
        "triangle": {
            "title": "Triangle",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83d\udcc9",
            "timeComplexity": "O(n^2)",
            "spaceComplexity": "O(n)",
            "oneliner": "Compute min path sum from bottom to top to avoid greedy traps!",
            "intuition": [
                "\ud83d\udd3a Greedy doesn't work! Local min \u2260 Global min",
                "\ud83e\udde0 Subproblem: Min path from cell (i, j) to bottom",
                "\ud83d\udca1 dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])"
            ],
            "testCases": [
                {
                    "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
                    "output": "11"
                },
                {
                    "input": "triangle = [[-10]]",
                    "output": "-10"
                }
            ],
            "code": "def minimumTotal(triangle):\n    dp = triangle[-1][:]\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(i + 1):\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n    return dp[0]",
            "keyInsight": "Bottom-up DP simplifies boundary conditions and reuses space.",
            "description": "Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.",
            "examples": [
                {
                    "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
                    "output": "11",
                    "explanation": "Path 2 -> 3 -> 5 -> 1 = 11."
                },
                {
                    "input": "triangle = [[-10]]",
                    "output": "-10",
                    "explanation": "Single element."
                }
            ],
            "constraints": [
                "1 <= triangle.length <= 200",
                "triangle[0].length == 1",
                "triangle[i].length == triangle[i - 1].length + 1",
                "-10^4 <= triangle[i][j] <= 10^4"
            ],
            "hints": [
                "Use DP from bottom to top.",
                "dp[i] = triangle[row][i] + min(dp[i], dp[i+1]).",
                "Space optimization: reuse same array."
            ],
            "relatedProblems": [
                "minimum-path-sum",
                "dungeon-game"
            ],
            "videoId": "OM1MTokvxs4"
        },
        "best-time-to-buy-and-sell-stock": {
            "title": "Best Time to Buy and Sell Stock",
            "pattern": "Track Minimum",
            "patternEmoji": "\ud83d\udcc8",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track the minimum price seen so far, maximize profit at each step!",
            "intuition": [
                "\ud83c\udfaf Buy LOW, Sell HIGH",
                "\ud83e\udde0 Keep track of the cheapest day to buy",
                "\ud83d\udca1 At each day, calculate: what if I sold today?"
            ],
            "testCases": [
                {
                    "input": "prices = [7,1,5,3,6,4]",
                    "output": "5"
                },
                {
                    "input": "prices = [7,6,4,3,1]",
                    "output": "0"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Initialize Trackers",
                    "visual": "min_price = \u221e\nmax_profit = 0",
                    "explanation": "Start with infinity as min (first price will always be lower)"
                },
                {
                    "step": 2,
                    "title": "Walk Through Prices",
                    "visual": "prices: [7, 1, 5, 3, 6, 4]\n         \u2191\n       Day 1: price = 7",
                    "explanation": "Visit each day's price"
                },
                {
                    "step": 3,
                    "title": "Update Minimum",
                    "visual": "Day 1: min = min(\u221e, 7) = 7\nDay 2: min = min(7, 1) = 1 \u2b50 NEW LOW!",
                    "explanation": "Always track the best buying opportunity"
                },
                {
                    "step": 4,
                    "title": "Calculate Profit",
                    "visual": "Day 5: price = 6\n        profit = 6 - 1 = 5 \ud83d\udcb0\n        max_profit = 5",
                    "explanation": "At each step: profit = today - min_so_far"
                }
            ],
            "code": "def maxProfit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        profit = price - min_price\n        max_profit = max(max_profit, profit)\n    \n    return max_profit",
            "keyInsight": "One pass solution - no need to compare every pair!",
            "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
            "examples": [
                {
                    "input": "prices = [7,1,5,3,6,4]",
                    "output": "5",
                    "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
                },
                {
                    "input": "prices = [7,6,4,3,1]",
                    "output": "0",
                    "explanation": "No profitable transaction possible."
                }
            ],
            "constraints": [
                "1 <= prices.length <= 10^5",
                "0 <= prices[i] <= 10^4"
            ],
            "hints": [
                "Track the minimum price seen so far.",
                "At each day, calculate potential profit if you sold today.",
                "Keep track of the maximum profit seen."
            ],
            "relatedProblems": [
                "best-time-to-buy-and-sell-stock-ii",
                "best-time-to-buy-and-sell-stock-iii",
                "maximum-subarray"
            ],
            "videoId": "1pkOgXD63yU"
        },
        "valid-palindrome": {
            "title": "Valid Palindrome",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc46",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use two pointers from both ends, skip non-alphanumeric!",
            "intuition": [
                "\ud83c\udfaf Palindrome reads same forwards & backwards",
                "\ud83e\udde0 Compare characters from outside \u2192 inside",
                "\ud83d\udca1 Skip spaces and punctuation!"
            ],
            "testCases": [
                {
                    "input": "s = \"A man, a plan, a canal: Panama\"",
                    "output": "True"
                },
                {
                    "input": "s = \"race a car\"",
                    "output": "False"
                },
                {
                    "input": "s = \" \"",
                    "output": "True"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Set Up Pointers",
                    "visual": "\"A man, a plan, a canal: Panama\"\n \u2191                              \u2191\nleft                          right",
                    "explanation": "Start from both ends of the string"
                },
                {
                    "step": 2,
                    "title": "Skip Non-Letters",
                    "visual": "\"...canal: Panama\"\n         \u2191      \u2191\n     skip ':'  'a'",
                    "explanation": "Move pointer if not alphanumeric"
                },
                {
                    "step": 3,
                    "title": "Compare (Case-Insensitive)",
                    "visual": "'A' == 'a' \u2705 (lowercase both)\n'M' == 'm' \u2705\n'N' == 'n' \u2705",
                    "explanation": "Convert to lowercase and compare"
                },
                {
                    "step": 4,
                    "title": "Move Inward",
                    "visual": "left \u2192 \u2190     \u2192 \u2190 right\n      Meet in middle = VALID!",
                    "explanation": "Continue until pointers cross"
                }
            ],
            "code": "def isPalindrome(s):\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True",
            "keyInsight": "Two pointers = no extra space needed for reversed string!",
            "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.",
            "examples": [
                {
                    "input": "s = \"A man, a plan, a canal: Panama\"",
                    "output": "true",
                    "explanation": "After filtering: 'amanaplanacanalpanama' is a palindrome."
                },
                {
                    "input": "s = \"race a car\"",
                    "output": "false",
                    "explanation": "After filtering: 'raceacar' is not a palindrome."
                }
            ],
            "constraints": [
                "1 <= s.length <= 2 * 10^5",
                "s consists only of printable ASCII characters."
            ],
            "hints": [
                "Use two pointers from both ends.",
                "Skip non-alphanumeric characters.",
                "Compare characters (case-insensitive)."
            ],
            "relatedProblems": [
                "valid-palindrome-ii",
                "palindrome-linked-list",
                "longest-palindromic-substring"
            ],
            "videoId": "jJXJ16kPFWg"
        },
        "merge-sorted-array": {
            "title": "Merge Sorted Array",
            "pattern": "Three Pointers (Reverse)",
            "patternEmoji": "\ud83d\udd00",
            "timeComplexity": "O(m + n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Fill from the END to avoid overwriting!",
            "intuition": [
                "\ud83c\udfaf Can't start from front - would overwrite nums1!",
                "\ud83e\udde0 Start from back - empty space is there for us!",
                "\ud83d\udca1 Three pointers: end of nums1, end of nums2, write position"
            ],
            "testCases": [
                {
                    "input": "nums1 = [1,2,3,0,0,0]; m = 3; nums2 = [2,5,6]; n = 3",
                    "output": "[1, 2, 2, 3, 5, 6]"
                },
                {
                    "input": "nums1 = [1]; m = 1; nums2 = []; n = 0",
                    "output": "[1]"
                },
                {
                    "input": "nums1 = [0]; m = 0; nums2 = [1]; n = 1",
                    "output": "[1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Set Up 3 Pointers",
                    "visual": "nums1: [1,2,3,0,0,0]  nums2: [2,5,6]\n            \u2191     \u2191              \u2191\n           p1    write           p2",
                    "explanation": "p1 at last real element, p2 at end of nums2, write at end"
                },
                {
                    "step": 2,
                    "title": "Compare & Place Larger",
                    "visual": "3 vs 6 \u2192 6 wins!\n[1,2,3,0,0,6] \u2190 place 6",
                    "explanation": "Bigger goes to write position"
                },
                {
                    "step": 3,
                    "title": "Move Pointers",
                    "visual": "[1,2,3,0,0,6]\n            \u2191 \u2191\n           p1 write\n           \u2190 moved left",
                    "explanation": "Decrement write and the pointer that was used"
                },
                {
                    "step": 4,
                    "title": "Continue Until Done",
                    "visual": "Result: [1,2,2,3,5,6] \u2705",
                    "explanation": "If nums2 remaining, copy them. nums1 remaining? Already in place!"
                }
            ],
            "code": "def merge(nums1, m, nums2, n):\n    p1, p2 = m - 1, n - 1\n    write = m + n - 1\n    \n    while p2 >= 0:\n        if p1 >= 0 and nums1[p1] > nums2[p2]:\n            nums1[write] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[write] = nums2[p2]\n            p2 -= 1\n        write -= 1\n    return nums1",
            "keyInsight": "Reverse iteration = in-place without overwriting!",
            "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\n\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.",
            "examples": [
                {
                    "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
                    "output": "[1,2,2,3,5,6]",
                    "explanation": "The arrays we are merging are [1,2,3] and [2,5,6]."
                },
                {
                    "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
                    "output": "[1]",
                    "explanation": "No elements to merge from nums2."
                }
            ],
            "constraints": [
                "nums1.length == m + n",
                "nums2.length == n",
                "0 <= m, n <= 200",
                "1 <= m + n <= 200",
                "-10^9 <= nums1[i], nums2[j] <= 10^9"
            ],
            "hints": [
                "Start from the end of both arrays and work backwards.",
                "Compare elements from the end and place the larger one at the back of nums1.",
                "This avoids overwriting elements we haven't processed yet."
            ],
            "relatedProblems": [
                "merge-two-sorted-lists",
                "sort-an-array",
                "squares-of-a-sorted-array"
            ],
            "videoId": "P1Ic85RarKY"
        },
        "valid-parentheses": {
            "title": "Valid Parentheses",
            "pattern": "Stack",
            "patternEmoji": "(\ufe0f)\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Push open brackets; pop and match close brackets.",
            "intuition": [
                "\ud83c\udfaf Last Opened must be First Closed (LIFO).",
                "\ud83e\udde0 Stack tracks open brackets.",
                "\ud83d\udca1 Mismatch or empty stack on close? Invalid."
            ],
            "testCases": [
                {
                    "input": "s=\"()[]{}\"",
                    "output": "true"
                },
                {
                    "input": "s=\"(]\"",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Open",
                    "visual": "Push '(', '[', '{'.",
                    "explanation": "Await closing."
                },
                {
                    "step": 2,
                    "title": "Close",
                    "visual": "Pop top. Matches current? () [] {}",
                    "explanation": "Verify pairing."
                },
                {
                    "step": 3,
                    "title": "End",
                    "visual": "Stack empty? Valid.",
                    "explanation": "No unclosed brackets left."
                }
            ],
            "code": "def isValid(s):\n    stack = []\n    closeToOpen = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c in closeToOpen:\n            if stack and stack[-1] == closeToOpen[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n    return not stack",
            "keyInsight": "Map only the closing brackets allows clean logic: \"Is it a closer? Check stack. Else, it must be an opener.\"",
            "visualizationType": "string",
            "initialState": "()[]{}",
            "animationSteps": [],
            "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
            "examples": [
                {
                    "input": "s = \"()\"",
                    "output": "true",
                    "explanation": "Simple pair of matching parentheses."
                },
                {
                    "input": "s = \"()[]{}\"",
                    "output": "true",
                    "explanation": "Multiple types of matching brackets."
                },
                {
                    "input": "s = \"(]\"",
                    "output": "false",
                    "explanation": "Mismatched bracket types."
                }
            ],
            "constraints": [
                "1 <= s.length <= 10^4",
                "s consists of parentheses only '()[]{}'."
            ],
            "hints": [
                "Use a stack to track opening brackets.",
                "When you see a closing bracket, check if it matches the top of the stack.",
                "At the end, the stack should be empty."
            ],
            "relatedProblems": [
                "generate-parentheses",
                "longest-valid-parentheses",
                "remove-invalid-parentheses"
            ],
            "videoId": "WTzjTskDFMg"
        },
        "maximum-subarray": {
            "title": "Maximum Subarray",
            "pattern": "Kadane's Algorithm",
            "patternEmoji": "\ud83d\udcc8",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Extend current sum OR start fresh - pick the better option!",
            "intuition": [
                "\ud83c\udfaf At each position: should I continue or restart?",
                "\ud83e\udde0 If current_sum < 0, better to start fresh!",
                "\ud83d\udca1 Track both current sum and overall maximum"
            ],
            "testCases": [
                {
                    "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
                    "output": "6"
                },
                {
                    "input": "nums = [1]",
                    "output": "1"
                },
                {
                    "input": "nums = [5,4,-1,7,8]",
                    "output": "23"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Initialize",
                    "visual": "current_sum = nums[0]\nmax_sum = nums[0]",
                    "explanation": "Start with first element as both"
                },
                {
                    "step": 2,
                    "title": "The Key Decision",
                    "visual": "[-2,1,-3,4,-1,2,1,-5,4]\n         \u2191\ncurrent = -2 + 1 = -1\n   OR\nstart fresh = 1 \u2190 WINNER!",
                    "explanation": "current_sum = max(num, current_sum + num)"
                },
                {
                    "step": 3,
                    "title": "Update Maximum",
                    "visual": "current: 1 \u2192 -2 \u2192 4 \u2192 3 \u2192 5 \u2192 6 \u2192 1 \u2192 5\n                   \u2191           \u2191\n                 reset       max=6!",
                    "explanation": "max_sum = max(max_sum, current_sum)"
                },
                {
                    "step": 4,
                    "title": "Result",
                    "visual": "[4,-1,2,1] = 6 \u2705\n \u2191 max subarray",
                    "explanation": "Return max_sum"
                }
            ],
            "code": "def maxSubArray(nums):\n    current_sum = nums[0]\n    max_sum = nums[0]\n    \n    for num in nums[1:]:\n        # Either extend current subarray or start new\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum",
            "keyInsight": "The magic: negative prefix sum is never worth keeping!",
            "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.",
            "examples": [
                {
                    "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
                    "output": "6",
                    "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
                },
                {
                    "input": "nums = [1]",
                    "output": "1",
                    "explanation": "Single element is the maximum."
                },
                {
                    "input": "nums = [5,4,-1,7,8]",
                    "output": "23",
                    "explanation": "The entire array has the largest sum."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^5",
                "-10^4 <= nums[i] <= 10^4"
            ],
            "hints": [
                "Use Kadane's algorithm.",
                "At each position, decide: extend current subarray or start fresh.",
                "current_sum = max(nums[i], current_sum + nums[i])"
            ],
            "relatedProblems": [
                "maximum-product-subarray",
                "best-time-to-buy-and-sell-stock",
                "maximum-sum-circular-subarray"
            ],
            "videoId": "5WZl3MMT0Eg"
        },
        "climbing-stairs": {
            "title": "Climbing Stairs",
            "pattern": "DP (Fibonacci)",
            "patternEmoji": "\ud83e\uddb7",
            "timeComplexity": "O(N)",
            "spaceComplexity": "O(1)",
            "oneliner": "ways(i) = ways(i-1) + ways(i-2). It's just Fibonacci.",
            "intuition": [
                "\ud83c\udfaf To reach Step N, I must have come from N-1 or N-2.",
                "\ud83e\udde0 Count(N) = Count(N-1) + Count(N-2).",
                "\ud83d\udca1 Use two variables to store previous results."
            ],
            "testCases": [
                {
                    "input": "n = 2",
                    "output": "2"
                },
                {
                    "input": "n = 3",
                    "output": "3"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "one, two = 1, 1",
                    "explanation": "Base cases."
                },
                {
                    "step": 2,
                    "title": "Loop",
                    "visual": "temp=one. one=one+two. two=temp.",
                    "explanation": "Shift."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "return one.",
                    "explanation": "Result."
                }
            ],
            "code": "def climbStairs(n):\n    one, two = 1, 1\n    for i in range(n - 1):\n        temp = one\n        one = one + two\n        two = temp\n    return one",
            "keyInsight": "Notice the subproblem structure overlap. Memorization or Iterative DP solves it efficiently.",
            "visualizationType": "array",
            "initialState": [
                1,
                1
            ],
            "animationSteps": [],
            "description": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
            "examples": [
                {
                    "input": "n = 2",
                    "output": "2",
                    "explanation": "Two ways: (1+1) or (2)."
                },
                {
                    "input": "n = 3",
                    "output": "3",
                    "explanation": "Three ways: (1+1+1), (1+2), (2+1)."
                }
            ],
            "constraints": [
                "1 <= n <= 45"
            ],
            "hints": [
                "This is a classic dynamic programming problem.",
                "The number of ways to reach step n = ways to reach (n-1) + ways to reach (n-2).",
                "This is essentially the Fibonacci sequence!"
            ],
            "relatedProblems": [
                "min-cost-climbing-stairs",
                "house-robber",
                "fibonacci-number"
            ],
            "videoId": "Y0lT9Fck7qI"
        },
        "linked-list-cycle": {
            "title": "Linked List Cycle",
            "pattern": "Fast & Slow Pointers",
            "patternEmoji": "\ud83d\udc07\ud83d\udc22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Slow moves 1 step, Fast moves 2. If they collide, there is a cycle.",
            "intuition": [
                "\ud83c\udfaf Floyd's Tortoise and Hare.",
                "\ud83e\udde0 If cycle exists, Fast will eventually lap Slow.",
                "\ud83d\udca1 If Fast reaches null, no cycle."
            ],
            "testCases": [
                {
                    "input": "head = [3,2,0,-4]; pos = 1",
                    "output": "true"
                },
                {
                    "input": "head = [1]; pos = -1",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Run",
                    "visual": "Slow=Head, Fast=Head. Loop.",
                    "explanation": "Start race."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "Slow == Fast? Return True.",
                    "explanation": "Collision!"
                },
                {
                    "step": 3,
                    "title": "End",
                    "visual": "Fast is None? Return False.",
                    "explanation": "Reached end."
                }
            ],
            "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\ndef hasCycle(head):\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False",
            "keyInsight": "Fast pointer MUST check `fast.next` before jumping two steps to avoid AttributeError.",
            "visualizationType": "linked-list",
            "initialState": [
                3,
                2,
                0,
                -4
            ],
            "animationSteps": [],
            "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.",
            "examples": [
                {
                    "input": "head = [3,2,0,-4], pos = 1",
                    "output": "true",
                    "explanation": "There is a cycle where the tail connects to node at index 1."
                },
                {
                    "input": "head = [1,2], pos = 0",
                    "output": "true",
                    "explanation": "Tail connects to node at index 0."
                },
                {
                    "input": "head = [1], pos = -1",
                    "output": "false",
                    "explanation": "No cycle in the list."
                }
            ],
            "constraints": [
                "The number of nodes is in range [0, 10^4]",
                "-10^5 <= Node.val <= 10^5",
                "pos is -1 or a valid index."
            ],
            "hints": [
                "Use Floyd's Cycle Detection (Tortoise and Hare).",
                "Have a slow pointer move by 1 and fast pointer move by 2.",
                "If they meet, there's a cycle."
            ],
            "relatedProblems": [
                "linked-list-cycle-ii",
                "happy-number",
                "find-the-duplicate-number"
            ],
            "videoId": "gBTe7lFR3vc"
        },
        "binary-search": {
            "title": "Binary Search",
            "pattern": "Divide & Conquer",
            "patternEmoji": "\ud83c\udfaf",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Half the search space each time by checking the middle!",
            "intuition": [
                "\ud83c\udfaf Array is SORTED - exploit this!",
                "\ud83e\udde0 Check middle: too big? go left. Too small? go right.",
                "\ud83d\udca1 Halving = log\u2082(n) steps maximum"
            ],
            "testCases": [
                {
                    "input": "nums = [-1,0,3,5,9,12]; target = 9",
                    "output": "4"
                },
                {
                    "input": "nums = [-1,0,3,5,9,12]; target = 2",
                    "output": "-1"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Set Boundaries",
                    "visual": "[1, 3, 5, 7, 9, 11, 13]\n \u2191                    \u2191\nleft                right",
                    "explanation": "Start with full array range"
                },
                {
                    "step": 2,
                    "title": "Find Middle",
                    "visual": "[1, 3, 5, 7, 9, 11, 13]\n          \u2191\n         mid (index 3, value 7)",
                    "explanation": "mid = (left + right) // 2"
                },
                {
                    "step": 3,
                    "title": "Compare & Narrow",
                    "visual": "target = 11\n7 < 11 \u2192 search RIGHT half\n[_, _, _, _, 9, 11, 13]\n             \u2191       \u2191\n           left    right",
                    "explanation": "Eliminate half the options!"
                },
                {
                    "step": 4,
                    "title": "Repeat Until Found",
                    "visual": "mid = 11 \u2705 FOUND!\nOR left > right = Not found",
                    "explanation": "Continue halving until match or exhausted"
                }
            ],
            "code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1   # search right\n        else:\n            right = mid - 1  # search left\n    \n    return -1",
            "keyInsight": "Each step eliminates HALF - that's why it's O(log n)!",
            "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n\nYou must write an algorithm with O(log n) runtime complexity.",
            "examples": [
                {
                    "input": "nums = [-1,0,3,5,9,12], target = 9",
                    "output": "4",
                    "explanation": "9 exists in nums and its index is 4."
                },
                {
                    "input": "nums = [-1,0,3,5,9,12], target = 2",
                    "output": "-1",
                    "explanation": "2 does not exist in nums."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^4",
                "-10^4 < nums[i], target < 10^4",
                "All the integers in nums are unique.",
                "nums is sorted in ascending order."
            ],
            "hints": [
                "Use two pointers: left and right.",
                "Calculate mid = (left + right) // 2.",
                "Compare nums[mid] with target and narrow the search range."
            ],
            "relatedProblems": [
                "search-insert-position",
                "search-in-rotated-sorted-array",
                "find-first-and-last-position-of-element-in-sorted-array"
            ],
            "videoId": "s4DPM8ct1pI"
        },
        "number-of-islands": {
            "title": "Number of Islands",
            "pattern": "Matrix DFS / BFS",
            "patternEmoji": "\ud83c\udfdd\ufe0f",
            "timeComplexity": "O(M*N)",
            "spaceComplexity": "O(M*N)",
            "oneliner": "Iterate grid. If '1', increment count and run DFS/BFS to sink (mark '0') the entire island.",
            "intuition": [
                "\ud83c\udfaf '1' is land. Connected '1's form one island.",
                "\ud83e\udde0 When we find an island, destroy it so we don't count it again.",
                "\ud83d\udca1 Flood fill."
            ],
            "testCases": [
                {
                    "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
                    "output": "1"
                },
                {
                    "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
                    "output": "3"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Find '1' at (r, c). Count++.",
                    "explanation": "Discovery."
                },
                {
                    "step": 2,
                    "title": "Sink",
                    "visual": "DFS(r, c). Turn '1' to '0'. Recurse 4 dirs.",
                    "explanation": "Erase."
                },
                {
                    "step": 3,
                    "title": "Repeat",
                    "visual": "Continue scan till end.",
                    "explanation": "Completion."
                }
            ],
            "code": "def numIslands(grid):\n    if not grid: return 0\n    rows, cols = len(grid), len(grid[0])\n    visit = set()\n    islands = 0\n    \n    def bfs(r, c):\n        q = []\n        q.append((r, c))\n        visit.add((r,c))\n        while q:\n            row, col = q.pop(0)\n            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n            for dr, dc in directions:\n                r, c = row + dr, col + dc\n                if (r in range(rows) and c in range(cols) and\n                    grid[r][c] == \"1\" and (r, c) not in visit):\n                    q.append((r, c))\n                    visit.add((r, c))\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == \"1\" and (r, c) not in visit:\n                bfs(r, c)\n                islands += 1\n    return islands",
            "keyInsight": "You can modify the grid in-place (change '1' to '0') to save O(MN) space for the visited set.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    "1",
                    "1",
                    "0"
                ],
                [
                    "1",
                    "1",
                    "0"
                ],
                [
                    "0",
                    "0",
                    "1"
                ]
            ],
            "animationSteps": [],
            "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
            "examples": [
                {
                    "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
                    "output": "1",
                    "explanation": "One connected land mass."
                },
                {
                    "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
                    "output": "3",
                    "explanation": "Three separate islands."
                }
            ],
            "constraints": [
                "m == grid.length",
                "n == grid[i].length",
                "1 <= m, n <= 300",
                "grid[i][j] is '0' or '1'."
            ],
            "hints": [
                "Use DFS or BFS to explore connected land.",
                "When you find a '1', increment count and mark all connected land as visited.",
                "Continue scanning the grid."
            ],
            "relatedProblems": [
                "surrounded-regions",
                "max-area-of-island",
                "number-of-enclaves"
            ],
            "videoId": "pV2kpPD66nE"
        },
        "reverse-linked-list": {
            "title": "Reverse Linked List",
            "pattern": "Iterative Pointer Swap",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Change each node's pointer to point backwards!",
            "intuition": [
                "\ud83c\udfaf Each node.next should point to previous node",
                "\ud83e\udde0 Need to save 'next' before changing pointer",
                "\ud83d\udca1 Use 3 pointers: prev, current, next"
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,4,5]",
                    "output": "[5,4,3,2,1]"
                },
                {
                    "input": "head = [1,2]",
                    "output": "[2,1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Initialize",
                    "visual": "None \u2190 1 \u2192 2 \u2192 3 \u2192 None\n \u2191    \u2191\nprev  curr",
                    "explanation": "prev starts at None (new tail)"
                },
                {
                    "step": 2,
                    "title": "Save Next",
                    "visual": "1 \u2192 2 \u2192 3\n    \u2191\n   next_node (save before we lose it!)",
                    "explanation": "Must save before changing pointer"
                },
                {
                    "step": 3,
                    "title": "Reverse Pointer",
                    "visual": "None \u2190 1   2 \u2192 3\n \u2191    \u2191   \u2191\nprev curr next",
                    "explanation": "curr.next = prev"
                },
                {
                    "step": 4,
                    "title": "Move Forward",
                    "visual": "None \u2190 1 \u2190 2 \u2190 3\n               \u2191\n              prev (new head!)",
                    "explanation": "Shift all pointers right, repeat"
                }
            ],
            "code": "def reverseList(head):\n    prev = None\n    curr = head\n    \n    while curr:\n        next_node = curr.next  # save next\n        curr.next = prev       # reverse pointer\n        prev = curr            # move prev forward\n        curr = next_node       # move curr forward\n    \n    return prev  # prev is new head",
            "keyInsight": "Three-pointer technique is fundamental for linked list operations!",
            "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5]",
                    "output": "[5,4,3,2,1]",
                    "explanation": "The list is reversed."
                },
                {
                    "input": "head = [1,2]",
                    "output": "[2,1]",
                    "explanation": "Two-element list reversed."
                },
                {
                    "input": "head = []",
                    "output": "[]",
                    "explanation": "Empty list remains empty."
                }
            ],
            "constraints": [
                "The number of nodes in the list is the range [0, 5000].",
                "-5000 <= Node.val <= 5000"
            ],
            "hints": [
                "Use three pointers: prev, curr, next.",
                "At each step, reverse curr's pointer to prev.",
                "Move all pointers one step forward."
            ],
            "relatedProblems": [
                "reverse-linked-list-ii",
                "palindrome-linked-list",
                "reverse-nodes-in-k-group"
            ],
            "videoId": "G0_I-ZF0S38"
        },
        "contains-duplicate": {
            "title": "Contains Duplicate",
            "pattern": "Hash Set",
            "patternEmoji": "\ud83d\udc6f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Add to set; if exists, return True.",
            "intuition": [
                "\ud83c\udfaf Any number appearing twice?",
                "\ud83e\udde0 Set stores unique elements.",
                "\ud83d\udca1 Check membership before adding."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "true"
                },
                {
                    "input": "nums = [1,2,3,4]",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Iterate numbers.",
                    "explanation": "Standard pass."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "In set? True.",
                    "explanation": "Collision."
                },
                {
                    "step": 3,
                    "title": "Add",
                    "visual": "Add to set.",
                    "explanation": "Track seen."
                }
            ],
            "code": "def containsDuplicate(nums):\n    seen = set()\n    for n in nums:\n        if n in seen: return True\n        seen.add(n)\n    return False",
            "keyInsight": "HashSet provides immediate collision detection.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                1
            ],
            "animationSteps": [],
            "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
            "examples": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "true",
                    "explanation": "1 appears twice."
                },
                {
                    "input": "nums = [1,2,3,4]",
                    "output": "false",
                    "explanation": "All elements are distinct."
                },
                {
                    "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
                    "output": "true",
                    "explanation": "Multiple duplicates exist."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^5",
                "-10^9 <= nums[i] <= 10^9"
            ],
            "hints": [
                "Use a hash set to track seen numbers.",
                "If you see a number already in the set, return true.",
                "Alternatively, sort the array and check adjacent elements."
            ],
            "relatedProblems": [
                "contains-duplicate-ii",
                "contains-duplicate-iii",
                "find-the-duplicate-number"
            ],
            "videoId": "3OamzN90kPg"
        },
        "invert-binary-tree": {
            "title": "Invert Binary Tree",
            "pattern": "DFS (Recursion)",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Swap left and right children, then recurse.",
            "intuition": [
                "\ud83c\udfaf Mirror image.",
                "\ud83e\udde0 For every node, left becomes right.",
                "\ud83d\udca1 Post-order or Pre-order traversal works fine."
            ],
            "testCases": [
                {
                    "input": "root = [4,2,7,1,3,6,9]",
                    "output": "[4,7,2,9,6,3,1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Swap",
                    "visual": "root.left, root.right = root.right, root.left.",
                    "explanation": "Action."
                },
                {
                    "step": 2,
                    "title": "Recurse",
                    "visual": "invert(left), invert(right).",
                    "explanation": "Propagate."
                },
                {
                    "step": 3,
                    "title": "Base",
                    "visual": "If null, return null.",
                    "explanation": "Stop."
                }
            ],
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef invertTree(root):\n    if not root: return None\n    root.left, root.right = root.right, root.left\n    invertTree(root.left)\n    invertTree(root.right)\n    return root",
            "keyInsight": "Max Howell famously got rejected by Google for not solving this on a whiteboard.",
            "visualizationType": "tree",
            "initialState": [
                4,
                2,
                7,
                1,
                3,
                6,
                9
            ],
            "animationSteps": [],
            "description": "Given the root of a binary tree, invert the tree, and return its root.",
            "examples": [
                {
                    "input": "root = [4,2,7,1,3,6,9]",
                    "output": "[4,7,2,9,6,3,1]",
                    "explanation": "Mirror the tree."
                },
                {
                    "input": "root = [2,1,3]",
                    "output": "[2,3,1]",
                    "explanation": "Swap children."
                }
            ],
            "constraints": [
                "The number of nodes is in range [0, 100].",
                "-100 <= Node.val <= 100"
            ],
            "hints": [
                "Recursively swap left and right children.",
                "Base case: null node returns null.",
                "DFS or BFS both work."
            ],
            "relatedProblems": [
                "same-tree",
                "symmetric-tree"
            ],
            "videoId": "OnSn2XEQ4MY"
        },
        "coin-change": {
            "title": "Coin Change",
            "pattern": "1D DP",
            "patternEmoji": "\ud83e\ude99",
            "timeComplexity": "O(amount * n)",
            "spaceComplexity": "O(amount)",
            "oneliner": "dp[i] = min(dp[i], dp[i-coin] + 1) for each coin.",
            "intuition": [
                "\ud83c\udfaf Min coins to make amount.",
                "\ud83e\udde0 dp[i] = min coins for amount i.",
                "\ud83d\udca1 For each coin, dp[i] = min(dp[i], dp[i-coin] + 1)."
            ],
            "testCases": [
                {
                    "input": "coins = [1,2,5]; amount = 11",
                    "output": "3"
                }
            ],
            "code": "def coinChange(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1",
            "keyInsight": "Bottom-up DP iterating coins first or amount first.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                5
            ],
            "animationSteps": [],
            "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.",
            "examples": [
                {
                    "input": "coins = [1,2,5], amount = 11",
                    "output": "3",
                    "explanation": "11 = 5 + 5 + 1"
                },
                {
                    "input": "coins = [2], amount = 3",
                    "output": "-1",
                    "explanation": "Cannot make 3 with only 2s."
                },
                {
                    "input": "coins = [1], amount = 0",
                    "output": "0",
                    "explanation": "No coins needed for amount 0."
                }
            ],
            "constraints": [
                "1 <= coins.length <= 12",
                "1 <= coins[i] <= 2^31 - 1",
                "0 <= amount <= 10^4"
            ],
            "hints": [
                "Use dynamic programming.",
                "dp[i] = minimum coins needed to make amount i.",
                "For each coin, dp[i] = min(dp[i], dp[i-coin] + 1)."
            ],
            "relatedProblems": [
                "coin-change-ii",
                "minimum-cost-for-tickets",
                "perfect-squares"
            ],
            "videoId": "H9bfqozjoqs"
        },
        "two-sum": {
            "title": "Two Sum",
            "pattern": "Hash Map",
            "patternEmoji": "\u2795",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Store seen numbers; check if (target - current) exists in map.",
            "intuition": [
                "\ud83c\udfaf We need: nums[j] = target - nums[i].",
                "\ud83e\udde0 While iterating, store {val: index} of what we've seen.",
                "\ud83d\udca1 Look back: do we have the complement?"
            ],
            "testCases": [
                {
                    "input": "nums = [2,7,11,15]; target = 9",
                    "output": "[0,1]"
                },
                {
                    "input": "nums = [3,2,4]; target = 6",
                    "output": "[1,2]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Visit 2. Need 7. Map: {2:0}.",
                    "explanation": "Remember 2."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "Visit 7. Need 2. 2 is in Map!",
                    "explanation": "Pair found."
                },
                {
                    "step": 3,
                    "title": "Found",
                    "visual": "Return [Map[2], CurrentIndex].",
                    "explanation": "Indices found."
                }
            ],
            "code": "def twoSum(nums, target):\n    prevMap = {}\n    for i, n in enumerate(nums):\n        diff = target - n\n        if diff in prevMap:\n            return [prevMap[diff], i]\n        prevMap[n] = i\n    return []",
            "keyInsight": "One pass is sufficient because the pair is commutative; we find it when we reach the *second* number.",
            "visualizationType": "array",
            "initialState": [
                2,
                7,
                11,
                15
            ],
            "animationSteps": [],
            "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
            "examples": [
                {
                    "input": "nums = [2,7,11,15], target = 9",
                    "output": "[0,1]",
                    "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
                },
                {
                    "input": "nums = [3,2,4], target = 6",
                    "output": "[1,2]",
                    "explanation": "nums[1] + nums[2] = 2 + 4 = 6"
                },
                {
                    "input": "nums = [3,3], target = 6",
                    "output": "[0,1]",
                    "explanation": "nums[0] + nums[1] = 3 + 3 = 6"
                }
            ],
            "constraints": [
                "2 <= nums.length <= 10^4",
                "-10^9 <= nums[i] <= 10^9",
                "-10^9 <= target <= 10^9",
                "Only one valid answer exists."
            ],
            "hints": [
                "A really brute force way would be to search for all possible pairs of numbers but that would be too slow.",
                "Try using a hash map to store the complement of each number.",
                "Can you do it in one pass through the array?"
            ],
            "relatedProblems": [
                "three-sum",
                "two-sum-ii---input-array-is-sorted",
                "two-sum-iv---input-is-a-bst"
            ],
            "videoId": "KLlXCFG5TnA"
        },
        "remove-element": {
            "title": "Remove Element",
            "pattern": "Two Pointers",
            "patternEmoji": "\u270c\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use a read pointer and a write pointer to filter in-place.",
            "intuition": [
                "\ud83c\udfaf We need to remove all instances of val in-place",
                "\ud83e\udde0 Maintain a 'k' pointer that tracks the position of valid elements",
                "\ud83d\udca1 If current element != val, put it at k and increment k"
            ],
            "testCases": [
                {
                    "input": "nums = [3,2,2,3]; val = 3",
                    "output": "2"
                },
                {
                    "input": "nums = [0,1,2,2,3,0,4,2]; val = 2",
                    "output": "5"
                }
            ],
            "code": "def removeElement(nums, val):\n    k = 0\n    for i in range(len(nums)):\n        if nums[i] != val:\n            nums[k] = nums[i]\n            k += 1\n    return k",
            "keyInsight": "Overwrite values we don't want with the ones we keep!",
            "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.",
            "examples": [
                {
                    "input": "nums = [3,2,2,3], val = 3",
                    "output": "2, nums = [2,2,_,_]",
                    "explanation": "Your function should return k = 2, with the first two elements of nums being 2."
                },
                {
                    "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
                    "output": "5, nums = [0,1,4,0,3,_,_,_]",
                    "explanation": "Your function should return k = 5."
                }
            ],
            "constraints": [
                "0 <= nums.length <= 100",
                "0 <= nums[i] <= 50",
                "0 <= val <= 100"
            ],
            "hints": [
                "Use two pointers - one for iteration, one for placing valid elements.",
                "Overwrite elements equal to val with elements from the end.",
                "The order doesn't matter, so we can swap freely."
            ],
            "relatedProblems": [
                "remove-duplicates-from-sorted-array",
                "move-zeroes",
                "remove-linked-list-elements"
            ],
            "videoId": "Pcd1ii9P9ZI"
        },
        "majority-element": {
            "title": "Majority Element",
            "pattern": "Boyer-Moore Voting",
            "patternEmoji": "\ud83d\uddf3\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Cancel out different elements; the majority always survives!",
            "intuition": [
                "\ud83c\udfaf Majority element appears > n/2 times",
                "\ud83e\udde0 Think of it as a war: mixed pair die, majority wins",
                "\ud83d\udca1 Count +, Count -. If count 0, pick new candidate."
            ],
            "testCases": [
                {
                    "input": "nums = [3,2,3]",
                    "output": "3"
                },
                {
                    "input": "nums = [2,2,1,1,1,2,2]",
                    "output": "2"
                }
            ],
            "code": "def majorityElement(nums):\n    count = 0\n    candidate = None\n    \n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += (1 if num == candidate else -1)\n        \n    return candidate",
            "keyInsight": "If >50% of people vote Red, even if everyone else pairs up against them, Red wins!",
            "description": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.",
            "examples": [
                {
                    "input": "nums = [3,2,3]",
                    "output": "3",
                    "explanation": "3 appears 2 times out of 3."
                },
                {
                    "input": "nums = [2,2,1,1,1,2,2]",
                    "output": "2",
                    "explanation": "2 appears 4 times out of 7."
                }
            ],
            "constraints": [
                "n == nums.length",
                "1 <= n <= 5 * 10^4",
                "-10^9 <= nums[i] <= 10^9"
            ],
            "hints": [
                "Use Boyer-Moore Voting Algorithm.",
                "Maintain a candidate and count.",
                "If count is 0, pick new candidate. If same, increment, else decrement."
            ],
            "relatedProblems": [
                "majority-element-ii",
                "check-if-a-number-is-majority-element-in-a-sorted-array"
            ],
            "videoId": "7pnhv842keE"
        },
        "ransom-note": {
            "title": "Ransom Note",
            "pattern": "Hash Map / Counter",
            "patternEmoji": "\ud83d\udcc3",
            "timeComplexity": "O(m+n)",
            "spaceComplexity": "O(1) (26 chars)",
            "oneliner": "Count letters in magazine; ensure every letter in note is available.",
            "intuition": [
                "\ud83c\udfaf Can we construct 'note' from 'magazine' letters?",
                "\ud83e\udde0 Count frequency of each char in magazine.",
                "\ud83d\udca1 For each char in note, subtract count. If count < 0, False."
            ],
            "testCases": [
                {
                    "input": "ransomNote = \"a\"; magazine = \"b\"",
                    "output": "false"
                },
                {
                    "input": "ransomNote = \"aa\"; magazine = \"aab\"",
                    "output": "true"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Count Magazine",
                    "visual": "Map: {a:2, b:1}",
                    "explanation": "Available resources."
                },
                {
                    "step": 2,
                    "title": "Check Note",
                    "visual": "Need 'a'? Map['a']--. Remaining: 1.",
                    "explanation": "Consume resource."
                },
                {
                    "step": 3,
                    "title": "Verify",
                    "visual": "If Map[char] < 0, impossible.",
                    "explanation": "Not enough letters."
                }
            ],
            "code": "def canConstruct(ransomNote, magazine):\n    from collections import Counter\n    counts = Counter(magazine)\n    for c in ransomNote:\n        counts[c] -= 1\n        if counts[c] < 0: return False\n    return True",
            "keyInsight": "Using an array of size 26 is slightly faster than a hashmap, but Counter is cleaner.",
            "visualizationType": "string",
            "initialState": "ransomNote='aa', magazine='aab'",
            "animationSteps": [],
            "description": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote.",
            "examples": [
                {
                    "input": "ransomNote = \"a\", magazine = \"b\"",
                    "output": "false",
                    "explanation": "'a' is not in magazine."
                },
                {
                    "input": "ransomNote = \"aa\", magazine = \"aab\"",
                    "output": "true",
                    "explanation": "Both 'a's can be found in magazine."
                }
            ],
            "constraints": [
                "1 <= ransomNote.length, magazine.length <= 10^5",
                "ransomNote and magazine consist of lowercase English letters."
            ],
            "hints": [
                "Count character frequencies in magazine.",
                "Check if ransomNote's frequencies are all <= magazine's.",
                "Use a hash map or array of size 26."
            ],
            "relatedProblems": [
                "stickers-to-spell-word",
                "first-unique-character-in-a-string"
            ],
            "videoId": "OKmDwbsROuc"
        },
        "valid-anagram": {
            "title": "Valid Anagram",
            "pattern": "Hash Map / Sorting",
            "patternEmoji": "\ud83d\udd00",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Check if character counts are identical.",
            "intuition": [
                "\ud83c\udfaf Anagram = same letters, rearranged.",
                "\ud83e\udde0 Sorting works (O(nlogn)), but counting is faster (O(n)).",
                "\ud83d\udca1 Count S, subtract T. All zero? True."
            ],
            "testCases": [
                {
                    "input": "s = \"anagram\"; t = \"nagaram\"",
                    "output": "true"
                },
                {
                    "input": "s = \"rat\"; t = \"car\"",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Count S",
                    "visual": "{a:3, n:1, g:1, r:1, m:1}",
                    "explanation": "Tally up."
                },
                {
                    "step": 2,
                    "title": "Subtract T",
                    "visual": "Decrement counts for 'nagaram'.",
                    "explanation": "Cancel out."
                },
                {
                    "step": 3,
                    "title": "Result",
                    "visual": "All zero? Match.",
                    "explanation": "Any non-zero means mismatch."
                }
            ],
            "code": "def isAnagram(s, t):\n    if len(s) != len(t): return False\n    # return sorted(s) == sorted(t)\n    from collections import Counter\n    return Counter(s) == Counter(t)",
            "keyInsight": "Length check first is a cheap optimization.",
            "visualizationType": "string",
            "initialState": "anagram vs nagaram",
            "animationSteps": [],
            "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
            "examples": [
                {
                    "input": "s = \"anagram\", t = \"nagaram\"",
                    "output": "true",
                    "explanation": "Both have same letter counts."
                },
                {
                    "input": "s = \"rat\", t = \"car\"",
                    "output": "false",
                    "explanation": "Different letter counts."
                }
            ],
            "constraints": [
                "1 <= s.length, t.length <= 5 * 10^4",
                "s and t consist of lowercase English letters."
            ],
            "hints": [
                "If lengths differ, return false immediately.",
                "Count character frequencies and compare.",
                "Or sort both strings and compare."
            ],
            "relatedProblems": [
                "group-anagrams",
                "find-all-anagrams-in-a-string",
                "find-resultant-array-after-removing-anagrams"
            ],
            "videoId": "9UtInBqnCgA"
        },
        "happy-number": {
            "title": "Happy Number",
            "pattern": "Floyd's Cycle Finding",
            "patternEmoji": "\ud83d\ude00",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Detect cycle in sum-of-squares chain. 1 is happy root; other cycles are sad.",
            "intuition": [
                "\ud83c\udfaf Process: replace n with sum of squares of digits.",
                "\ud83e\udde0 It either reaches 1 (Happy) or stuck in a loop (Sad).",
                "\ud83d\udca1 Use Slow/Fast pointers or a Set to detect loop."
            ],
            "testCases": [
                {
                    "input": "n = 19",
                    "output": "true"
                },
                {
                    "input": "n = 2",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Simulate",
                    "visual": "19 -> 1^2+9^2=82 -> 68 -> 100 -> 1.",
                    "explanation": "Converged to 1."
                },
                {
                    "step": 2,
                    "title": "Cycle",
                    "visual": "2 -> 4 -> 16... -> 4 (Loop!).",
                    "explanation": "Detected visited number."
                },
                {
                    "step": 3,
                    "title": "Result",
                    "visual": "If 1: True. If Cycle: False.",
                    "explanation": "Decision."
                }
            ],
            "code": "def isHappy(n):\n    visit = set()\n    while n not in visit:\n        visit.add(n)\n        n = sum(int(d)**2 for d in str(n))\n        if n == 1: return True\n    return False",
            "keyInsight": "The cycle doesn't grow infinitely; digits reduce numbers drastically (999 -> 243). Loop is guaranteed small.",
            "visualizationType": "string",
            "initialState": "19",
            "animationSteps": [],
            "description": "Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.",
            "examples": [
                {
                    "input": "n = 19",
                    "output": "true",
                    "explanation": "1\u00b2 + 9\u00b2 = 82 \u2192 8\u00b2 + 2\u00b2 = 68 \u2192 ... \u2192 1"
                },
                {
                    "input": "n = 2",
                    "output": "false",
                    "explanation": "2 \u2192 4 \u2192 16 \u2192 37 \u2192 58 \u2192 89 \u2192 145 \u2192 42 \u2192 20 \u2192 4 (cycle)"
                }
            ],
            "constraints": [
                "1 <= n <= 2^31 - 1"
            ],
            "hints": [
                "Use Floyd's cycle detection (fast and slow).",
                "Or use a hash set to detect cycles.",
                "If you see a number twice, it's not happy."
            ],
            "relatedProblems": [
                "linked-list-cycle",
                "add-digits",
                "ugly-number"
            ],
            "videoId": "ljz85bxOYJ0"
        },
        "middle-of-the-linked-list": {
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc49\ud83d\udc48",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use two pointers, one moving twice as fast as the other, to find the middle.",
            "intuition": [
                "The faster pointer will reach the end when the slower one is at the middle.",
                "Move slow and fast pointers; fast moves two steps while slow moves one."
            ],
            "visualizationType": "linkedlist",
            "initialState": [
                "A",
                "B",
                "C",
                "D",
                "E"
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "slow"
                        },
                        {
                            "index": 1,
                            "label": "fast"
                        }
                    ],
                    "transientMessage": "Step 1: slow = A, fast = B"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "slow"
                        },
                        {
                            "index": 3,
                            "label": "fast"
                        }
                    ],
                    "transientMessage": "Step 2: slow = B, fast = D"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        4
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "slow"
                        },
                        {
                            "index": 4,
                            "label": "fast"
                        }
                    ],
                    "transientMessage": "Step 3: slow = C, fast = None. Middle found!"
                }
            ],
            "code": "def middleNode(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    return slow",
            "keyInsight": "The fast pointer will reach the end when the slow one is at the middle.",
            "testCases": [
                {
                    "input": "head = [1, 2, 3, 4, 5]",
                    "output": "[3, 4, 5]"
                }
            ],
            "description": "Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5]",
                    "output": "[3,4,5]",
                    "explanation": "The middle node is 3."
                },
                {
                    "input": "head = [1,2,3,4,5,6]",
                    "output": "[4,5,6]",
                    "explanation": "There are two middles, return the second one."
                }
            ],
            "constraints": [
                "The number of nodes is in range [1, 100].",
                "1 <= Node.val <= 100"
            ],
            "hints": [
                "Use slow and fast pointers.",
                "Slow moves 1 step, fast moves 2 steps.",
                "When fast reaches end, slow is at middle."
            ],
            "relatedProblems": [
                "delete-the-middle-node-of-a-linked-list",
                "linked-list-cycle",
                "reorder-list"
            ],
            "videoId": "A2_ldqM4QcY"
        },
        "time-needed-to-buy-tickets": {
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc49\ud83d\udc48",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use two pointers to simulate buying tickets in a queue.",
            "intuition": [
                "Track the time taken for each person to buy their ticket using two pointers.",
                "Adjust pointers based on the number of tickets needed and available."
            ],
            "visualizationType": "array",
            "initialState": [
                2,
                3,
                2
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Front"
                        }
                    ],
                    "transientMessage": "First person buys a ticket (1/2), time = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "Middle"
                        }
                    ],
                    "transientMessage": "Second person buys a ticket (1/3), time = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "Back"
                        }
                    ],
                    "transientMessage": "Third person buys a ticket (1/2), time = 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Front"
                        }
                    ],
                    "transientMessage": "First person buys a ticket (2/2), time = 4"
                }
            ],
            "code": "def time_needed_to_buy(tickets, k):\n    time = 0\n    n = len(tickets)\n    while tickets[k] > 0:\n        for i in range(n):\n            if tickets[i] == 0:\n                continue\n            tickets[i] -= 1\n            time += 1\n            if tickets[k] == 0:\n                return time",
            "keyInsight": "Simulate the queue by decrementing ticket counts and incrementing time.",
            "testCases": [
                {
                    "input": "tickets = [2,3,2]; k = 2",
                    "output": "6"
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Time Needed to Buy Tickets",
            "description": "There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line. You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i]. Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line to buy more tickets. Return the time taken for the person at position k to finish buying all their tickets.",
            "examples": [
                {
                    "input": "tickets = [2,3,2], k = 2",
                    "output": "6",
                    "explanation": "Person 2 finishes after 6 seconds."
                },
                {
                    "input": "tickets = [5,1,1,1], k = 0",
                    "output": "8",
                    "explanation": "Person 0 needs 5 tickets, takes 8 seconds total."
                }
            ],
            "constraints": [
                "n == tickets.length",
                "1 <= n <= 100",
                "1 <= tickets[i] <= 100",
                "0 <= k < n"
            ],
            "hints": [
                "For people before k: min(tickets[i], tickets[k]).",
                "For people at k: tickets[k].",
                "For people after k: min(tickets[i], tickets[k] - 1)."
            ],
            "relatedProblems": [
                "number-of-students-unable-to-eat-lunch"
            ],
            "videoId": "6Sk5xZCr94o"
        },
        "minimum-absolute-difference": {
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc49\ud83d\udc48",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Sort the array and use two pointers to find the minimum absolute difference.",
            "intuition": [
                "Sorting helps in easily finding the closest pairs by comparing adjacent elements.",
                "Two pointers starting from consecutive positions can efficiently track the smallest difference."
            ],
            "visualizationType": "array",
            "initialState": [
                4,
                2,
                1,
                3
            ],
            "animationSteps": [
                {
                    "type": "sort",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "accent",
                    "transientMessage": "Sorting the array: [1, 2, 3, 4]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 1,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Difference = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "L"
                        },
                        {
                            "index": 2,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Difference = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "L"
                        },
                        {
                            "index": 3,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Difference = 1"
                }
            ],
            "code": "def minimumAbsDifference(nums):\n    nums.sort()\n    min_diff = float('inf')\n    result = []\n    for i in range(1, len(nums)):\n        diff = nums[i] - nums[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = [[nums[i-1], nums[i]]]\n        elif diff == min_diff:\n            result.append([nums[i-1], nums[i]])\n    return result",
            "keyInsight": "Sorting the array allows us to only check adjacent elements for the minimum difference.",
            "testCases": [
                {
                    "input": "nums = [4, 2, 1, 3]",
                    "output": "[[1, 2], [2, 3], [3, 4]]"
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Minimum Absolute Difference",
            "description": "Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. Return a list of pairs in ascending order (with respect to pairs), each pair [a, b] follows a < b.",
            "examples": [
                {
                    "input": "arr = [4,2,1,3]",
                    "output": "[[1,2],[2,3],[3,4]]",
                    "explanation": "Min diff is 1, all adjacent pairs after sorting."
                },
                {
                    "input": "arr = [1,3,6,10,15]",
                    "output": "[[1,3]]",
                    "explanation": "Min diff is 2."
                }
            ],
            "constraints": [
                "2 <= arr.length <= 10^5",
                "-10^6 <= arr[i] <= 10^6"
            ],
            "hints": [
                "Sort the array first.",
                "Minimum difference must be between adjacent elements.",
                "Find min diff, then collect all pairs with that diff."
            ],
            "relatedProblems": [
                "minimum-absolute-difference-in-bst",
                "k-diff-pairs-in-an-array"
            ],
            "videoId": "mH1aEjOEjcQ"
        },
        "missing-number": {
            "pattern": "Math",
            "patternEmoji": "\u2716\ufe0f\u2795",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Calculate the expected sum and subtract the actual sum.",
            "intuition": [
                "Use the formula for the sum of the first n natural numbers.",
                "Subtract the actual sum from this expected sum to find the missing number."
            ],
            "visualizationType": "array",
            "initialState": [
                3,
                0,
                1
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "accent",
                    "transientMessage": "Sum of given numbers = 4"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "success",
                    "transientMessage": "Expected sum for n=3 = 6"
                }
            ],
            "code": "def missingNumber(nums):\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum",
            "keyInsight": "The sum of numbers from 0 to n is a known formula: n(n+1)/2.",
            "testCases": [
                {
                    "input": "nums = [3,0,1]",
                    "output": "2"
                },
                {
                    "input": "nums = [9,6,4,2,3,5,7,0,1]",
                    "output": "8"
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Missing Number",
            "description": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
            "examples": [
                {
                    "input": "nums = [3,0,1]",
                    "output": "2",
                    "explanation": "n = 3, range is [0,3], 2 is missing."
                },
                {
                    "input": "nums = [0,1]",
                    "output": "2",
                    "explanation": "n = 2, range is [0,2], 2 is missing."
                }
            ],
            "constraints": [
                "n == nums.length",
                "1 <= n <= 10^4",
                "0 <= nums[i] <= n",
                "All numbers in nums are unique."
            ],
            "hints": [
                "Use XOR: XOR all numbers 0 to n, then XOR with array.",
                "Or use sum formula: n*(n+1)/2 - sum(nums).",
                "Both approaches are O(n) time, O(1) space."
            ],
            "relatedProblems": [
                "single-number",
                "find-the-duplicate-number",
                "first-missing-positive"
            ],
            "videoId": "WnPLSRLSANE"
        },
        "minimum-time-visiting-all-points": {
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc49\ud83d\udc48",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use two pointers to traverse points and calculate min time.",
            "intuition": [
                "Calculate the time to move from one point to another using Manhattan distance.",
                "Traverse through all points sequentially."
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    1,
                    1
                ],
                [
                    3,
                    4
                ],
                [
                    -1,
                    0
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Start"
                        }
                    ],
                    "transientMessage": "At (1, 1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Current"
                        },
                        {
                            "index": 1,
                            "label": "Next"
                        }
                    ],
                    "transientMessage": "Move to (3, 4) in 5 units."
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "Current"
                        },
                        {
                            "index": 2,
                            "label": "Next"
                        }
                    ],
                    "transientMessage": "Move to (-1, 0) in 5 units."
                }
            ],
            "code": "def minTimeToVisitAllPoints(points):\n    total_time = 0\n    for i in range(len(points) - 1):\n        current_point = points[i]\n        next_point = points[i + 1]\n        time_to_next = max(abs(next_point[0] - current_point[0]), abs(next_point[1] - current_point[1]))\n        total_time += time_to_next\n    return total_time",
            "keyInsight": "Manhattan distance gives the minimum time to move between two points.",
            "testCases": [
                {
                    "input": "points = [[1,1],[3,4],[-1,0]]",
                    "output": "7"
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Minimum Time Visiting All Points",
            "description": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points. You can move diagonally 1 unit in 1 second, or move horizontally or vertically 1 unit in 1 second.",
            "examples": [
                {
                    "input": "points = [[1,1],[3,4],[-1,0]]",
                    "output": "7",
                    "explanation": "(1,1) to (3,4) = 3 steps, (3,4) to (-1,0) = 4 steps."
                },
                {
                    "input": "points = [[3,2],[-2,2]]",
                    "output": "5",
                    "explanation": "5 horizontal steps."
                }
            ],
            "constraints": [
                "points.length == n",
                "1 <= n <= 100",
                "-1000 <= points[i][0], points[i][1] <= 1000"
            ],
            "hints": [
                "For two points, time = max(|dx|, |dy|).",
                "Chebyshev distance works here.",
                "Sum distances between consecutive points."
            ],
            "relatedProblems": [
                "minimum-cost-to-make-at-least-one-valid-path-in-a-grid"
            ],
            "videoId": "QJz-0VmNpuE"
        },
        "fizz-buzz": {
            "pattern": "Iterative",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Iterate through numbers 1 to n, appending 'Fizz', 'Buzz', or 'FizzBuzz' based on divisibility.",
            "intuition": [
                "Check each number for divisibility by 3 and 5.",
                "Use modulo operation to determine if a number is divisible."
            ],
            "visualizationType": "array",
            "initialState": [],
            "animationSteps": [
                {
                    "type": "append",
                    "value": "1",
                    "transientMessage": "1 is not divisible by 3 or 5, append '1'"
                },
                {
                    "type": "append",
                    "value": "Fizz",
                    "transientMessage": "2 is not divisible by 3 or 5, append '2'"
                },
                {
                    "type": "append",
                    "value": "Buzz",
                    "transientMessage": "3 is divisible by 3, append 'Buzz'"
                },
                {
                    "type": "append",
                    "value": "4",
                    "transientMessage": "4 is not divisible by 3 or 5, append '4'"
                },
                {
                    "type": "append",
                    "value": "FizzBuzz",
                    "transientMessage": "15 is divisible by both 3 and 5, append 'FizzBuzz'"
                }
            ],
            "code": "def fizzBuzz(n):\n    result = []\n    for i in range(1, n+1):\n        if i % 15 == 0:\n            result.append('FizzBuzz')\n        elif i % 3 == 0:\n            result.append('Fizz')\n        elif i % 5 == 0:\n            result.append('Buzz')\n        else:\n            result.append(str(i))\n    return result",
            "keyInsight": "Modulo operation helps in checking divisibility efficiently.",
            "testCases": [
                {
                    "input": "n = 15",
                    "output": "['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz']"
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Fizz Buzz",
            "description": "Given an integer n, return a string array answer (1-indexed) where: answer[i] == \"FizzBuzz\" if i is divisible by 3 and 5, answer[i] == \"Fizz\" if i is divisible by 3, answer[i] == \"Buzz\" if i is divisible by 5, answer[i] == i (as a string) if none of the above conditions are true.",
            "examples": [
                {
                    "input": "n = 3",
                    "output": "[\"1\",\"2\",\"Fizz\"]",
                    "explanation": "1 and 2 are neither, 3 is divisible by 3."
                },
                {
                    "input": "n = 5",
                    "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
                    "explanation": "5 is divisible by 5."
                }
            ],
            "constraints": [
                "1 <= n <= 10^4"
            ],
            "hints": [
                "Check divisibility by 15 first (3 AND 5).",
                "Then check 3, then 5, then default to number.",
                "Use string concatenation for cleaner code."
            ],
            "relatedProblems": [
                "fizz-buzz-multithreaded"
            ],
            "videoId": "AfxHGNRtFac"
        },
        "count-and-say": {
            "pattern": "Iterative with String Manipulation",
            "patternEmoji": "\ud83d\udd04\ud83d\udcac",
            "timeComplexity": "O(n * m)",
            "spaceComplexity": "O(m)",
            "oneliner": "Iteratively build each sequence by counting and saying the previous one.",
            "intuition": [
                "Start with the initial '1' and iteratively generate the next sequence by describing the current one.",
                "Use a loop to count consecutive digits and form the new string accordingly."
            ],
            "visualizationType": "string",
            "initialState": "1",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "First iteration: '1' -> '1 one'"
                },
                {
                    "type": "update",
                    "newString": "11",
                    "color": "success",
                    "transientMessage": "Second iteration: '1 one' -> '2 ones'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "transientMessage": "Third iteration: '2 ones' -> '1 two, 1 one'"
                }
            ],
            "code": "def countAndSay(n):\n    if n == 1:\n        return '1'\n    current = '1'\n    for _ in range(1, n):\n        next_seq = ''\n        i = 0\n        while i < len(current):\n            count = 1\n            while i + 1 < len(current) and current[i] == current[i + 1]:\n                i += 1\n                count += 1\n            next_seq += str(count) + current[i]\n            i += 1\n        current = next_seq\n    return current",
            "keyInsight": "Each number is generated by reading off the digits of the previous number.",
            "testCases": [
                {
                    "input": "n = 1",
                    "output": "\"1\""
                },
                {
                    "input": "n = 4",
                    "output": "\"1211\""
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Count and Say",
            "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula: countAndSay(1) = \"1\", countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1). To determine how you \"say\" a digit string, group it into runs of consecutive identical digits. Then for each group, say the number of digits, then the digit.",
            "examples": [
                {
                    "input": "n = 1",
                    "output": "\"1\"",
                    "explanation": "Base case."
                },
                {
                    "input": "n = 4",
                    "output": "\"1211\"",
                    "explanation": "1 -> 11 -> 21 -> 1211"
                }
            ],
            "constraints": [
                "1 <= n <= 30"
            ],
            "hints": [
                "Build iteratively from 1 to n.",
                "For each string, group consecutive digits.",
                "Build next string: count + digit for each group."
            ],
            "relatedProblems": [
                "encode-and-decode-strings",
                "string-compression"
            ],
            "videoId": "a1v3GIaJNoM"
        },
        "two-sum-iv---input-is-a-bst": {
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc49\ud83d\udc48",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Use in-order traversal to collect elements, then apply two-pointer technique.",
            "intuition": [
                "Perform an in-order traversal of the BST to get a sorted list of numbers.",
                "Use two pointers starting from ends of this sorted list to find the pair that sums up to the target."
            ],
            "visualizationType": "array",
            "initialState": [
                2,
                7,
                11,
                15
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 3,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Sum = 17. Too big!"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 2,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Sum = 13. Match!"
                }
            ],
            "code": "def twoSumBST(root, target):\n    def inorder(node):\n        if not node: return []\n        return inorder(node.left) + [node.val] + inorder(node.right)\n    nums = inorder(root)\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
            "keyInsight": "The BST in-order traversal provides a sorted array, enabling the two-pointer technique.",
            "testCases": [
                {
                    "input": "root = TreeNode(2, TreeNode(1), TreeNode(3)); target = 4",
                    "output": "[1, 3]"
                },
                {
                    "input": "root = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(6, None, TreeNode(7))); target = 9",
                    "output": "[2, 7]"
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Two Sum IV - Input is a BST",
            "description": "Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.",
            "examples": [
                {
                    "input": "root = [5,3,6,2,4,null,7], k = 9",
                    "output": "true",
                    "explanation": "5 + 4 = 9."
                },
                {
                    "input": "root = [5,3,6,2,4,null,7], k = 28",
                    "output": "false",
                    "explanation": "No pair sums to 28."
                }
            ],
            "constraints": [
                "The number of nodes is in range [1, 10^4].",
                "-10^4 <= Node.val <= 10^4",
                "root is guaranteed to be a valid BST.",
                "-10^5 <= k <= 10^5"
            ],
            "hints": [
                "Use in-order traversal to get sorted array, then two pointers.",
                "Or use a hash set while traversing.",
                "For each node, check if k - node.val exists."
            ],
            "relatedProblems": [
                "two-sum",
                "two-sum-ii---input-array-is-sorted",
                "two-sum-iii---data-structure-design"
            ],
            "videoId": "cxoOxinXYiE"
        },
        "isomorphic-strings": {
            "title": "Isomorphic Strings",
            "pattern": "Hash Map (Bi-directional)",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Map s[i]->t[i] AND t[i]->s[i]; detect conflicts.",
            "intuition": [
                "\ud83c\udfaf 'egg' -> 'add'. e->a, g->d.",
                "\ud83e\udde0 Must be consistent (1-to-1 mapping).",
                "\ud83d\udca1 If 'e' maps to 'a', 'a' must map back to 'e' ONLY."
            ],
            "testCases": [
                {
                    "input": "s = \"egg\"; t = \"add\"",
                    "output": "true"
                },
                {
                    "input": "s = \"foo\"; t = \"bar\"",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Iterate",
                    "visual": "Pair (s[i], t[i]).",
                    "explanation": "Check character mapping."
                },
                {
                    "step": 2,
                    "title": "Check S->T",
                    "visual": "MapS[s[i]] exists? Must equal t[i].",
                    "explanation": "Forward consistency."
                },
                {
                    "step": 3,
                    "title": "Check T->S",
                    "visual": "MapT[t[i]] exists? Must equal s[i].",
                    "explanation": "Backward consistency (No two chars map to same target)."
                }
            ],
            "code": "def isIsomorphic(s, t):\n    mapST, mapTS = {}, {}\n    for c1, c2 in zip(s, t):\n        if (c1 in mapST and mapST[c1] != c2) or \\\n           (c2 in mapTS and mapTS[c2] != c1):\n            return False\n        mapST[c1] = c2\n        mapTS[c2] = c1\n    return True",
            "keyInsight": "Using two maps prevents 'many-to-one' mapping errors (like 'ab' -> 'cc').",
            "visualizationType": "string",
            "initialState": "egg -> add",
            "animationSteps": [],
            "description": "Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
            "examples": [
                {
                    "input": "s = \"egg\", t = \"add\"",
                    "output": "true",
                    "explanation": "e->a, g->d"
                },
                {
                    "input": "s = \"foo\", t = \"bar\"",
                    "output": "false",
                    "explanation": "o cannot map to both a and r."
                }
            ],
            "constraints": [
                "1 <= s.length <= 5 * 10^4",
                "t.length == s.length",
                "s and t consist of any valid ascii character."
            ],
            "hints": [
                "Use two hash maps for bidirectional mapping.",
                "Map s[i] to t[i] and t[i] to s[i].",
                "If any mapping conflicts, return false."
            ],
            "relatedProblems": [
                "word-pattern",
                "word-pattern-ii"
            ],
            "videoId": "7yF-U1hLEqQ"
        },
        "word-pattern": {
            "title": "Word Pattern",
            "pattern": "Hash Map (Bi-directional)",
            "patternEmoji": "\ud83e\udde9",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Same as Isomorphic Strings, but mapping Char -> Word.",
            "intuition": [
                "\ud83c\udfaf Pattern 'abba' and words 'dog cat cat dog'.",
                "\ud83e\udde0 a -> dog, b -> cat.",
                "\ud83d\udca1 Split string by space, then check 1-to-1 mapping."
            ],
            "testCases": [
                {
                    "input": "pattern = \"abba\"; s = \"dog cat cat dog\"",
                    "output": "true"
                },
                {
                    "input": "pattern = \"abba\"; s = \"dog cat cat fish\"",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Split",
                    "visual": "['dog', 'cat', 'cat', 'dog']",
                    "explanation": "Get tokens."
                },
                {
                    "step": 2,
                    "title": "Length Check",
                    "visual": "If len(pattern) != len(words): False.",
                    "explanation": "Must match length."
                },
                {
                    "step": 3,
                    "title": "Bi-Map",
                    "visual": "Map P->W and W->P. Check conflicts.",
                    "explanation": "Ensure consistency."
                }
            ],
            "code": "def wordPattern(pattern, s):\n    words = s.split()\n    if len(pattern) != len(words): return False\n    c_to_w, w_to_c = {}, {}\n    for c, w in zip(pattern, words):\n        if c in c_to_w and c_to_w[c] != w: return False\n        if w in w_to_c and w_to_c[w] != c: return False\n        c_to_w[c] = w\n        w_to_c[w] = c\n    return True",
            "keyInsight": "Don't forget to check if lengths differ first!",
            "visualizationType": "string",
            "initialState": "abba -> dog cat cat dog",
            "animationSteps": [],
            "description": "Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.",
            "examples": [
                {
                    "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
                    "output": "true",
                    "explanation": "a->dog, b->cat"
                },
                {
                    "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
                    "output": "false",
                    "explanation": "a cannot map to both dog and fish."
                }
            ],
            "constraints": [
                "1 <= pattern.length <= 300",
                "pattern contains only lowercase letters.",
                "1 <= s.length <= 3000",
                "s contains lowercase letters and spaces."
            ],
            "hints": [
                "Split s by spaces to get words array.",
                "Use two maps: pattern[i] -> word and word -> pattern[i].",
                "Check for conflicts in both directions."
            ],
            "relatedProblems": [
                "isomorphic-strings",
                "word-pattern-ii"
            ],
            "videoId": "W_akoecmCbM"
        },
        "group-anagrams": {
            "title": "Group Anagrams",
            "pattern": "Hash Map",
            "patternEmoji": "\ud83d\udcc2",
            "timeComplexity": "O(NK)",
            "spaceComplexity": "O(NK)",
            "oneliner": "Map sorted string (or char-count tuple) to list of strings.",
            "intuition": [
                "\ud83c\udfaf All anagrams have the same 'signature'.",
                "\ud83e\udde0 Signature = sorted string ('eat' -> 'aet').",
                "\ud83d\udca1 Store {signature: [list of words]}."
            ],
            "testCases": [
                {
                    "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
                    "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
                },
                {
                    "input": "strs = [\"\"]",
                    "output": "[[\"\"]]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Hash Key",
                    "visual": "\"eat\" -> (1,0,0...1...1) OR \"aet\"",
                    "explanation": "Generate canonical key."
                },
                {
                    "step": 2,
                    "title": "Bucket",
                    "visual": "Map[key].append(word).",
                    "explanation": "Group them."
                },
                {
                    "step": 3,
                    "title": "Collect",
                    "visual": "Return Map.values()",
                    "explanation": "List of lists."
                }
            ],
            "code": "def groupAnagrams(strs):\n    from collections import defaultdict\n    res = defaultdict(list)\n    for s in strs:\n        # Using tuple(sorted(s)) as key\n        # Or char count tuple for O(N) instead of O(N log K)\n        count = [0] * 26\n        for c in s:\n            count[ord(c) - ord('a')] += 1\n        res[tuple(count)].append(s)\n    return list(res.values())",
            "keyInsight": "Using a count-tuple `(2, 1, 0...)` as a dictionary key is efficient and avoids sorting overhead.",
            "visualizationType": "string",
            "initialState": "eat, tea, tan, ate, nat, bat",
            "animationSteps": [],
            "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
            "examples": [
                {
                    "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
                    "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
                    "explanation": "Grouped by sorted characters."
                },
                {
                    "input": "strs = [\"\"]",
                    "output": "[[\"\"]]",
                    "explanation": "Empty string is its own group."
                }
            ],
            "constraints": [
                "1 <= strs.length <= 10^4",
                "0 <= strs[i].length <= 100",
                "strs[i] consists of lowercase English letters."
            ],
            "hints": [
                "Sort each word and use as key.",
                "Or use character count tuple as key.",
                "Group words with same key together."
            ],
            "relatedProblems": [
                "valid-anagram",
                "find-all-anagrams-in-a-string",
                "group-shifted-strings"
            ],
            "videoId": "vzdNOK2oB2E"
        },
        "contains-duplicate-ii": {
            "title": "Contains Duplicate II",
            "pattern": "Sliding Window / Hash Map",
            "patternEmoji": "\u26a0\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(k)",
            "oneliner": "Maintain a window of size k using a set; duplicate in window triggers True.",
            "intuition": [
                "\ud83c\udfaf Duplicate must be within distance k (abs(i-j) <= k).",
                "\ud83e\udde0 Keep latest k elements in a set.",
                "\ud83d\udca1 If current num is in set -> found it!"
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,1]; k = 3",
                    "output": "true"
                },
                {
                    "input": "nums = [1,2,3,1,2,3]; k = 2",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Expand",
                    "visual": "Add nums[i] to window set.",
                    "explanation": "Track recent."
                },
                {
                    "step": 2,
                    "title": "Shrink",
                    "visual": "If window size > k, remove nums[i-k].",
                    "explanation": "Maintain invariant."
                },
                {
                    "step": 3,
                    "title": "Check",
                    "visual": "nums[i] already in set? True.",
                    "explanation": "Collision detected."
                }
            ],
            "code": "def containsNearbyDuplicate(nums, k):\n    window = set()\n    l = 0\n    for r in range(len(nums)):\n        if r - l > k:\n            window.remove(nums[l])\n            l += 1\n        if nums[r] in window:\n            return True\n        window.add(nums[r])\n    return False",
            "keyInsight": "Removing the element falling out of the window makes lookups O(1).",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                1
            ],
            "animationSteps": [],
            "description": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.",
            "examples": [
                {
                    "input": "nums = [1,2,3,1], k = 3",
                    "output": "true",
                    "explanation": "nums[0] == nums[3] and 3-0 = 3 <= 3."
                },
                {
                    "input": "nums = [1,2,3,1,2,3], k = 2",
                    "output": "false",
                    "explanation": "Duplicate 1s are 3 apart, not <= 2."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^5",
                "-10^9 <= nums[i] <= 10^9",
                "0 <= k <= 10^5"
            ],
            "hints": [
                "Use sliding window with hash set of size k.",
                "Or use hash map storing last seen index.",
                "Check if current index - last index <= k."
            ],
            "relatedProblems": [
                "contains-duplicate",
                "contains-duplicate-iii"
            ],
            "videoId": "ypn0aZ0nrL4"
        },
        "longest-consecutive-sequence": {
            "title": "Longest Consecutive Sequence",
            "pattern": "Hash Set",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Only start counting if (num-1) is NOT in set. This ensures we only count from sequence starts.",
            "intuition": [
                "\ud83c\udfaf We want 1, 2, 3, 4 given unsorted inputs.",
                "\ud83e\udde0 Hash Set gives O(1) lookup.",
                "\ud83d\udca1 Key: Don't count '2' if '1' exists. Only start counting at '1'. Avoids O(n^2)."
            ],
            "testCases": [
                {
                    "input": "nums = [100,4,200,1,3,2]",
                    "output": "4"
                },
                {
                    "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
                    "output": "9"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Setify",
                    "visual": "{100, 4, 200, 1, 3, 2}",
                    "explanation": "Remove dupes, fast access."
                },
                {
                    "step": 2,
                    "title": "Check Start",
                    "visual": "Is 100-1 in set? No. Start chain. 100... len 1.\nIs 4-1 (3) in set? Yes. Skip.",
                    "explanation": "Ensure single traversal."
                },
                {
                    "step": 3,
                    "title": "Expand",
                    "visual": "At 1: 1 in, 2 in, 3 in, 4 in. Stop. Len 4.",
                    "explanation": "Count sequence."
                }
            ],
            "code": "def longestConsecutive(nums):\n    numSet = set(nums)\n    longest = 0\n    for n in numSet:\n        if (n - 1) not in numSet:\n            length = 0\n            while (n + length) in numSet:\n                length += 1\n            longest = max(length, longest)\n    return longest",
            "keyInsight": "Checking `if (n-1) not in set` ensures each sequence is only processed ONCE, making it linear.",
            "visualizationType": "array",
            "initialState": [
                100,
                4,
                200,
                1,
                3,
                2
            ],
            "animationSteps": [],
            "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.",
            "examples": [
                {
                    "input": "nums = [100,4,200,1,3,2]",
                    "output": "4",
                    "explanation": "Longest consecutive is [1,2,3,4]."
                },
                {
                    "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
                    "output": "9",
                    "explanation": "0 to 8 is 9 consecutive."
                }
            ],
            "constraints": [
                "0 <= nums.length <= 10^5",
                "-10^9 <= nums[i] <= 10^9"
            ],
            "hints": [
                "Put all numbers in a set.",
                "For each number, check if it's the start of a sequence (n-1 not in set).",
                "If so, count consecutive numbers."
            ],
            "relatedProblems": [
                "binary-tree-longest-consecutive-sequence",
                "find-three-consecutive-integers-that-sum-to-a-given-number"
            ],
            "videoId": "P6RZZMu_maU"
        },
        "insert-delete-getrandom-o1": {
            "title": "Insert Delete GetRandom O(1)",
            "pattern": "Hash Map + Dynamic Array",
            "patternEmoji": "\ud83c\udfb2",
            "timeComplexity": "O(1)",
            "spaceComplexity": "O(n)",
            "oneliner": "Map stores {val: index}. To delete, swap val with last element, then pop.",
            "intuition": [
                "\ud83c\udfaf List allows O(1) random access (choice).",
                "\ud83e\udde0 Hashmap allows O(1) lookup/delete logic.",
                "\ud83d\udca1 Problem: Deleting from middle of list is O(n). Solution: Swap with end, then pop!"
            ],
            "testCases": [
                {
                    "input": "ops = [\"RandomizedSet\",\"insert\",\"remove\",\"getRandom\"]; args = [[],[1],[2],[]]",
                    "output": "[null,true,false,1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Insert",
                    "visual": "Append to list. Map[val] = len-1.",
                    "explanation": "Easy O(1)."
                },
                {
                    "step": 2,
                    "title": "Delete",
                    "visual": "Val at index `i`. Swap list[i] with list[end]. Update map for swapped item. Pop list.",
                    "explanation": "O(1) removal."
                },
                {
                    "step": 3,
                    "title": "Random",
                    "visual": "random.choice(list)",
                    "explanation": "Uniform distribution."
                }
            ],
            "code": "import random\nclass RandomizedSet:\n    def __init__(self):\n        self.valMap = {}\n        self.valList = []\n    def insert(self, val):\n        if val in self.valMap: return False\n        self.valMap[val] = len(self.valList)\n        self.valList.append(val)\n        return True\n    def remove(self, val):\n        if val not in self.valMap: return False\n        idx = self.valMap[val]\n        lastVal = self.valList[-1]\n        self.valList[idx] = lastVal\n        self.valMap[lastVal] = idx\n        self.valList.pop()\n        del self.valMap[val]\n        return True\n    def getRandom(self):\n        return random.choice(self.valList)",
            "keyInsight": "The 'Swap and Pop' technique is crucial for O(1) deletions in arrays.",
            "visualizationType": "array",
            "initialState": [],
            "animationSteps": [],
            "description": "Implement the RandomizedSet class: RandomizedSet() Initializes the object. bool insert(int val) Inserts an item val if not present. Returns true if not present, false otherwise. bool remove(int val) Removes an item val if present. Returns true if present, false otherwise. int getRandom() Returns a random element from the current set. Each element must have the same probability of being returned.",
            "examples": [
                {
                    "input": "[[\"RandomizedSet\"],[\"insert\"],[\"remove\"],[\"insert\"],[\"getRandom\"],[\"remove\"],[\"insert\"],[\"getRandom\"]], [[],[1],[2],[2],[],[1],[2],[]]",
                    "output": "[null,true,false,true,2,true,false,2]",
                    "explanation": "Operations performed in sequence."
                }
            ],
            "constraints": [
                "-2^31 <= val <= 2^31 - 1",
                "At most 2 * 10^5 calls will be made to insert, remove, and getRandom.",
                "There will be at least one element in the data structure when getRandom is called."
            ],
            "hints": [
                "Use array + hash map.",
                "Hash map stores val -> index.",
                "On remove, swap with last element for O(1)."
            ],
            "relatedProblems": [
                "insert-delete-getrandom-o1-duplicates-allowed"
            ],
            "videoId": "j4KwhBziOpg"
        },
        "how-many-numbers-are-smaller-than-the-current-number": {
            "title": "How Many Numbers Smaller",
            "pattern": "Bucket Sort / Counting",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1) (range limited)",
            "oneliner": "Count occurrences, prefix sum to find cumulative count smaller.",
            "intuition": [
                "\ud83c\udfaf If 5 numbers are <= 7, and 2 numbers are == 7, then 3 are < 7.",
                "\ud83e\udde0 Frequency array tracks counts.",
                "\ud83d\udca1 Prefix sums give 'count of numbers <= i'."
            ],
            "testCases": [
                {
                    "input": "nums = [8,1,2,2,3]",
                    "output": "[4,0,1,1,3]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Count",
                    "visual": "Freq array of size 101.",
                    "explanation": "Constraints say nums[i] <= 100."
                },
                {
                    "step": 2,
                    "title": "Prefix Sum",
                    "visual": "freq[i] += freq[i-1].",
                    "explanation": "Cumulative count."
                },
                {
                    "step": 3,
                    "title": "Map",
                    "visual": "Res[i] = freq[nums[i]-1].",
                    "explanation": "Get numbers strictly smaller."
                }
            ],
            "code": "def smallerNumbersThanCurrent(nums):\n    count = [0] * 102\n    for n in nums: count[n+1] += 1\n    for i in range(1, 102): count[i] += count[i-1]\n    return [count[n] for n in nums]",
            "keyInsight": "Using the input constraints (0-100) allows faster-than-sorting O(n) solution using counting sort ideas.",
            "visualizationType": "array",
            "initialState": [
                8,
                1,
                2,
                2,
                3
            ],
            "animationSteps": [],
            "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].",
            "examples": [
                {
                    "input": "nums = [8,1,2,2,3]",
                    "output": "[4,0,1,1,3]",
                    "explanation": "For 8, there are 4 smaller numbers."
                },
                {
                    "input": "nums = [6,5,4,8]",
                    "output": "[2,1,0,3]",
                    "explanation": "Count smaller numbers for each."
                }
            ],
            "constraints": [
                "2 <= nums.length <= 500",
                "0 <= nums[i] <= 100"
            ],
            "hints": [
                "Use counting sort since values <= 100.",
                "Build prefix sum of counts.",
                "Answer for nums[i] is prefix[nums[i]]."
            ],
            "relatedProblems": [
                "count-of-smaller-numbers-after-self",
                "reverse-pairs"
            ],
            "videoId": "x2K_4xNxCME"
        },
        "simplify-path": {
            "title": "Simplify Path",
            "pattern": "Stack",
            "patternEmoji": "\ud83d\udcc2",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Split by '/'. Stack keeps directories. '..' pops, '.' ignores.",
            "intuition": [
                "\ud83c\udfaf Canonical path logic.",
                "\ud83e\udde0 '..' means go up (pop).",
                "\ud83d\udca1 '.' or empty means stay (ignore)."
            ],
            "testCases": [
                {
                    "input": "path = \"/a/./b/../../c/\"",
                    "output": "\"/c\""
                },
                {
                    "input": "path = \"/../\"",
                    "output": "\"/\""
                },
                {
                    "input": "path = \"/home//foo/\"",
                    "output": "\"/home/foo\""
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Split",
                    "visual": "['a', '.', 'b', '..', '..', 'c']",
                    "explanation": "Tokenize."
                },
                {
                    "step": 2,
                    "title": "Process",
                    "visual": "'a': push. '.': skip. 'b': push. '..': pop(b). '..': pop(a). 'c': push.",
                    "explanation": "Stack operations."
                },
                {
                    "step": 3,
                    "title": "Join",
                    "visual": "'/' + join(stack)",
                    "explanation": "Rebuild."
                }
            ],
            "code": "def simplifyPath(path):\n    stack = []\n    for portion in path.split('/'):\n        if portion == '..':\n            if stack: stack.pop()\n        elif portion == '.' or not portion:\n            continue\n        else:\n            stack.append(portion)\n    return '/' + '/'.join(stack)",
            "keyInsight": "Splitting by slash handles multiple slashes `//` automatically (producing empty strings to ignore).",
            "visualizationType": "string",
            "initialState": "/a/./b/../../c/",
            "animationSteps": [],
            "description": "Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.",
            "examples": [
                {
                    "input": "path = \"/home/\"",
                    "output": "\"/home\"",
                    "explanation": "Remove trailing slash."
                },
                {
                    "input": "path = \"/../\"",
                    "output": "\"/\"",
                    "explanation": "Cannot go above root."
                },
                {
                    "input": "path = \"/home//foo/\"",
                    "output": "\"/home/foo\"",
                    "explanation": "Multiple slashes treated as one."
                }
            ],
            "constraints": [
                "1 <= path.length <= 3000",
                "path consists of English letters, digits, period '.', slash '/' or '_'."
            ],
            "hints": [
                "Split by '/' and use a stack.",
                "Ignore empty strings and '.'. Pop for '..'.",
                "Join stack with '/' at the end."
            ],
            "relatedProblems": [
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "qYlHrAKJfyA"
        },
        "min-stack": {
            "title": "Min Stack",
            "pattern": "Stack (Two Stacks)",
            "patternEmoji": "\u2b07\ufe0f",
            "timeComplexity": "O(1)",
            "spaceComplexity": "O(n)",
            "oneliner": "Maintain a second stack tracking the minimum value at each depth.",
            "intuition": [
                "\ud83c\udfaf Get Min in O(1).",
                "\ud83e\udde0 Normal stack holds values.",
                "\ud83d\udca1 MinStack holds min_so_far. Push? min(val, top). Pop? Pop both."
            ],
            "testCases": [
                {
                    "input": "ops = [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]; args = [[],[-2],[0],[-3],[],[],[],[]]",
                    "output": "[null,null,null,null,-3,null,0,-2]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Push",
                    "visual": "Main: [-2]. MinStack: [-2].",
                    "explanation": "Init."
                },
                {
                    "step": 2,
                    "title": "Push Smaller",
                    "visual": "Main: [-2, -3]. MinStack: [-2, -3].",
                    "explanation": "New min found."
                },
                {
                    "step": 3,
                    "title": "Pop",
                    "visual": "Pop both. Min reverts to -2.",
                    "explanation": "Sync."
                }
            ],
            "code": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n    def push(self, val):\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n    def pop(self):\n        self.stack.pop()\n        self.minStack.pop()\n    def top(self): return self.stack[-1]\n    def getMin(self): return self.minStack[-1]",
            "keyInsight": "The minimum history needs to be stacked because when we pop the minimum, we need to know what the *previous* minimum was.",
            "visualizationType": "array",
            "initialState": [],
            "animationSteps": [],
            "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
            "examples": [
                {
                    "input": "[[\"MinStack\"],[\"push\"],[\"push\"],[\"push\"],[\"getMin\"],[\"pop\"],[\"top\"],[\"getMin\"]], [[],[-2],[0],[-3],[],[],[],[]]",
                    "output": "[null,null,null,null,-3,null,0,-2]",
                    "explanation": "Min tracking works correctly."
                }
            ],
            "constraints": [
                "-2^31 <= val <= 2^31 - 1",
                "Methods pop, top and getMin will always be called on non-empty stacks.",
                "At most 3 * 10^4 calls will be made to push, pop, top, and getMin."
            ],
            "hints": [
                "Use two stacks: one for values, one for minimums.",
                "Or store pairs (value, current_min) in single stack.",
                "Update min on each push."
            ],
            "relatedProblems": [
                "max-stack",
                "implement-stack-using-queues"
            ],
            "videoId": "qkLl7nAwDPo"
        },
        "evaluate-reverse-polish-notation": {
            "title": "Eval RPN",
            "pattern": "Stack",
            "patternEmoji": "\u2797\u2796",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Push numbers. Operator? Pop two, apply, push result.",
            "intuition": [
                "\ud83c\udfaf Postfix notation (3 4 +) eliminates parenthesis ambiguity.",
                "\ud83e\udde0 Stack holds operands waiting for an operator.",
                "\ud83d\udca1 Saw '+'? Pop 4, Pop 3. Do 3+4=7. Push 7."
            ],
            "testCases": [
                {
                    "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
                    "output": "9"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Push",
                    "visual": "Stack: [2, 1]",
                    "explanation": "Operands."
                },
                {
                    "step": 2,
                    "title": "Op +",
                    "visual": "Pop 1, 2. Add -> 3. Stack: [3].",
                    "explanation": "Execute."
                },
                {
                    "step": 3,
                    "title": "Continue",
                    "visual": "Push 3. Op *. 3 * 3 = 9.",
                    "explanation": "Chain."
                }
            ],
            "code": "def evalRPN(tokens):\n    stack = []\n    for t in tokens:\n        if t not in \"+-*/\":\n            stack.append(int(t))\n        else:\n            b, a = stack.pop(), stack.pop()\n            if t == \"+\": stack.append(a + b)\n            elif t == \"-\": stack.append(a - b)\n            elif t == \"*\": stack.append(a * b)\n            else: stack.append(int(a / b))\n    return stack[0]",
            "keyInsight": "Careful with division: 'int(a / b)' truncates toward zero in Python, unlike '//' which floors.",
            "visualizationType": "array",
            "initialState": [
                "2",
                "1",
                "+",
                "3",
                "*"
            ],
            "animationSteps": [],
            "description": "Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, and /. Each operand may be an integer or another expression.",
            "examples": [
                {
                    "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
                    "output": "9",
                    "explanation": "((2 + 1) * 3) = 9"
                },
                {
                    "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
                    "output": "6",
                    "explanation": "(4 + (13 / 5)) = 6"
                }
            ],
            "constraints": [
                "1 <= tokens.length <= 10^4",
                "tokens[i] is an operator or an integer in range [-200, 200]."
            ],
            "hints": [
                "Use a stack.",
                "Push operands. On operator, pop two operands, compute, push result.",
                "Note: division truncates toward zero."
            ],
            "relatedProblems": [
                "basic-calculator",
                "basic-calculator-ii",
                "expression-add-operators"
            ],
            "videoId": "iu0082c4HDE"
        },
        "basic-calculator": {
            "title": "Basic Calculator",
            "pattern": "Stack (Signs)",
            "patternEmoji": "\ud83d\udc22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Track result and sign. Parenthesis? Push current result & sign, reset.",
            "intuition": [
                "\ud83c\udfaf Linear scan with recursion simulated by stack.",
                "\ud83e\udde0 '(': Stash current state. Start fresh sub-problem.",
                "\ud83d\udca1 ')': Finish sub-problem, multiply by stashed sign, add stashed result."
            ],
            "testCases": [
                {
                    "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
                    "output": "23"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Update 'res' with num*sign.",
                    "explanation": "Accumulate."
                },
                {
                    "step": 2,
                    "title": "Open (",
                    "visual": "Push res, sign. Res=0, Sign=1.",
                    "explanation": "Context switch."
                },
                {
                    "step": 3,
                    "title": "Close )",
                    "visual": "Res = Res * pop_sign + pop_res.",
                    "explanation": "Resolve scope."
                }
            ],
            "code": "def calculate(s):\n    res, num, sign, stack = 0, 0, 1, []\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c in '+-':\n            res += sign * num\n            num = 0\n            sign = 1 if c == '+' else -1\n        elif c == '(': \n            stack.append(res)\n            stack.append(sign)\n            sign = 1\n            res = 0\n        elif c == ')':\n            res += sign * num\n            res *= stack.pop()\n            res += stack.pop()\n            num = 0\n    return res + num * sign",
            "keyInsight": "Only one 'sign' variable is needed to handle +/-, applying it lazily when a number ends.",
            "visualizationType": "string",
            "initialState": "(1+(4+5+2)-3)+(6+8)",
            "animationSteps": [],
            "description": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions.",
            "examples": [
                {
                    "input": "s = \"1 + 1\"",
                    "output": "2",
                    "explanation": "1 + 1 = 2"
                },
                {
                    "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
                    "output": "23",
                    "explanation": "Evaluate nested parentheses."
                }
            ],
            "constraints": [
                "1 <= s.length <= 3 * 10^5",
                "s consists of digits, '+', '-', '(', ')', and ' '.",
                "s represents a valid expression.",
                "'+' is not used as unary operation."
            ],
            "hints": [
                "Use stack to handle nested parentheses.",
                "Track current result and sign.",
                "On '(', push current state. On ')', pop and apply."
            ],
            "relatedProblems": [
                "basic-calculator-ii",
                "basic-calculator-iii",
                "evaluate-reverse-polish-notation"
            ],
            "videoId": "081AqOuasw0"
        },
        "implement-stack-using-queues": {
            "title": "Stack using Queues",
            "pattern": "Queue Rotation",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "Push O(n), Pop O(1)",
            "spaceComplexity": "O(n)",
            "oneliner": "Push to queue, then rotate (pop & push back) all previous elements to keep new element at front.",
            "intuition": [
                "\ud83c\udfaf Queue is FIFO. Stack is LIFO.",
                "\ud83e\udde0 To make Queue look LIFO, the 'newest' item must be at the head.",
                "\ud83d\udca1 After appending X, rotate all other N items behind X."
            ],
            "testCases": [
                {
                    "input": "ops = [\"MyStack\",\"push\",\"push\",\"pop\",\"top\",\"empty\"]; args = [[],[1],[2],[],[],[]]",
                    "output": "[null,null,null,2,1,false]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Push X",
                    "visual": "Q appends X. Q: [1, 2, X].",
                    "explanation": "Wrong order."
                },
                {
                    "step": 2,
                    "title": "Rotate",
                    "visual": "Pop 1, Push 1. Pop 2, Push 2. Q: [X, 1, 2].",
                    "explanation": "X is now front."
                },
                {
                    "step": 3,
                    "title": "Pop",
                    "visual": "Q.popleft() returns X.",
                    "explanation": "LIFO behavior achieved."
                }
            ],
            "code": "from collections import deque\nclass MyStack:\n    def __init__(self):\n        self.q = deque()\n    def push(self, x):\n        self.q.append(x)\n        for _ in range(len(self.q) - 1):\n            self.q.append(self.q.popleft())\n    def pop(self): return self.q.popleft()\n    def top(self): return self.q[0]\n    def empty(self): return not self.q",
            "keyInsight": "Single queue is sufficient if we rotate it!",
            "visualizationType": "array",
            "initialState": [],
            "animationSteps": [],
            "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).",
            "examples": [
                {
                    "input": "[[\"MyStack\"],[\"push\"],[\"push\"],[\"top\"],[\"pop\"],[\"empty\"]], [[],[1],[2],[],[],[]]",
                    "output": "[null,null,null,2,2,false]",
                    "explanation": "Stack operations using queues."
                }
            ],
            "constraints": [
                "1 <= x <= 9",
                "At most 100 calls will be made to push, pop, top, and empty.",
                "All calls to pop and top are valid."
            ],
            "hints": [
                "On push, add to queue then rotate n-1 times.",
                "This puts new element at front.",
                "Pop and top become O(1)."
            ],
            "relatedProblems": [
                "implement-queue-using-stacks",
                "min-stack"
            ],
            "videoId": "rW4vm0-DLYc"
        },
        "add-two-numbers": {
            "title": "Add Two Numbers",
            "pattern": "Linked List Math",
            "patternEmoji": "\ud83d\udcda",
            "timeComplexity": "O(max(m, n))",
            "spaceComplexity": "O(max(m, n))",
            "oneliner": "Traverse both lists, add digits + carry, create new node.",
            "intuition": [
                "\ud83c\udfaf Just like elementary math: add right-to-left.",
                "\ud83e\udde0 Lists are already reversed (digits at head).",
                "\ud83d\udca1 Don't forget the final carry if it exists!"
            ],
            "testCases": [
                {
                    "input": "l1 = [2,4,3]; l2 = [5,6,4]",
                    "output": "[7,0,8]"
                },
                {
                    "input": "l1 = [0]; l2 = [0]",
                    "output": "[0]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "Dummy node. Carry = 0.",
                    "explanation": "Base setup."
                },
                {
                    "step": 2,
                    "title": "Add",
                    "visual": "Sum = v1 + v2 + carry. New val = Sum % 10. Carry = Sum // 10.",
                    "explanation": "Standard addition."
                },
                {
                    "step": 3,
                    "title": "Next",
                    "visual": "Move l1, l2 pointers if not null.",
                    "explanation": "Iterate."
                }
            ],
            "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef addTwoNumbers(l1, l2):\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n    while l1 or l2 or carry:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n        val = v1 + v2 + carry\n        carry = val // 10\n        val = val % 10\n        cur.next = ListNode(val)\n        cur = cur.next\n        if l1: l1 = l1.next\n        if l2: l2 = l2.next\n    return dummy.next",
            "keyInsight": "Using 'v1 = l1.val if l1 else 0' cleans up the code significantly, removing null checks inside the addition.",
            "visualizationType": "linked-list",
            "initialState": [
                2,
                4,
                3
            ],
            "animationSteps": [],
            "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
            "examples": [
                {
                    "input": "l1 = [2,4,3], l2 = [5,6,4]",
                    "output": "[7,0,8]",
                    "explanation": "342 + 465 = 807"
                },
                {
                    "input": "l1 = [9,9,9,9], l2 = [9,9,9]",
                    "output": "[8,9,9,0,1]",
                    "explanation": "9999 + 999 = 10998"
                }
            ],
            "constraints": [
                "The number of nodes in each list is in range [1, 100].",
                "0 <= Node.val <= 9",
                "The lists represent numbers without leading zeros (except 0 itself)."
            ],
            "hints": [
                "Iterate both lists simultaneously.",
                "Track carry for sums >= 10.",
                "Don't forget the final carry!"
            ],
            "relatedProblems": [
                "multiply-strings",
                "add-binary",
                "add-two-numbers-ii"
            ],
            "videoId": "wgFPrzTjm7s"
        },
        "merge-two-sorted-lists": {
            "title": "Merge Two Sorted Lists",
            "pattern": "Linked List / Two Pointers",
            "patternEmoji": "\ud83d\udd00",
            "timeComplexity": "O(m+n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use a dummy head; stitch nodes from l1 or l2 whichever is smaller.",
            "intuition": [
                "\ud83c\udfaf Zipper merge.",
                "\ud83e\udde0 Compare heads. Attach smaller to 'tail'.",
                "\ud83d\udca1 Advance the chosen one."
            ],
            "testCases": [
                {
                    "input": "list1 = [1,2,4]; list2 = [1,3,4]",
                    "output": "[1,1,2,3,4,4]"
                },
                {
                    "input": "list1 = []; list2 = []",
                    "output": "[]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Dummy",
                    "visual": "Tail -> Dummy.",
                    "explanation": "Simplifies edge cases."
                },
                {
                    "step": 2,
                    "title": "Stitch",
                    "visual": "l1.val < l2.val? Tail.next = l1. l1 = l1.next.",
                    "explanation": "Pick smallest."
                },
                {
                    "step": 3,
                    "title": "Cleanup",
                    "visual": "Tail.next = l1 or l2 (whichever remains).",
                    "explanation": "Attach rest."
                }
            ],
            "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef mergeTwoLists(list1, list2):\n    dummy = ListNode()\n    tail = dummy\n    while list1 and list2:\n        if list1.val < list2.val:\n            tail.next = list1\n            list1 = list1.next\n        else:\n            tail.next = list2\n            list2 = list2.next\n        tail = tail.next\n    if list1:\n        tail.next = list1\n    elif list2:\n        tail.next = list2\n    return dummy.next",
            "keyInsight": "We don't create new nodes; we just re-link existing ones.",
            "visualizationType": "linked-list",
            "initialState": [
                1,
                2,
                4
            ],
            "animationSteps": [],
            "description": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
            "examples": [
                {
                    "input": "list1 = [1,2,4], list2 = [1,3,4]",
                    "output": "[1,1,2,3,4,4]",
                    "explanation": "Merged in sorted order."
                },
                {
                    "input": "list1 = [], list2 = []",
                    "output": "[]",
                    "explanation": "Both empty."
                },
                {
                    "input": "list1 = [], list2 = [0]",
                    "output": "[0]",
                    "explanation": "One empty, one with element."
                }
            ],
            "constraints": [
                "The number of nodes in both lists is in range [0, 50].",
                "-100 <= Node.val <= 100",
                "Both lists are sorted in non-decreasing order."
            ],
            "hints": [
                "Use a dummy node to simplify the code.",
                "Compare heads of both lists, take the smaller one.",
                "Move the pointer forward on the list you took from."
            ],
            "relatedProblems": [
                "merge-sorted-array",
                "merge-k-sorted-lists",
                "sort-list"
            ],
            "videoId": "XIdigk956u0"
        },
        "copy-list-with-random-pointer": {
            "title": "Copy List with Random Pointer",
            "pattern": "Hash Map / Interweaving",
            "patternEmoji": "\ud83d\udcc3",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n) (or O(1) interweave)",
            "oneliner": "Two passes: 1. Create copy nodes mapped in dict. 2. Link next/random using dict.",
            "intuition": [
                "\ud83c\udfaf Deep copy means new nodes.",
                "\ud83e\udde0 Random pointers might point to nodes not visited yet.",
                "\ud83d\udca1 Map {OldNode -> NewNode} solves strict reference issues."
            ],
            "testCases": [
                {
                    "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
                    "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Map",
                    "visual": "Iterate. Map[old] = Node(old.val).",
                    "explanation": "Create clones."
                },
                {
                    "step": 2,
                    "title": "Link",
                    "visual": "Iterate. copy.next = map[old.next]. copy.random = map[old.random].",
                    "explanation": "Wire up."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Return map[head].",
                    "explanation": "Done."
                }
            ],
            "code": "class Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\ndef copyRandomList(head):\n    if not head: return None\n    oldToCopy = {None: None}\n    cur = head\n    while cur:\n        copy = Node(cur.val)\n        oldToCopy[cur] = copy\n        cur = cur.next\n    cur = head\n    while cur:\n        copy = oldToCopy[cur]\n        copy.next = oldToCopy[cur.next]\n        copy.random = oldToCopy[cur.random]\n        cur = cur.next\n    return oldToCopy[head]",
            "keyInsight": "The hashmap approach is simplest. The O(1) space 'interweaving' approach is clever but much harder to implement correctly in an interview.",
            "visualizationType": "linked-list",
            "initialState": [
                [
                    7,
                    null
                ],
                [
                    13,
                    0
                ],
                [
                    11,
                    4
                ],
                [
                    10,
                    2
                ],
                [
                    1,
                    0
                ]
            ],
            "animationSteps": [],
            "description": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list.",
            "examples": [
                {
                    "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
                    "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
                    "explanation": "Deep copy with same structure."
                }
            ],
            "constraints": [
                "0 <= n <= 1000",
                "-10^4 <= Node.val <= 10^4",
                "Node.random is null or points to a node in the list."
            ],
            "hints": [
                "Use hash map: old node -> new node.",
                "First pass: create all new nodes.",
                "Second pass: connect next and random pointers."
            ],
            "relatedProblems": [
                "clone-graph",
                "clone-binary-tree-with-random-pointer"
            ],
            "videoId": "5Y2EiZST97Y"
        },
        "reverse-linked-list-ii": {
            "title": "Reverse Linked List II",
            "pattern": "Linked List Manipulation",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Reach 'left'; reverse 'right-left' times; reconnect.",
            "intuition": [
                "\ud83c\udfaf Use a Dummy to handle edge case (left=1).",
                "\ud83e\udde0 'prev' sits before reversing starts.",
                "\ud83d\udca1 Reverse the sub-segment standard way. Fix connections."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,4,5]; left = 2; right = 4",
                    "output": "[1,4,3,2,5]"
                },
                {
                    "input": "head = [5]; left = 1; right = 1",
                    "output": "[5]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Reach",
                    "visual": "Move prev to left-1.",
                    "explanation": "Positioning."
                },
                {
                    "step": 2,
                    "title": "Reverse",
                    "visual": "For i in range(r-l): temp=curr.next; curr.next=temp.next; temp.next=prev.next; prev.next=temp.",
                    "explanation": "Bubble swap."
                },
                {
                    "step": 3,
                    "title": "Done",
                    "visual": "Return dummy.next.",
                    "explanation": "Head might change."
                }
            ],
            "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reverseBetween(head, left, right):\n    dummy = ListNode(0, head)\n    leftPrev, cur = dummy, head\n    for i in range(left - 1):\n        leftPrev, cur = cur, cur.next\n    prev = None\n    for i in range(right - left + 1):\n        tmp = cur.next\n        cur.next = prev\n        prev, cur = cur, tmp\n    # Connect\n    leftPrev.next.next = cur\n    leftPrev.next = prev\n    return dummy.next",
            "keyInsight": "It's easier to fully reverse the sublist using standard Prev/Curr/Next logic, then stitch the ends `leftPrev` and `cur` back.",
            "visualizationType": "linked-list",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [],
            "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5], left = 2, right = 4",
                    "output": "[1,4,3,2,5]",
                    "explanation": "Nodes 2-4 are reversed."
                },
                {
                    "input": "head = [5], left = 1, right = 1",
                    "output": "[5]",
                    "explanation": "Single node, nothing to reverse."
                }
            ],
            "constraints": [
                "The number of nodes is n.",
                "1 <= n <= 500",
                "-500 <= Node.val <= 500",
                "1 <= left <= right <= n"
            ],
            "hints": [
                "Use dummy node for clean edge cases.",
                "Find the node before 'left' position.",
                "Reverse nodes from left to right using standard technique."
            ],
            "relatedProblems": [
                "reverse-linked-list",
                "reverse-nodes-in-k-group"
            ],
            "videoId": "RF_M9tX4Eag"
        },
        "maximum-depth-of-binary-tree": {
            "title": "Max Depth of Binary Tree",
            "pattern": "DFS (Recursion)",
            "patternEmoji": "\ud83d\udccf",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "1 + max(dfs(left), dfs(right))",
            "intuition": [
                "\ud83c\udfaf Base case: Null node has depth 0.",
                "\ud83e\udde0 Recursive step: I am 1 deeper than my deepest child.",
                "\ud83d\udca1 Return 1 + max(L, R)."
            ],
            "testCases": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "3"
                },
                {
                    "input": "root = [1,null,2]",
                    "output": "2"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Base",
                    "visual": "If zero? Ret 0.",
                    "explanation": "Leaf check."
                },
                {
                    "step": 2,
                    "title": "Recurse",
                    "visual": "L = depth(left), R = depth(right).",
                    "explanation": "Explore."
                },
                {
                    "step": 3,
                    "title": "Combine",
                    "visual": "Ret 1 + max(L, R).",
                    "explanation": "Count me."
                }
            ],
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef maxDepth(root):\n    if not root: return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))",
            "keyInsight": "Simplest recursion pattern. BFS also works for level counting.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "3",
                    "explanation": "Root -> 20 -> 15 or 7 is 3 levels."
                },
                {
                    "input": "root = [1,null,2]",
                    "output": "2",
                    "explanation": "Root -> 2 is 2 levels."
                }
            ],
            "constraints": [
                "The number of nodes is in range [0, 10^4].",
                "-100 <= Node.val <= 100"
            ],
            "hints": [
                "Use recursion: depth = 1 + max(left, right).",
                "Or use BFS level order traversal.",
                "Count levels as you traverse."
            ],
            "relatedProblems": [
                "minimum-depth-of-binary-tree",
                "balanced-binary-tree",
                "maximum-depth-of-n-ary-tree"
            ],
            "videoId": "hTM3phVI6YQ"
        },
        "same-tree": {
            "title": "Same Tree",
            "pattern": "DFS (Recursion)",
            "patternEmoji": "\ud83d\udc6f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Check if p==q, then recurse: same(p.left, q.left) && same(p.right, q.right).",
            "intuition": [
                "\ud83c\udfaf Are they structural clones with same values?",
                "\ud83e\udde0 Both Null? True. One Null? False. Vals differ? False.",
                "\ud83d\udca1 Else, check children recursively."
            ],
            "testCases": [
                {
                    "input": "p = [1,2,3]; q = [1,2,3]",
                    "output": "true"
                },
                {
                    "input": "p = [1,2]; q = [1,null,2]",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Null Check",
                    "visual": "Both None -> True. One None -> False.",
                    "explanation": "Structure."
                },
                {
                    "step": 2,
                    "title": "Val Check",
                    "visual": "p.val != q.val -> False.",
                    "explanation": "Data."
                },
                {
                    "step": 3,
                    "title": "Recurse",
                    "visual": "return same(L,L) and same(R,R).",
                    "explanation": "Deep check."
                }
            ],
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSameTree(p, q):\n    if not p and not q: return True\n    if not p or not q or p.val != q.val: return False\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)",
            "keyInsight": "Checking 'not p and not q' handles the leaf success case naturally.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                3
            ],
            "animationSteps": [],
            "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
            "examples": [
                {
                    "input": "p = [1,2,3], q = [1,2,3]",
                    "output": "true",
                    "explanation": "Both trees have same structure and values."
                },
                {
                    "input": "p = [1,2], q = [1,null,2]",
                    "output": "false",
                    "explanation": "Different structure."
                }
            ],
            "constraints": [
                "The number of nodes in both trees is in range [0, 100].",
                "-10^4 <= Node.val <= 10^4"
            ],
            "hints": [
                "If both null, return true. If one null, return false.",
                "If values differ, return false.",
                "Recursively check left and right subtrees."
            ],
            "relatedProblems": [
                "symmetric-tree",
                "subtree-of-another-tree"
            ],
            "videoId": "vRbbcKXCkOw"
        },
        "symmetric-tree": {
            "title": "Symmetric Tree",
            "pattern": "DFS (Helpers)",
            "patternEmoji": "\ud83e\ude9e",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Compare root.left and root.right as mirror images (outer vs outer, inner vs inner).",
            "intuition": [
                "\ud83c\udfaf A tree is symmetric if Left Subtree is MIRROR of Right Subtree.",
                "\ud83e\udde0 isMirror(t1, t2): val match? t1.left==t2.right? t1.right==t2.left?",
                "\ud83d\udca1 Key is crossing the comparison."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,2,3,4,4,3]",
                    "output": "true"
                },
                {
                    "input": "root = [1,2,2,null,3,null,3]",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Helper",
                    "visual": "check(L, R)",
                    "explanation": "Start split."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "L.val == R.val?",
                    "explanation": "Values."
                },
                {
                    "step": 3,
                    "title": "Recurse",
                    "visual": "check(L.left, R.right) AND check(L.right, R.left).",
                    "explanation": "Mirror logic."
                }
            ],
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSymmetric(root):\n    if not root: return True\n    def dfs(left, right):\n        if not left and not right: return True\n        if not left or not right: return False\n        return (left.val == right.val and \n                dfs(left.left, right.right) and \n                dfs(left.right, right.left))\n    return dfs(root.left, root.right)",
            "keyInsight": "You need a helper function because the 'root' only has specific logic, while the recursive step compares TWO nodes.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                2,
                3,
                4,
                4,
                3
            ],
            "animationSteps": [],
            "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
            "examples": [
                {
                    "input": "root = [1,2,2,3,4,4,3]",
                    "output": "true",
                    "explanation": "Left and right subtrees are mirrors."
                },
                {
                    "input": "root = [1,2,2,null,3,null,3]",
                    "output": "false",
                    "explanation": "Not symmetric."
                }
            ],
            "constraints": [
                "The number of nodes is in range [1, 1000].",
                "-100 <= Node.val <= 100"
            ],
            "hints": [
                "Compare left subtree with right subtree.",
                "Left's left should equal Right's right.",
                "Left's right should equal Right's left."
            ],
            "relatedProblems": [
                "same-tree",
                "flip-equivalent-binary-trees"
            ],
            "videoId": "Mao9uzxwvmc"
        },
        "binary-tree-level-order-traversal": {
            "title": "Level Order Traversal",
            "pattern": "BFS (Queue)",
            "patternEmoji": "\ud83d\udcc2",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use a deque; process current level sizet times; append children.",
            "intuition": [
                "\ud83c\udfaf Breadth-first.",
                "\ud83e\udde0 Queue valid nodes.",
                "\ud83d\udca1 Snapshot queue length 'L' to know boundary of current level."
            ],
            "testCases": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[[3],[9,20],[15,7]]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "Q = [root]",
                    "explanation": "Start."
                },
                {
                    "step": 2,
                    "title": "Level Loop",
                    "visual": "For _ in range(len(Q)): Pop, Add data, Push children.",
                    "explanation": "Batch process."
                },
                {
                    "step": 3,
                    "title": "Result",
                    "visual": "Append level list to results.",
                    "explanation": "Structure."
                }
            ],
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef levelOrder(root):\n    import collections\n    res = []\n    q = collections.deque()\n    q.append(root)\n    while q:\n        qLen = len(q)\n        level = []\n        for i in range(qLen):\n            node = q.popleft()\n            if node:\n                level.append(node.val)\n                q.append(node.left)\n                q.append(node.right)\n        if level:\n            res.append(level)\n    return res",
            "keyInsight": "Checking `if node:` inside the loop is cleaner than checking children individually before appending.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[[3],[9,20],[15,7]]",
                    "explanation": "Level by level from top to bottom."
                },
                {
                    "input": "root = [1]",
                    "output": "[[1]]",
                    "explanation": "Single node."
                }
            ],
            "constraints": [
                "The number of nodes is in range [0, 2000].",
                "-1000 <= Node.val <= 1000"
            ],
            "hints": [
                "Use BFS with a queue.",
                "Track level size to separate levels.",
                "Add all nodes at current level, then move to next."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal-ii",
                "binary-tree-zigzag-level-order-traversal",
                "average-of-levels-in-binary-tree"
            ],
            "videoId": "6ZnyEApgFYg"
        },
        "clone-graph": {
            "title": "Clone Graph",
            "pattern": "Graph (Hashtable + DFS)",
            "patternEmoji": "\ud83d\udd78",
            "timeComplexity": "O(N + E)",
            "spaceComplexity": "O(N)",
            "oneliner": "Use a hashmap {old_node: new_node} to avoid cycles and duplicates during DFS copy.",
            "intuition": [
                "\ud83c\udfaf Deep copy means creating new instances for every node.",
                "\ud83e\udde0 Graph has cycles; if we visit a node already in map, return the mapped copy.",
                "\ud83d\udca1 Map acts as 'visited' set AND reference storage."
            ],
            "testCases": [
                {
                    "input": "node = [[2,4],[1,3],[2,4],[1,3]]",
                    "output": "[[2,4],[1,3],[2,4],[1,3]]"
                },
                {
                    "input": "node = [[]]",
                    "output": "[[]]"
                },
                {
                    "input": "node = []",
                    "output": "[]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Map",
                    "visual": "Init map = {}. DFS(node).",
                    "explanation": "Start traversal."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "If node in map? Return map[node].",
                    "explanation": "Cycle handled."
                },
                {
                    "step": 3,
                    "title": "Copy",
                    "visual": "copy = Node(node.val). map[node] = copy.",
                    "explanation": "Create node."
                },
                {
                    "step": 4,
                    "title": "Neighbors",
                    "visual": "For nei in neighbors: copy.neighbors.append(dfs(nei)).",
                    "explanation": "Recurse."
                }
            ],
            "code": "class Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    if not node: return None\n    oldToNew = {}\n    \n    def dfs(node):\n        if node in oldToNew:\n            return oldToNew[node]\n        \n        copy = Node(node.val)\n        oldToNew[node] = copy\n        \n        for nei in node.neighbors:\n            copy.neighbors.append(dfs(nei))\n        return copy\n        \n    return dfs(node)",
            "keyInsight": "The hashmap is essential. Without it, you'd get stuck in an infinite loop due to cycles.",
            "visualizationType": "graph",
            "initialState": [
                [
                    2,
                    4
                ],
                [
                    1,
                    3
                ],
                [
                    2,
                    4
                ],
                [
                    1,
                    3
                ]
            ],
            "animationSteps": [],
            "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.",
            "examples": [
                {
                    "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
                    "output": "[[2,4],[1,3],[2,4],[1,3]]",
                    "explanation": "Deep copy of the graph."
                }
            ],
            "constraints": [
                "The number of nodes is in range [0, 100].",
                "1 <= Node.val <= 100",
                "Node.val is unique for each node.",
                "There are no repeated edges and no self-loops."
            ],
            "hints": [
                "Use hash map: old node -> cloned node.",
                "Use BFS or DFS to traverse.",
                "Clone node first, then clone neighbors."
            ],
            "relatedProblems": [
                "copy-list-with-random-pointer",
                "clone-n-ary-tree",
                "clone-binary-tree-with-random-pointer"
            ],
            "videoId": "mQeF6bN8hMk"
        },
        "course-schedule": {
            "title": "Course Schedule",
            "pattern": "Topological Sort (DFS/BFS)",
            "patternEmoji": "\ud83d\udcc3",
            "timeComplexity": "O(N + E)",
            "spaceComplexity": "O(N + E)",
            "oneliner": "Detect cycle in a directed graph. DFS with 'visiting' state or Kahn's Algo (indegrees).",
            "intuition": [
                "\ud83c\udfaf Prereqs are edges. A valid schedule -> No cycles.",
                "\ud83e\udde0 DFS: 0=unvisited, 1=visiting, 2=visited.",
                "\ud83d\udca1 If we meet '1' (visiting), cycle detected."
            ],
            "testCases": [
                {
                    "input": "numCourses = 2; prerequisites = [[1,0]]",
                    "output": "true"
                },
                {
                    "input": "numCourses = 2; prerequisites = [[1,0],[0,1]]",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Build",
                    "visual": "Adj List: {0: [1]}.",
                    "explanation": "Graph rep."
                },
                {
                    "step": 2,
                    "title": "DFS",
                    "visual": "Visit 0. State[0]=Visiting. Visit children.",
                    "explanation": "Traverse."
                },
                {
                    "step": 3,
                    "title": "Cycle?",
                    "visual": "Back edge to Visiting? Cycle! Finish: State[0]=Visited.",
                    "explanation": "Detection."
                }
            ],
            "code": "def canFinish(numCourses, prerequisites):\n    preMap = { i: [] for i in range(numCourses) }\n    for crs, pre in prerequisites:\n        preMap[crs].append(pre)\n        \n    visitSet = set() # Visiting\n    \n    def dfs(crs):\n        if crs in visitSet:\n            return False\n        if preMap[crs] == []: # No prereqs or already verified\n            return True\n            \n        visitSet.add(crs)\n        for pre in preMap[crs]:\n            if not dfs(pre): return False\n        visitSet.remove(crs)\n        preMap[crs] = [] # Optimization: marked as verified\n        return True\n        \n    for crs in range(numCourses):\n        if not dfs(crs): return False\n    return True",
            "keyInsight": "Clearing `preMap[crs] = []` acts as marking it 'Visited' (safe), optimizing so we don't re-check safe nodes.",
            "visualizationType": "graph",
            "initialState": {
                "numCourses": 2,
                "prerequisites": [
                    [
                        1,
                        0
                    ]
                ]
            },
            "animationSteps": [],
            "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. Return true if you can finish all courses. Otherwise, return false.",
            "examples": [
                {
                    "input": "numCourses = 2, prerequisites = [[1,0]]",
                    "output": "true",
                    "explanation": "Take 0 first, then 1."
                },
                {
                    "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
                    "output": "false",
                    "explanation": "Cycle exists, impossible."
                }
            ],
            "constraints": [
                "1 <= numCourses <= 2000",
                "0 <= prerequisites.length <= 5000",
                "prerequisites[i].length == 2",
                "0 <= ai, bi < numCourses"
            ],
            "hints": [
                "This is cycle detection in a directed graph.",
                "Use topological sort (Kahn's algorithm or DFS).",
                "If cycle exists, cannot complete all courses."
            ],
            "relatedProblems": [
                "course-schedule-ii",
                "course-schedule-iv",
                "minimum-height-trees"
            ],
            "videoId": "EgI5nU9etnU"
        },
        "permutations": {
            "title": "Permutations",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(N!)",
            "spaceComplexity": "O(N)",
            "oneliner": "Iterate choices, remove choice (visiting), recurse, add choice back (unvisiting).",
            "intuition": [
                "\ud83c\udfaf Ordering matters.",
                "\ud83e\udde0 Decision tree: 1st slot has N choices, 2nd has N-1...",
                "\ud83d\udca1 Base case: len(path) == len(nums)."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3]",
                    "output": "[[3,2,1],[2,3,1],[1,3,2],[3,1,2],[2,1,3],[1,2,3]]"
                },
                {
                    "input": "nums = [0,1]",
                    "output": "[[1,0],[0,1]]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Choose",
                    "visual": "Pick 1. Remaining: [2,3].",
                    "explanation": "Branch."
                },
                {
                    "step": 2,
                    "title": "Recurse",
                    "visual": "dfs(path + [1]).",
                    "explanation": "Explore."
                },
                {
                    "step": 3,
                    "title": "Backtrack",
                    "visual": "Pop 1. Try 2.",
                    "explanation": "Undo."
                }
            ],
            "code": "def permute(nums):\n    res = []\n    \n    if (len(nums) == 1):\n        return [nums[:]]\n        \n    for i in range(len(nums)):\n        n = nums.pop(0)\n        perms = permute(nums)\n        \n        for p in perms:\n            p.append(n)\n        res.extend(perms)\n        nums.append(n)\n    return res",
            "keyInsight": "The iterative swapping or popping/appending creates the variations without explicit visited sets.",
            "visualizationType": "tree-decision",
            "initialState": [
                1,
                2,
                3
            ],
            "animationSteps": [],
            "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
            "examples": [
                {
                    "input": "nums = [1,2,3]",
                    "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
                    "explanation": "All 6 permutations."
                },
                {
                    "input": "nums = [1]",
                    "output": "[[1]]",
                    "explanation": "Only one permutation."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 6",
                "-10 <= nums[i] <= 10",
                "All integers in nums are unique."
            ],
            "hints": [
                "Use backtracking.",
                "At each position, try all remaining numbers.",
                "Swap elements to avoid using extra space."
            ],
            "relatedProblems": [
                "permutations-ii",
                "next-permutation",
                "combinations"
            ],
            "videoId": "s7AvT7cGdSo"
        },
        "combination-sum": {
            "title": "Combination Sum",
            "pattern": "Backtracking (Decision Tree)",
            "patternEmoji": "\ud83c\udf81",
            "timeComplexity": "O(2^Target)",
            "spaceComplexity": "O(Target)",
            "oneliner": "At each step: Option 1 (Include nums[i], stay at i), Option 2 (Exclude nums[i], move to i+1).",
            "intuition": [
                "\ud83c\udfaf Unlimited use of same number -> stay at index `i`.",
                "\ud83e\udde0 Sum > Target? Stop. Sum == Target? Record.",
                "\ud83d\udca1 Avoid duplicates by only moving forward index."
            ],
            "testCases": [
                {
                    "input": "candidates = [2,3,6,7]; target = 7",
                    "output": "[[2,2,3],[7]]"
                },
                {
                    "input": "candidates = [2]; target = 1",
                    "output": "[]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Include",
                    "visual": "Add 2. New sum. Recurse(i).",
                    "explanation": "Reuse."
                },
                {
                    "step": 2,
                    "title": "Exclude",
                    "visual": "Pop 2. Recurse(i+1).",
                    "explanation": "Skip."
                },
                {
                    "step": 3,
                    "title": "Base",
                    "visual": "Sum > Target? Return.",
                    "explanation": "Prune."
                }
            ],
            "code": "def combinationSum(candidates, target):\n    res = []\n    \n    def dfs(i, cur, total):\n        if total == target:\n            res.append(cur.copy())\n            return\n        if i >= len(candidates) or total > target:\n            return\n            \n        # Decision 1: Include candidate[i] -> stay at i\n        cur.append(candidates[i])\n        dfs(i, cur, total + candidates[i])\n        \n        # Decision 2: Exclude candidate[i] -> move to i+1\n        cur.pop()\n        dfs(i + 1, cur, total)\n        \n    dfs(0, [], 0)\n    return res",
            "keyInsight": "Splitting the decision into 'include current' OR 'never use current again' avoids duplicate combinations perfectly.",
            "visualizationType": "tree-decision",
            "initialState": {
                "candidates": [
                    2,
                    3,
                    6,
                    7
                ],
                "target": 7
            },
            "animationSteps": [],
            "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times.",
            "examples": [
                {
                    "input": "candidates = [2,3,6,7], target = 7",
                    "output": "[[2,2,3],[7]]",
                    "explanation": "2+2+3=7 and 7=7."
                },
                {
                    "input": "candidates = [2,3,5], target = 8",
                    "output": "[[2,2,2,2],[2,3,3],[3,5]]",
                    "explanation": "Three valid combinations."
                }
            ],
            "constraints": [
                "1 <= candidates.length <= 30",
                "2 <= candidates[i] <= 40",
                "All elements in candidates are distinct.",
                "1 <= target <= 40"
            ],
            "hints": [
                "Use backtracking.",
                "Allow reusing same element (start index doesn't advance).",
                "Prune when sum exceeds target."
            ],
            "relatedProblems": [
                "combination-sum-ii",
                "combination-sum-iii",
                "subsets"
            ],
            "videoId": "GBKI9VSKdGg"
        },
        "word-search": {
            "title": "Word Search",
            "pattern": "Backtracking (Matrix)",
            "patternEmoji": "\ud83d\udd0e",
            "timeComplexity": "O(N * M * 4^L)",
            "spaceComplexity": "O(L)",
            "oneliner": "DFS on grid: match char? Mark visited -> Recurse neighbors -> Unmark.",
            "intuition": [
                "\ud83c\udfaf Snake through the grid.",
                "\ud83e\udde0 Cannot reuse cell in same path (need path_visited set).",
                "\ud83d\udca1 Prune immediately if char mismatch."
            ],
            "testCases": [
                {
                    "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]; word = \"ABCCED\"",
                    "output": "true"
                },
                {
                    "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]; word = \"SEE\"",
                    "output": "true"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Find Start",
                    "visual": "Scan for word[0]. Start DFS.",
                    "explanation": "Init."
                },
                {
                    "step": 2,
                    "title": "DFS",
                    "visual": "Match? Path.add. Recurse 4 dirs.",
                    "explanation": "Pathfinding."
                },
                {
                    "step": 3,
                    "title": "Backtrack",
                    "visual": "Return. Path.remove.",
                    "explanation": "Cleanup."
                }
            ],
            "code": "def exist(board, word):\n    ROWS, COLS = len(board), len(board[0])\n    path = set()\n    \n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n        if (r < 0 or c < 0 or \n            r >= ROWS or c >= COLS or \n            word[i] != board[r][c] or \n            (r,c) in path):\n            return False\n            \n        path.add((r, c))\n        res = (dfs(r + 1, c, i + 1) or\n               dfs(r - 1, c, i + 1) or\n               dfs(r, c + 1, i + 1) or\n               dfs(r, c - 1, i + 1))\n        path.remove((r, c))\n        return res\n        \n    for r in range(ROWS):\n        for c in range(COLS):\n            if dfs(r, c, 0): return True\n    return False",
            "keyInsight": "Using a set for the current path is cleaner than modifying the board, though board modification (e.g. replacing with '#') saves space.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    "A",
                    "B",
                    "C",
                    "E"
                ],
                [
                    "S",
                    "F",
                    "C",
                    "S"
                ],
                [
                    "A",
                    "D",
                    "E",
                    "E"
                ]
            ],
            "animationSteps": [],
            "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
            "examples": [
                {
                    "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
                    "output": "true",
                    "explanation": "Path exists."
                },
                {
                    "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
                    "output": "false",
                    "explanation": "Cannot reuse cells."
                }
            ],
            "constraints": [
                "m == board.length",
                "n = board[i].length",
                "1 <= m, n <= 6",
                "1 <= word.length <= 15",
                "board and word only contain uppercase and lowercase English letters."
            ],
            "hints": [
                "Use backtracking with DFS.",
                "Mark visited cells temporarily.",
                "Restore after backtracking."
            ],
            "relatedProblems": [
                "word-search-ii"
            ],
            "videoId": "pfiQ_PS1g8E"
        },
        "kth-largest-element-in-an-array": {
            "title": "Kth Largest Element",
            "pattern": "Heap / QuickSelect",
            "patternEmoji": "\ud83e\udd47",
            "timeComplexity": "O(N) avg",
            "spaceComplexity": "O(1) / O(K)",
            "oneliner": "QuickSelect for O(N) OR Min-Heap of size K (keep K largest seen).",
            "intuition": [
                "\ud83c\udfaf We want the Kth item if sorted descending.",
                "\ud83e\udde0 Sorting is O(NlogN). Can we do better?",
                "\ud83d\udca1 QuickSelect partitions array like QuickSort but only recurses into one half."
            ],
            "testCases": [
                {
                    "input": "nums = [3,2,1,5,6,4]; k = 2",
                    "output": "5"
                },
                {
                    "input": "nums = [3,2,3,1,2,4,5,5,6]; k = 4",
                    "output": "4"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Pivot",
                    "visual": "Pick pivot, partition < pivot, > pivot.",
                    "explanation": "Split."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "Is pivot index == len-k? Return pivot.",
                    "explanation": "Target?"
                },
                {
                    "step": 3,
                    "title": "Recurse",
                    "visual": "If idx < target, go right. Else left.",
                    "explanation": "Search."
                }
            ],
            "code": "def findKthLargest(nums, k):\n    k = len(nums) - k\n    \n    def quickSelect(l, r):\n        pivot, p = nums[r], l\n        for i in range(l, r):\n            if nums[i] <= pivot:\n                nums[p], nums[i] = nums[i], nums[p]\n                p += 1\n        nums[p], nums[r] = nums[r], nums[p]\n        \n        if p > k: return quickSelect(l, p - 1)\n        elif p < k: return quickSelect(p + 1, r)\n        else: return nums[p]\n        \n    return quickSelect(0, len(nums) - 1)",
            "keyInsight": "Running QuickSelect is theoretically O(N) average, superior to Heap's O(N log K) if K is large, although Python's `heapq.nlargest` is very optimized.",
            "visualizationType": "array",
            "initialState": [
                3,
                2,
                1,
                5,
                6,
                4
            ],
            "animationSteps": [],
            "description": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting?",
            "examples": [
                {
                    "input": "nums = [3,2,1,5,6,4], k = 2",
                    "output": "5",
                    "explanation": "Sorted: [1,2,3,4,5,6], 2nd largest is 5."
                },
                {
                    "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
                    "output": "4",
                    "explanation": "4th largest is 4."
                }
            ],
            "constraints": [
                "1 <= k <= nums.length <= 10^5",
                "-10^4 <= nums[i] <= 10^4"
            ],
            "hints": [
                "Use a min-heap of size k.",
                "Or use Quickselect for O(n) average.",
                "Heap gives O(n log k)."
            ],
            "relatedProblems": [
                "top-k-frequent-elements",
                "find-k-pairs-with-smallest-sums",
                "kth-smallest-element-in-a-sorted-matrix"
            ],
            "videoId": "XEmy13g1Qxc"
        },
        "top-k-frequent-elements": {
            "title": "Top K Frequent Elements",
            "pattern": "Bucket Sort / Heap",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(N)",
            "spaceComplexity": "O(N)",
            "oneliner": "Count freqs. Use Bucket Sort (freq is index, list of numbers is val) to get results in O(N).",
            "intuition": [
                "\ud83c\udfaf Map {num -> count}.",
                "\ud83e\udde0 Max freq is N. Create array where index is freq.",
                "\ud83d\udca1 Iterate bucket from N down to 1 to find most frequent."
            ],
            "testCases": [
                {
                    "input": "nums = [1,1,1,2,2,3]; k = 2",
                    "output": "[1,2]"
                },
                {
                    "input": "nums = [1]; k = 1",
                    "output": "[1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Count",
                    "visual": "Hashmap counts.",
                    "explanation": "Freqs."
                },
                {
                    "step": 2,
                    "title": "Bucket",
                    "visual": "bucket[count].append(num).",
                    "explanation": "Group."
                },
                {
                    "step": 3,
                    "title": "Gather",
                    "visual": "Flatten buckets in reverse.",
                    "explanation": "Result."
                }
            ],
            "code": "def topKFrequent(nums, k):\n    count = {}\n    freq = [[] for i in range(len(nums) + 1)]\n    \n    for n in nums:\n        count[n] = 1 + count.get(n, 0)\n    for n, c in count.items():\n        freq[c].append(n)\n        \n    res = []\n    for i in range(len(freq) - 1, 0, -1):\n        for n in freq[i]:\n            res.append(n)\n            if len(res) == k:\n                return res",
            "keyInsight": "Bucket Sort is essentially O(N) here because frequencies are bounded by array size.",
            "visualizationType": "array",
            "initialState": [
                1,
                1,
                1,
                2,
                2,
                3
            ],
            "animationSteps": [],
            "description": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
            "examples": [
                {
                    "input": "nums = [1,1,1,2,2,3], k = 2",
                    "output": "[1,2]",
                    "explanation": "1 appears 3 times, 2 appears 2 times."
                },
                {
                    "input": "nums = [1], k = 1",
                    "output": "[1]",
                    "explanation": "Single element."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^5",
                "-10^4 <= nums[i] <= 10^4",
                "k is in range [1, the number of unique elements].",
                "It is guaranteed that the answer is unique."
            ],
            "hints": [
                "Count frequencies with a hash map.",
                "Use a min-heap of size k.",
                "Or use bucket sort for O(n)."
            ],
            "relatedProblems": [
                "kth-largest-element-in-an-array",
                "sort-characters-by-frequency",
                "top-k-frequent-words"
            ],
            "videoId": "YPTqKIgVk-k"
        },
        "remove-duplicates-from-sorted-array": {
            "title": "Remove Duplicates from Sorted Array",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc46\ud83d\udc46",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use slow/fast pointers. Slow marks 'write position', fast scans ahead.",
            "intuition": [
                "\ud83c\udfaf We need to remove duplicates IN-PLACE and return new length.",
                "\ud83e\udde0 Use 'slow' pointer for write position, 'fast' to scan.",
                "\ud83d\udca1 When nums[fast] != nums[slow], copy nums[fast] to nums[slow+1]."
            ],
            "testCases": [
                {
                    "input": "nums = [1,1,2]",
                    "output": "2"
                },
                {
                    "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
                    "output": "5"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "slow=0, fast=1",
                    "explanation": "Start pointers."
                },
                {
                    "step": 2,
                    "title": "Compare",
                    "visual": "nums[fast] != nums[slow]? Move slow, copy.",
                    "explanation": "Unique found."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Return slow + 1",
                    "explanation": "Length of unique elements."
                }
            ],
            "code": "def removeDuplicates(nums):\n    if not nums: return 0\n    slow = 0\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1",
            "keyInsight": "The slow pointer always points to the last unique element.",
            "visualizationType": "array",
            "initialState": [
                1,
                1,
                2
            ],
            "animationSteps": [],
            "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums.",
            "examples": [
                {
                    "input": "nums = [1,1,2]",
                    "output": "2, nums = [1,2,_]",
                    "explanation": "Return k=2, first 2 elements are unique."
                },
                {
                    "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
                    "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
                    "explanation": "5 unique elements."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 3 * 10^4",
                "-100 <= nums[i] <= 100",
                "nums is sorted in non-decreasing order."
            ],
            "hints": [
                "Use two pointers - slow for unique position, fast for scanning.",
                "If nums[fast] != nums[slow], copy to slow+1.",
                "Return slow + 1 as count."
            ],
            "relatedProblems": [
                "remove-duplicates-from-sorted-array-ii",
                "remove-element",
                "move-zeroes"
            ],
            "videoId": "DEJAZBq0FDA"
        },
        "remove-duplicates-from-sorted-array-ii": {
            "title": "Remove Duplicates from Sorted Array II",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc46\ud83d\udc46",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Allow at most 2 duplicates. Compare with nums[slow-1] instead of nums[slow].",
            "intuition": [
                "\ud83c\udfaf Each unique element can appear at most twice.",
                "\ud83e\udde0 Compare nums[fast] with nums[slow-1] (not slow).",
                "\ud83d\udca1 If different, copy and advance slow."
            ],
            "testCases": [
                {
                    "input": "nums = [1,1,1,2,2,3]",
                    "output": "5"
                },
                {
                    "input": "nums = [0,0,1,1,1,1,2,3,3]",
                    "output": "7"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "slow=2, fast=2",
                    "explanation": "First 2 are always kept."
                },
                {
                    "step": 2,
                    "title": "Compare",
                    "visual": "nums[fast] != nums[slow-2]?",
                    "explanation": "Check 2 back."
                },
                {
                    "step": 3,
                    "title": "Copy",
                    "visual": "nums[slow] = nums[fast]; slow++",
                    "explanation": "Keep element."
                }
            ],
            "code": "def removeDuplicates(nums):\n    if len(nums) <= 2: return len(nums)\n    slow = 2\n    for fast in range(2, len(nums)):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n    return slow",
            "keyInsight": "The key insight is comparing with slow-2, not slow-1.",
            "visualizationType": "array",
            "initialState": [
                1,
                1,
                1,
                2,
                2,
                3
            ],
            "animationSteps": [],
            "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.",
            "examples": [
                {
                    "input": "nums = [1,1,1,2,2,3]",
                    "output": "5, nums = [1,1,2,2,3,_]",
                    "explanation": "Keep at most 2 of each."
                },
                {
                    "input": "nums = [0,0,1,1,1,1,2,3,3]",
                    "output": "7, nums = [0,0,1,1,2,3,3,_,_]",
                    "explanation": "7 elements after removing extras."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 3 * 10^4",
                "-10^4 <= nums[i] <= 10^4",
                "nums is sorted in non-decreasing order."
            ],
            "hints": [
                "Use two pointers with a count variable.",
                "Allow at most 2 of each element.",
                "Compare with element 2 positions back."
            ],
            "relatedProblems": [
                "remove-duplicates-from-sorted-array",
                "remove-duplicates-from-sorted-list-ii"
            ],
            "videoId": "ycAq8iqh0TI"
        },
        "rotate-array": {
            "title": "Rotate Array",
            "pattern": "Reverse Trick",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Reverse entire array, then reverse first k, then reverse rest.",
            "intuition": [
                "\ud83c\udfaf Rotate array right by k steps.",
                "\ud83e\udde0 Reverse trick: reverse all, reverse [0:k], reverse [k:].",
                "\ud83d\udca1 Handles k > len(nums) with k %= len."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,4,5,6,7]; k = 3",
                    "output": "[5,6,7,1,2,3,4]"
                },
                {
                    "input": "nums = [-1,-100,3,99]; k = 2",
                    "output": "[3,99,-1,-100]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Normalize",
                    "visual": "k = k % n",
                    "explanation": "Handle overflow."
                },
                {
                    "step": 2,
                    "title": "Reverse All",
                    "visual": "[7,6,5,4,3,2,1]",
                    "explanation": "Flip entire array."
                },
                {
                    "step": 3,
                    "title": "Reverse Parts",
                    "visual": "[5,6,7] + [1,2,3,4]",
                    "explanation": "Flip both halves."
                }
            ],
            "code": "def rotate(nums, k):\n    n = len(nums)\n    k %= n\n    def reverse(l, r):\n        while l < r:\n            nums[l], nums[r] = nums[r], nums[l]\n            l, r = l + 1, r - 1\n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n    return nums",
            "keyInsight": "Three reverses is more elegant than slicing or cyclic replacement.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "animationSteps": [],
            "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
            "examples": [
                {
                    "input": "nums = [1,2,3,4,5,6,7], k = 3",
                    "output": "[5,6,7,1,2,3,4]",
                    "explanation": "Rotate right 3 times."
                },
                {
                    "input": "nums = [-1,-100,3,99], k = 2",
                    "output": "[3,99,-1,-100]",
                    "explanation": "Rotate right 2 times."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^5",
                "-2^31 <= nums[i] <= 2^31 - 1",
                "0 <= k <= 10^5"
            ],
            "hints": [
                "Use the reverse technique.",
                "Reverse the entire array.",
                "Reverse first k elements, then reverse remaining elements."
            ],
            "relatedProblems": [
                "rotate-list",
                "reverse-words-in-a-string",
                "rotate-image"
            ],
            "videoId": "BHr381Guz3Y"
        },
        "best-time-to-buy-and-sell-stock-ii": {
            "title": "Best Time to Buy and Sell Stock II",
            "pattern": "Greedy",
            "patternEmoji": "\ud83d\udcb0",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Buy before every rise, sell after every rise. Collect all profits.",
            "intuition": [
                "\ud83c\udfaf Unlimited transactions allowed.",
                "\ud83e\udde0 Collect profit for every upward movement.",
                "\ud83d\udca1 If prices[i] > prices[i-1], add the difference."
            ],
            "testCases": [
                {
                    "input": "prices = [7,1,5,3,6,4]",
                    "output": "7"
                },
                {
                    "input": "prices = [1,2,3,4,5]",
                    "output": "4"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Check pairs",
                    "explanation": "Compare consecutive."
                },
                {
                    "step": 2,
                    "title": "Profit",
                    "visual": "If up, add diff",
                    "explanation": "Greedy gain."
                },
                {
                    "step": 3,
                    "title": "Sum",
                    "visual": "Total = 7",
                    "explanation": "All upward moves."
                }
            ],
            "code": "def maxProfit(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            profit += prices[i] - prices[i - 1]\n    return profit",
            "keyInsight": "Every upward slope contributes to profit. Just sum them all.",
            "visualizationType": "array",
            "initialState": [
                7,
                1,
                5,
                3,
                6,
                4
            ],
            "animationSteps": [],
            "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.",
            "examples": [
                {
                    "input": "prices = [7,1,5,3,6,4]",
                    "output": "7",
                    "explanation": "Buy at 1, sell at 5, profit 4. Buy at 3, sell at 6, profit 3. Total 7."
                },
                {
                    "input": "prices = [1,2,3,4,5]",
                    "output": "4",
                    "explanation": "Buy at 1, sell at 5, or sum all increases."
                }
            ],
            "constraints": [
                "1 <= prices.length <= 3 * 10^4",
                "0 <= prices[i] <= 10^4"
            ],
            "hints": [
                "Capture every upward price movement.",
                "Sum of (prices[i] - prices[i-1]) for all increases.",
                "Greedy approach works here."
            ],
            "relatedProblems": [
                "best-time-to-buy-and-sell-stock",
                "best-time-to-buy-and-sell-stock-iii",
                "best-time-to-buy-and-sell-stock-with-cooldown"
            ],
            "videoId": "3SJ3pUkPQMc"
        },
        "jump-game": {
            "title": "Jump Game",
            "pattern": "Greedy",
            "patternEmoji": "\ud83e\udd98",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track the farthest reachable index. If i > maxReach, return False.",
            "intuition": [
                "\ud83c\udfaf Can you reach the last index?",
                "\ud83e\udde0 At each step, update max reachable: max(reach, i + nums[i]).",
                "\ud83d\udca1 If current index exceeds reach, we're stuck."
            ],
            "testCases": [
                {
                    "input": "nums = [2,3,1,1,4]",
                    "output": "true"
                },
                {
                    "input": "nums = [3,2,1,0,4]",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "reach = 0",
                    "explanation": "Start."
                },
                {
                    "step": 2,
                    "title": "Update",
                    "visual": "reach = max(reach, i + nums[i])",
                    "explanation": "Extend."
                },
                {
                    "step": 3,
                    "title": "Check",
                    "visual": "reach >= n-1?",
                    "explanation": "Can reach end."
                }
            ],
            "code": "def canJump(nums):\n    reach = 0\n    for i in range(len(nums)):\n        if i > reach:\n            return False\n        reach = max(reach, i + nums[i])\n    return True",
            "keyInsight": "Greedy approach: always track the maximum reachable position.",
            "visualizationType": "array",
            "initialState": [
                2,
                3,
                1,
                1,
                4
            ],
            "animationSteps": [],
            "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise.",
            "examples": [
                {
                    "input": "nums = [2,3,1,1,4]",
                    "output": "true",
                    "explanation": "Jump 1 step from 0 to 1, then 3 steps to last."
                },
                {
                    "input": "nums = [3,2,1,0,4]",
                    "output": "false",
                    "explanation": "Always stuck at index 3."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^4",
                "0 <= nums[i] <= 10^5"
            ],
            "hints": [
                "Track the farthest reachable index.",
                "If current index > farthest, return false.",
                "If farthest >= last index, return true."
            ],
            "relatedProblems": [
                "jump-game-ii",
                "jump-game-iii",
                "jump-game-iv"
            ],
            "videoId": "Yan0cv2cLy8"
        },
        "jump-game-ii": {
            "title": "Jump Game II",
            "pattern": "Greedy BFS",
            "patternEmoji": "\ud83e\udd98\ud83e\udd98",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "BFS-style: track current level end and farthest reachable.",
            "intuition": [
                "\ud83c\udfaf Minimum jumps to reach end.",
                "\ud83e\udde0 Think of it as BFS levels. Each 'jump' is a level.",
                "\ud83d\udca1 When we pass current level end, increment jumps."
            ],
            "testCases": [
                {
                    "input": "nums = [2,3,1,1,4]",
                    "output": "2"
                },
                {
                    "input": "nums = [2,3,0,1,4]",
                    "output": "2"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "jumps=0, end=0, far=0",
                    "explanation": "Setup."
                },
                {
                    "step": 2,
                    "title": "Expand",
                    "visual": "far = max(far, i+nums[i])",
                    "explanation": "Track farthest."
                },
                {
                    "step": 3,
                    "title": "Level",
                    "visual": "i == end? jumps++, end=far",
                    "explanation": "Next jump."
                }
            ],
            "code": "def jump(nums):\n    jumps = 0\n    end = 0\n    farthest = 0\n    for i in range(len(nums) - 1):\n        farthest = max(farthest, i + nums[i])\n        if i == end:\n            jumps += 1\n            end = farthest\n    return jumps",
            "keyInsight": "Think of it as BFS where each 'level' represents one jump.",
            "visualizationType": "array",
            "initialState": [
                2,
                3,
                1,
                1,
                4
            ],
            "animationSteps": [],
            "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. Return the minimum number of jumps to reach nums[n - 1].",
            "examples": [
                {
                    "input": "nums = [2,3,1,1,4]",
                    "output": "2",
                    "explanation": "Jump 1 to index 1, then 3 to last index."
                },
                {
                    "input": "nums = [2,3,0,1,4]",
                    "output": "2",
                    "explanation": "Same minimum jumps."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^4",
                "0 <= nums[i] <= 1000",
                "It's guaranteed you can reach nums[n - 1]."
            ],
            "hints": [
                "Use BFS-like approach with levels.",
                "Track current jump's end and farthest reachable.",
                "Increment jumps when reaching current end."
            ],
            "relatedProblems": [
                "jump-game",
                "jump-game-iii",
                "minimum-jumps-to-reach-home"
            ],
            "videoId": "dJ7sWiOoK7g"
        },
        "h-index": {
            "title": "H-Index",
            "pattern": "Counting Sort / Binary Search",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Count papers at each citation level. Scan from high to low.",
            "intuition": [
                "\ud83c\udfaf H-index: h papers with at least h citations.",
                "\ud83e\udde0 Use counting sort bucket. papers[i] = count of papers with i citations.",
                "\ud83d\udca1 Accumulate from high to find h where count >= h."
            ],
            "testCases": [
                {
                    "input": "citations = [3,0,6,1,5]",
                    "output": "3"
                },
                {
                    "input": "citations = [1,3,1]",
                    "output": "1"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Bucket",
                    "visual": "Count citations",
                    "explanation": "Counting sort."
                },
                {
                    "step": 2,
                    "title": "Accumulate",
                    "visual": "From n down to 0",
                    "explanation": "Sum papers."
                },
                {
                    "step": 3,
                    "title": "Find h",
                    "visual": "total >= h",
                    "explanation": "First valid."
                }
            ],
            "code": "def hIndex(citations):\n    n = len(citations)\n    papers = [0] * (n + 1)\n    for c in citations:\n        papers[min(n, c)] += 1\n    total = 0\n    for h in range(n, -1, -1):\n        total += papers[h]\n        if total >= h:\n            return h\n    return 0",
            "keyInsight": "Counting sort avoids O(n log n) sort. Cap citations at n.",
            "visualizationType": "array",
            "initialState": [
                3,
                0,
                6,
                1,
                5
            ],
            "animationSteps": [],
            "description": "Count papers at each citation level. Scan from high to low.\n\nH-index: h papers with at least h citations.\nUse counting sort bucket. papers[i] = count of papers with i citations.",
            "examples": [
                {
                    "input": "citations = [3,0,6,1,5]",
                    "output": "3"
                },
                {
                    "input": "citations = [1,3,1]",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "H-index: h papers with at least h citations.",
                "Use counting sort bucket. papers[i] = count of papers with i citations.",
                "Accumulate from high to find h where count >= h."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "CjKJDloMnwM"
        },
        "product-of-array-except-self": {
            "title": "Product of Array Except Self",
            "pattern": "Prefix/Suffix Products",
            "patternEmoji": "\u2716\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Two passes: left products, then right products multiplied in.",
            "intuition": [
                "\ud83c\udfaf res[i] = product of all except nums[i].",
                "\ud83e\udde0 res[i] = (product of left) * (product of right).",
                "\ud83d\udca1 First pass: left products. Second pass: multiply right products."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,4]",
                    "output": "[24,12,8,6]"
                },
                {
                    "input": "nums = [-1,1,0,-3,3]",
                    "output": "[0,0,9,0,0]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Left",
                    "visual": "res = [1, 1, 2, 6]",
                    "explanation": "Prefix products."
                },
                {
                    "step": 2,
                    "title": "Right",
                    "visual": "Multiply suffix",
                    "explanation": "Right to left."
                },
                {
                    "step": 3,
                    "title": "Result",
                    "visual": "[24,12,8,6]",
                    "explanation": "Combined."
                }
            ],
            "code": "def productExceptSelf(nums):\n    n = len(nums)\n    res = [1] * n\n    left = 1\n    for i in range(n):\n        res[i] = left\n        left *= nums[i]\n    right = 1\n    for i in range(n - 1, -1, -1):\n        res[i] *= right\n        right *= nums[i]\n    return res",
            "keyInsight": "Use output array for left products, then multiply right products in-place.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                4
            ],
            "animationSteps": [],
            "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
            "examples": [
                {
                    "input": "nums = [1,2,3,4]",
                    "output": "[24,12,8,6]",
                    "explanation": "answer[0] = 2*3*4 = 24, answer[1] = 1*3*4 = 12, etc."
                },
                {
                    "input": "nums = [-1,1,0,-3,3]",
                    "output": "[0,0,9,0,0]",
                    "explanation": "Products accounting for the zero."
                }
            ],
            "constraints": [
                "2 <= nums.length <= 10^5",
                "-30 <= nums[i] <= 30",
                "Product of any prefix or suffix fits in 32-bit integer."
            ],
            "hints": [
                "Calculate prefix products from left.",
                "Calculate suffix products from right.",
                "answer[i] = prefix[i-1] * suffix[i+1]."
            ],
            "relatedProblems": [
                "trapping-rain-water",
                "maximum-product-subarray",
                "paint-house-ii"
            ],
            "videoId": "bNvIQI2wAjk"
        },
        "gas-station": {
            "title": "Gas Station",
            "pattern": "Greedy",
            "patternEmoji": "\u26fd",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "If total gas >= total cost, solution exists. Start from where deficit resets.",
            "intuition": [
                "\ud83c\udfaf Find the starting gas station to complete the circuit.",
                "\ud83e\udde0 Track total and current tank. Reset start when current < 0.",
                "\ud83d\udca1 If total >= 0, answer is the last reset point."
            ],
            "testCases": [
                {
                    "input": "gas = [1,2,3,4,5]; cost = [3,4,5,1,2]",
                    "output": "3"
                },
                {
                    "input": "gas = [2,3,4]; cost = [3,4,3]",
                    "output": "-1"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Track",
                    "visual": "total, tank, start",
                    "explanation": "Initialize."
                },
                {
                    "step": 2,
                    "title": "Add",
                    "visual": "tank += gas[i] - cost[i]",
                    "explanation": "Net gain."
                },
                {
                    "step": 3,
                    "title": "Reset",
                    "visual": "tank<0? start=i+1, tank=0",
                    "explanation": "New start."
                }
            ],
            "code": "def canCompleteCircuit(gas, cost):\n    total = 0\n    tank = 0\n    start = 0\n    for i in range(len(gas)):\n        diff = gas[i] - cost[i]\n        total += diff\n        tank += diff\n        if tank < 0:\n            start = i + 1\n            tank = 0\n    return start if total >= 0 else -1",
            "keyInsight": "If you can't reach station i+1 from some start, try starting from i+1.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [],
            "description": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.",
            "examples": [
                {
                    "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
                    "output": "3",
                    "explanation": "Start at station 3, you can complete the circuit."
                },
                {
                    "input": "gas = [2,3,4], cost = [3,4,3]",
                    "output": "-1",
                    "explanation": "Not possible to complete."
                }
            ],
            "constraints": [
                "n == gas.length == cost.length",
                "1 <= n <= 10^5",
                "0 <= gas[i], cost[i] <= 10^4"
            ],
            "hints": [
                "If total gas < total cost, impossible.",
                "If we run out at station j, start can't be 0 to j.",
                "Greedy: reset start when tank goes negative."
            ],
            "relatedProblems": [
                "minimum-cost-to-make-at-least-one-valid-path-in-a-grid"
            ],
            "videoId": "lJwbPZGo05A"
        },
        "candy": {
            "title": "Candy",
            "pattern": "Two Pass Greedy",
            "patternEmoji": "\ud83c\udf6c",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Left pass: satisfy left neighbor rule. Right pass: satisfy right rule.",
            "intuition": [
                "\ud83c\udfaf Each child gets at least 1 candy. Higher rating = more than neighbors.",
                "\ud83e\udde0 Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
                "\ud83d\udca1 Right-to-left: same logic, take max."
            ],
            "testCases": [
                {
                    "input": "ratings = [1,0,2]",
                    "output": "5"
                },
                {
                    "input": "ratings = [1,2,2]",
                    "output": "4"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "candy = [1,1,1...]",
                    "explanation": "Everyone gets 1."
                },
                {
                    "step": 2,
                    "title": "Left",
                    "visual": "Increasing? +1",
                    "explanation": "Left rule."
                },
                {
                    "step": 3,
                    "title": "Right",
                    "visual": "Decreasing? max",
                    "explanation": "Right rule."
                }
            ],
            "code": "def candy(ratings):\n    n = len(ratings)\n    candies = [1] * n\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n    return sum(candies)",
            "keyInsight": "Two passes handle left and right neighbors independently, then combine.",
            "visualizationType": "array",
            "initialState": [
                1,
                0,
                2
            ],
            "animationSteps": [],
            "description": "Left pass: satisfy left neighbor rule. Right pass: satisfy right rule.\n\nEach child gets at least 1 candy. Higher rating = more than neighbors.\nLeft-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
            "examples": [
                {
                    "input": "ratings = [1,0,2]",
                    "output": "5"
                },
                {
                    "input": "ratings = [1,2,2]",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Each child gets at least 1 candy. Higher rating = more than neighbors.",
                "Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
                "Right-to-left: same logic, take max."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "QzPWc0yI-C0"
        },
        "trapping-rain-water": {
            "title": "Trapping Rain Water",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udca7",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Two pointers from ends. Water at i = min(leftMax, rightMax) - height[i].",
            "intuition": [
                "\ud83c\udfaf How much water can be trapped?",
                "\ud83e\udde0 Water at each position = min(maxLeft, maxRight) - height.",
                "\ud83d\udca1 Two pointers: move the smaller side inward."
            ],
            "testCases": [
                {
                    "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
                    "output": "6"
                },
                {
                    "input": "height = [4,2,0,3,2,5]",
                    "output": "9"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "l=0, r=n-1, maxL=maxR=0",
                    "explanation": "Pointers."
                },
                {
                    "step": 2,
                    "title": "Compare",
                    "visual": "Move smaller side",
                    "explanation": "Bottleneck."
                },
                {
                    "step": 3,
                    "title": "Add",
                    "visual": "water += max - height[i]",
                    "explanation": "Accumulate."
                }
            ],
            "code": "def trap(height):\n    if not height: return 0\n    l, r = 0, len(height) - 1\n    leftMax, rightMax = height[l], height[r]\n    water = 0\n    while l < r:\n        if leftMax < rightMax:\n            l += 1\n            leftMax = max(leftMax, height[l])\n            water += leftMax - height[l]\n        else:\n            r -= 1\n            rightMax = max(rightMax, height[r])\n            water += rightMax - height[r]\n    return water",
            "keyInsight": "The smaller of leftMax/rightMax determines water level at current position.",
            "visualizationType": "array",
            "initialState": [
                0,
                1,
                0,
                2,
                1,
                0,
                1,
                3,
                2,
                1,
                2,
                1
            ],
            "animationSteps": [],
            "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
            "examples": [
                {
                    "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
                    "output": "6",
                    "explanation": "Water fills between bars."
                },
                {
                    "input": "height = [4,2,0,3,2,5]",
                    "output": "9",
                    "explanation": "Water fills between 4,5 and intermediate bars."
                }
            ],
            "constraints": [
                "n == height.length",
                "1 <= n <= 2 * 10^4",
                "0 <= height[i] <= 10^5"
            ],
            "hints": [
                "Water at position i = min(maxLeft, maxRight) - height[i].",
                "Use two pointers from both ends.",
                "Or precompute maxLeft and maxRight arrays."
            ],
            "relatedProblems": [
                "container-with-most-water",
                "product-of-array-except-self",
                "trapping-rain-water-ii"
            ],
            "videoId": "ZI2z5pq0TqA"
        },
        "roman-to-integer": {
            "title": "Roman to Integer",
            "pattern": "Hash Map",
            "patternEmoji": "\ud83c\udfdb\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "If current < next, subtract; else add.",
            "intuition": [
                "\ud83c\udfaf Convert Roman numeral to integer.",
                "\ud83e\udde0 Map each symbol to value.",
                "\ud83d\udca1 If s[i] < s[i+1], subtract s[i]; else add."
            ],
            "testCases": [
                {
                    "input": "s = \"III\"",
                    "output": "3"
                },
                {
                    "input": "s = \"MCMXCIV\"",
                    "output": "1994"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Map",
                    "visual": "I=1, V=5, X=10...",
                    "explanation": "Values."
                },
                {
                    "step": 2,
                    "title": "Scan",
                    "visual": "Compare curr and next",
                    "explanation": "Direction."
                },
                {
                    "step": 3,
                    "title": "Add/Sub",
                    "visual": "Accumulate result",
                    "explanation": "Total."
                }
            ],
            "code": "def romanToInt(s):\n    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    for i in range(len(s)):\n        if i + 1 < len(s) and roman[s[i]] < roman[s[i + 1]]:\n            total -= roman[s[i]]\n        else:\n            total += roman[s[i]]\n    return total",
            "keyInsight": "Subtraction happens when a smaller value precedes a larger one.",
            "visualizationType": "string",
            "initialState": "MCMXCIV",
            "animationSteps": [],
            "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Given a roman numeral, convert it to an integer.",
            "examples": [
                {
                    "input": "s = \"III\"",
                    "output": "3",
                    "explanation": "III = 1 + 1 + 1 = 3."
                },
                {
                    "input": "s = \"LVIII\"",
                    "output": "58",
                    "explanation": "L = 50, V= 5, III = 3."
                },
                {
                    "input": "s = \"MCMXCIV\"",
                    "output": "1994",
                    "explanation": "M = 1000, CM = 900, XC = 90, IV = 4."
                }
            ],
            "constraints": [
                "1 <= s.length <= 15",
                "s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
                "It is guaranteed that s is a valid roman numeral."
            ],
            "hints": [
                "Create a mapping of symbols to values.",
                "If current < next, subtract current.",
                "Otherwise add current."
            ],
            "relatedProblems": [
                "integer-to-roman"
            ],
            "videoId": "3jdxYj3DD98"
        },
        "integer-to-roman": {
            "title": "Integer to Roman",
            "pattern": "Greedy",
            "patternEmoji": "\ud83c\udfdb\ufe0f",
            "timeComplexity": "O(1)",
            "spaceComplexity": "O(1)",
            "oneliner": "Greedily subtract largest possible value and append symbol.",
            "intuition": [
                "\ud83c\udfaf Convert integer to Roman numeral.",
                "\ud83e\udde0 Use a list of (value, symbol) pairs in descending order.",
                "\ud83d\udca1 Repeatedly subtract and append until num is 0."
            ],
            "testCases": [
                {
                    "input": "num = 3749",
                    "output": "\"MMMDCCXLIX\""
                },
                {
                    "input": "num = 58",
                    "output": "\"LVIII\""
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "List",
                    "visual": "(1000,M), (900,CM)...",
                    "explanation": "All values."
                },
                {
                    "step": 2,
                    "title": "Greed",
                    "visual": "While num >= val: append",
                    "explanation": "Subtract."
                },
                {
                    "step": 3,
                    "title": "Build",
                    "visual": "Concatenate symbols",
                    "explanation": "Result."
                }
            ],
            "code": "def intToRoman(num):\n    val_sym = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n               (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n               (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    res = []\n    for val, sym in val_sym:\n        while num >= val:\n            res.append(sym)\n            num -= val\n    return ''.join(res)",
            "keyInsight": "Include subtraction pairs (CM, CD, XC, etc.) in the lookup table.",
            "visualizationType": "string",
            "initialState": "3749",
            "animationSteps": [],
            "description": "Greedily subtract largest possible value and append symbol.\n\nConvert integer to Roman numeral.\nUse a list of (value, symbol) pairs in descending order.",
            "examples": [
                {
                    "input": "num = 3749",
                    "output": "\"MMMDCCXLIX\""
                },
                {
                    "input": "num = 58",
                    "output": "\"LVIII\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Convert integer to Roman numeral.",
                "Use a list of (value, symbol) pairs in descending order.",
                "Repeatedly subtract and append until num is 0."
            ],
            "relatedProblems": [
                "jump-game",
                "gas-station",
                "best-time-to-buy-and-sell-stock-ii"
            ],
            "videoId": "ohBNdSJyLh8"
        },
        "length-of-last-word": {
            "title": "Length of Last Word",
            "pattern": "String Traversal",
            "patternEmoji": "\ud83d\udccf",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Strip trailing spaces, find last space, return len - last_space - 1.",
            "intuition": [
                "\ud83c\udfaf Find length of last word.",
                "\ud83e\udde0 Iterate from end, skip trailing spaces, count letters.",
                "\ud83d\udca1 Or just use split()[-1]."
            ],
            "testCases": [
                {
                    "input": "s = \"Hello World\"",
                    "output": "5"
                },
                {
                    "input": "s = \"   fly me   to   the moon  \"",
                    "output": "4"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Trim",
                    "visual": "Skip trailing spaces",
                    "explanation": "Find word."
                },
                {
                    "step": 2,
                    "title": "Count",
                    "visual": "Count until space",
                    "explanation": "Length."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Length = 5",
                    "explanation": "Done."
                }
            ],
            "code": "def lengthOfLastWord(s):\n    return len(s.strip().split()[-1])",
            "keyInsight": "Python's split() handles multiple spaces elegantly.",
            "visualizationType": "string",
            "initialState": "Hello World",
            "animationSteps": [],
            "description": "Strip trailing spaces, find last space, return len - last_space - 1.\n\nFind length of last word.\nIterate from end, skip trailing spaces, count letters.",
            "examples": [
                {
                    "input": "s = \"Hello World\"",
                    "output": "5"
                },
                {
                    "input": "s = \"   fly me   to   the moon  \"",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find length of last word.",
                "Iterate from end, skip trailing spaces, count letters.",
                "Or just use split()[-1]."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "KT9rltZTybQ"
        },
        "longest-common-prefix": {
            "title": "Longest Common Prefix",
            "pattern": "Horizontal Scan",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(S)",
            "spaceComplexity": "O(1)",
            "oneliner": "Compare characters at same position across all strings.",
            "intuition": [
                "\ud83c\udfaf Find the longest common prefix among all strings.",
                "\ud83e\udde0 Iterate character by character.",
                "\ud83d\udca1 Stop when any string differs or ends."
            ],
            "testCases": [
                {
                    "input": "strs = [\"flower\",\"flow\",\"flight\"]",
                    "output": "\"fl\""
                },
                {
                    "input": "strs = [\"dog\",\"racecar\",\"car\"]",
                    "output": "\"\""
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Zip",
                    "visual": "Compare columns",
                    "explanation": "Char by char."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "All same?",
                    "explanation": "Continue."
                },
                {
                    "step": 3,
                    "title": "Stop",
                    "visual": "Mismatch found",
                    "explanation": "Return prefix."
                }
            ],
            "code": "def longestCommonPrefix(strs):\n    if not strs: return ''\n    for i in range(len(strs[0])):\n        char = strs[0][i]\n        for s in strs[1:]:\n            if i >= len(s) or s[i] != char:\n                return strs[0][:i]\n    return strs[0]",
            "keyInsight": "Vertical scanning is more efficient than horizontal pairwise comparison.",
            "visualizationType": "array",
            "initialState": [
                "flower",
                "flow",
                "flight"
            ],
            "animationSteps": [],
            "description": "Compare characters at same position across all strings.\n\nFind the longest common prefix among all strings.\nIterate character by character.",
            "examples": [
                {
                    "input": "strs = [\"flower\",\"flow\",\"flight\"]",
                    "output": "\"fl\""
                },
                {
                    "input": "strs = [\"dog\",\"racecar\",\"car\"]",
                    "output": "\"\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find the longest common prefix among all strings.",
                "Iterate character by character.",
                "Stop when any string differs or ends."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "0sWShKIJoo4"
        },
        "reverse-words-in-a-string": {
            "title": "Reverse Words in a String",
            "pattern": "Two Pointers / Split",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Split by spaces, reverse, join with single space.",
            "intuition": [
                "\ud83c\udfaf Reverse the order of words in a string.",
                "\ud83e\udde0 Split removes extra spaces, reverse list, join.",
                "\ud83d\udca1 Handle leading/trailing/multiple spaces."
            ],
            "testCases": [
                {
                    "input": "s = \"the sky is blue\"",
                    "output": "\"blue is sky the\""
                },
                {
                    "input": "s = \"  hello world  \"",
                    "output": "\"world hello\""
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Split",
                    "visual": "['the', 'sky', 'is', 'blue']",
                    "explanation": "Tokenize."
                },
                {
                    "step": 2,
                    "title": "Reverse",
                    "visual": "['blue', 'is', 'sky', 'the']",
                    "explanation": "Flip order."
                },
                {
                    "step": 3,
                    "title": "Join",
                    "visual": "'blue is sky the'",
                    "explanation": "Combine."
                }
            ],
            "code": "def reverseWords(s):\n    return ' '.join(s.split()[::-1])",
            "keyInsight": "Python's split() without args handles multiple spaces elegantly.",
            "visualizationType": "string",
            "initialState": "the sky is blue",
            "animationSteps": [],
            "description": "Split by spaces, reverse, join with single space.\n\nReverse the order of words in a string.\nSplit removes extra spaces, reverse list, join.",
            "examples": [
                {
                    "input": "s = \"the sky is blue\"",
                    "output": "\"blue is sky the\""
                },
                {
                    "input": "s = \"  hello world  \"",
                    "output": "\"world hello\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Reverse the order of words in a string.",
                "Split removes extra spaces, reverse list, join.",
                "Handle leading/trailing/multiple spaces."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "vhnRAaJybpA"
        },
        "zigzag-conversion": {
            "title": "Zigzag Conversion",
            "pattern": "Simulation",
            "patternEmoji": "\u26a1",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use row index and direction flag. Toggle direction at bounds.",
            "intuition": [
                "\ud83c\udfaf Write string in zigzag pattern, read row by row.",
                "\ud83e\udde0 Track current row, direction (up/down).",
                "\ud83d\udca1 Flip direction at row 0 and row numRows-1."
            ],
            "testCases": [
                {
                    "input": "s = \"PAYPALISHIRING\"; numRows = 3",
                    "output": "\"PAHNAPLSIIGYIR\""
                },
                {
                    "input": "s = \"PAYPALISHIRING\"; numRows = 4",
                    "output": "\"PINALSIGYAHRPI\""
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "rows = [''] * numRows",
                    "explanation": "Setup."
                },
                {
                    "step": 2,
                    "title": "Traverse",
                    "visual": "Add char to row[i]",
                    "explanation": "Fill."
                },
                {
                    "step": 3,
                    "title": "Direction",
                    "visual": "Bounce at edges",
                    "explanation": "Zigzag."
                }
            ],
            "code": "def convert(s, numRows):\n    if numRows == 1 or numRows >= len(s): return s\n    rows = [''] * numRows\n    idx, step = 0, 1\n    for c in s:\n        rows[idx] += c\n        if idx == 0: step = 1\n        elif idx == numRows - 1: step = -1\n        idx += step\n    return ''.join(rows)",
            "keyInsight": "The pattern is: go down until bottom, then go up until top, repeat.",
            "visualizationType": "string",
            "initialState": "PAYPALISHIRING",
            "animationSteps": [],
            "description": "Use row index and direction flag. Toggle direction at bounds.\n\nWrite string in zigzag pattern, read row by row.\nTrack current row, direction (up/down).",
            "examples": [
                {
                    "input": "s = \"PAYPALISHIRING\"; numRows = 3",
                    "output": "\"PAHNAPLSIIGYIR\""
                },
                {
                    "input": "s = \"PAYPALISHIRING\"; numRows = 4",
                    "output": "\"PINALSIGYAHRPI\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Write string in zigzag pattern, read row by row.",
                "Track current row, direction (up/down).",
                "Flip direction at row 0 and row numRows-1."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Q2Tw6gcVEwc"
        },
        "find-the-index-of-the-first-occurrence-in-a-string": {
            "title": "Find the Index of the First Occurrence in a String",
            "pattern": "KMP / Simple Search",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(n*m)",
            "spaceComplexity": "O(1)",
            "oneliner": "Slide needle over haystack, check for match.",
            "intuition": [
                "\ud83c\udfaf Find first occurrence of needle in haystack.",
                "\ud83e\udde0 Simple: check each starting position.",
                "\ud83d\udca1 Or use Python's built-in find()."
            ],
            "testCases": [
                {
                    "input": "haystack = \"sadbutsad\"; needle = \"sad\"",
                    "output": "0"
                },
                {
                    "input": "haystack = \"leetcode\"; needle = \"leeto\"",
                    "output": "-1"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Slide",
                    "visual": "Check each position",
                    "explanation": "Linear scan."
                },
                {
                    "step": 2,
                    "title": "Match",
                    "visual": "Compare substring",
                    "explanation": "Check."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Index or -1",
                    "explanation": "Result."
                }
            ],
            "code": "def strStr(haystack, needle):\n    return haystack.find(needle)",
            "keyInsight": "Python's find() is optimized. For interviews, show manual sliding window.",
            "visualizationType": "string",
            "initialState": "sadbutsad",
            "animationSteps": [],
            "description": "Slide needle over haystack, check for match.\n\nFind first occurrence of needle in haystack.\nSimple: check each starting position.",
            "examples": [
                {
                    "input": "haystack = \"sadbutsad\"; needle = \"sad\"",
                    "output": "0"
                },
                {
                    "input": "haystack = \"leetcode\"; needle = \"leeto\"",
                    "output": "-1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find first occurrence of needle in haystack.",
                "Simple: check each starting position.",
                "Or use Python's built-in find()."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "JoF0Z7nVSrA"
        },
        "text-justification": {
            "title": "Text Justification",
            "pattern": "Greedy + Simulation",
            "patternEmoji": "\ud83d\udcdd",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Greedily pack words, distribute spaces evenly. Left-justify last line.",
            "intuition": [
                "\ud83c\udfaf Fully justify text to maxWidth.",
                "\ud83e\udde0 Pack as many words as fit, distribute extra spaces.",
                "\ud83d\udca1 Last line: left-justified."
            ],
            "testCases": [
                {
                    "input": "words = [\"This\", \"is\", \"an\", \"example\"]; maxWidth = 16",
                    "output": "[\"This    is    an\", \"example         \"]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Pack",
                    "visual": "Greedy word fit",
                    "explanation": "Fill line."
                },
                {
                    "step": 2,
                    "title": "Space",
                    "visual": "Distribute evenly",
                    "explanation": "Justify."
                },
                {
                    "step": 3,
                    "title": "Last",
                    "visual": "Left align",
                    "explanation": "Special case."
                }
            ],
            "code": "def fullJustify(words, maxWidth):\n    res, line, width = [], [], 0\n    for w in words:\n        if width + len(w) + len(line) > maxWidth:\n            for i in range(maxWidth - width):\n                line[i % (len(line) - 1 or 1)] += ' '\n            res.append(''.join(line))\n            line, width = [], 0\n        line.append(w)\n        width += len(w)\n    return res + [' '.join(line).ljust(maxWidth)]",
            "keyInsight": "Distribute extra spaces using modulo for even distribution.",
            "visualizationType": "array",
            "initialState": [
                "This",
                "is",
                "an",
                "example"
            ],
            "animationSteps": [],
            "description": "Greedily pack words, distribute spaces evenly. Left-justify last line.\n\nFully justify text to maxWidth.\nPack as many words as fit, distribute extra spaces.",
            "examples": [
                {
                    "input": "words = [\"This\", \"is\", \"an\", \"example\"]; maxWidth = 16",
                    "output": "[\"This    is    an\", \"example         \"]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Fully justify text to maxWidth.",
                "Pack as many words as fit, distribute extra spaces.",
                "Last line: left-justified."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "TzMl5gId3s0"
        },
        "find-all-numbers-disappeared-in-an-array": {
            "title": "Find All Numbers Disappeared in an Array",
            "pattern": "Index Marking",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Mark visited indices negative. Return indices still positive.",
            "intuition": [
                "\ud83c\udfaf Find numbers 1..n missing from array.",
                "\ud83e\udde0 Use indices as markers: negate nums[nums[i]-1].",
                "\ud83d\udca1 Positive indices indicate missing numbers."
            ],
            "testCases": [
                {
                    "input": "nums = [4,3,2,7,8,2,3,1]",
                    "output": "[5,6]"
                },
                {
                    "input": "nums = [1,1]",
                    "output": "[2]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Mark",
                    "visual": "Negate at index",
                    "explanation": "Seen."
                },
                {
                    "step": 2,
                    "title": "Scan",
                    "visual": "Find positives",
                    "explanation": "Missing."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "[5, 6]",
                    "explanation": "Result."
                }
            ],
            "code": "def findDisappearedNumbers(nums):\n    for n in nums:\n        idx = abs(n) - 1\n        nums[idx] = -abs(nums[idx])\n    return [i + 1 for i, n in enumerate(nums) if n > 0]",
            "keyInsight": "Using array indices as a hash set avoids extra space.",
            "visualizationType": "array",
            "initialState": [
                4,
                3,
                2,
                7,
                8,
                2,
                3,
                1
            ],
            "animationSteps": [],
            "description": "Mark visited indices negative. Return indices still positive.\n\nFind numbers 1..n missing from array.\nUse indices as markers: negate nums[nums[i]-1].",
            "examples": [
                {
                    "input": "nums = [4,3,2,7,8,2,3,1]",
                    "output": "[5,6]"
                },
                {
                    "input": "nums = [1,1]",
                    "output": "[2]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find numbers 1..n missing from array.",
                "Use indices as markers: negate nums[nums[i]-1].",
                "Positive indices indicate missing numbers."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "8i-f24YFWC4"
        },
        "is-subsequence": {
            "title": "Is Subsequence",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc46\ud83d\udc46",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use pointer for s, advance when char matches in t.",
            "intuition": [
                "\ud83c\udfaf Is s a subsequence of t?",
                "\ud83e\udde0 Two pointers: advance s pointer on match.",
                "\ud83d\udca1 If s pointer reaches end, it's a subsequence."
            ],
            "testCases": [
                {
                    "input": "s = \"abc\"; t = \"ahbgdc\"",
                    "output": "true"
                },
                {
                    "input": "s = \"axc\"; t = \"ahbgdc\"",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "i=0, j=0",
                    "explanation": "Pointers."
                },
                {
                    "step": 2,
                    "title": "Match",
                    "visual": "s[i]==t[j]? i++",
                    "explanation": "Advance."
                },
                {
                    "step": 3,
                    "title": "Check",
                    "visual": "i == len(s)?",
                    "explanation": "Result."
                }
            ],
            "code": "def isSubsequence(s, t):\n    i = 0\n    for c in t:\n        if i < len(s) and c == s[i]:\n            i += 1\n    return i == len(s)",
            "keyInsight": "Characters must appear in order but not necessarily contiguous.",
            "visualizationType": "string",
            "initialState": "abc",
            "animationSteps": [],
            "description": "Use pointer for s, advance when char matches in t.\n\nIs s a subsequence of t?\nTwo pointers: advance s pointer on match.",
            "examples": [
                {
                    "input": "s = \"abc\"; t = \"ahbgdc\"",
                    "output": "true"
                },
                {
                    "input": "s = \"axc\"; t = \"ahbgdc\"",
                    "output": "false"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Is s a subsequence of t?",
                "Two pointers: advance s pointer on match.",
                "If s pointer reaches end, it's a subsequence."
            ],
            "relatedProblems": [
                "two-sum",
                "container-with-most-water",
                "3sum"
            ],
            "videoId": "99RVfqklbCE"
        },
        "two-sum-ii---input-array-is-sorted": {
            "title": "Two Sum II - Input Array Is Sorted",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc46\ud83d\udc46",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Left and right pointers. Move left up if sum too small, right down if too big.",
            "intuition": [
                "\ud83c\udfaf Find two numbers that add up to target (1-indexed).",
                "\ud83e\udde0 Since sorted, use two pointers from ends.",
                "\ud83d\udca1 Adjust pointers based on sum vs target."
            ],
            "testCases": [
                {
                    "input": "numbers = [2,7,11,15]; target = 9",
                    "output": "[1,2]"
                },
                {
                    "input": "numbers = [2,3,4]; target = 6",
                    "output": "[1,3]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "l=0, r=n-1",
                    "explanation": "Endpoints."
                },
                {
                    "step": 2,
                    "title": "Sum",
                    "visual": "Compare to target",
                    "explanation": "Check."
                },
                {
                    "step": 3,
                    "title": "Adjust",
                    "visual": "Move pointers",
                    "explanation": "Narrow."
                }
            ],
            "code": "def twoSum(numbers, target):\n    l, r = 0, len(numbers) - 1\n    while l < r:\n        s = numbers[l] + numbers[r]\n        if s == target:\n            return [l + 1, r + 1]\n        elif s < target:\n            l += 1\n        else:\n            r -= 1\n    return []",
            "keyInsight": "Sorted array + two sum = classic two pointer pattern.",
            "visualizationType": "array",
            "initialState": [
                2,
                7,
                11,
                15
            ],
            "animationSteps": [],
            "description": "Left and right pointers. Move left up if sum too small, right down if too big.\n\nFind two numbers that add up to target (1-indexed).\nSince sorted, use two pointers from ends.",
            "examples": [
                {
                    "input": "numbers = [2,7,11,15]; target = 9",
                    "output": "[1,2]"
                },
                {
                    "input": "numbers = [2,3,4]; target = 6",
                    "output": "[1,3]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find two numbers that add up to target (1-indexed).",
                "Since sorted, use two pointers from ends.",
                "Adjust pointers based on sum vs target."
            ],
            "relatedProblems": [
                "two-sum",
                "container-with-most-water",
                "3sum"
            ],
            "videoId": "cQ1Oz4ckceM"
        },
        "container-with-most-water": {
            "title": "Container With Most Water",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udca7",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Two pointers from ends. Move the shorter one inward.",
            "intuition": [
                "\ud83c\udfaf Maximize water container area.",
                "\ud83e\udde0 Area = min(height[l], height[r]) * (r - l).",
                "\ud83d\udca1 Moving shorter line could find taller one."
            ],
            "testCases": [
                {
                    "input": "height = [1,8,6,2,5,4,8,3,7]",
                    "output": "49"
                },
                {
                    "input": "height = [1,1]",
                    "output": "1"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "l=0, r=n-1",
                    "explanation": "Max width."
                },
                {
                    "step": 2,
                    "title": "Area",
                    "visual": "min * width",
                    "explanation": "Calculate."
                },
                {
                    "step": 3,
                    "title": "Move",
                    "visual": "Shorter side",
                    "explanation": "Optimize."
                }
            ],
            "code": "def maxArea(height):\n    l, r = 0, len(height) - 1\n    maxA = 0\n    while l < r:\n        area = min(height[l], height[r]) * (r - l)\n        maxA = max(maxA, area)\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    return maxA",
            "keyInsight": "Moving the taller line can never increase area (width decreases, height capped).",
            "visualizationType": "array",
            "initialState": [
                1,
                8,
                6,
                2,
                5,
                4,
                8,
                3,
                7
            ],
            "animationSteps": [],
            "description": "Two pointers from ends. Move the shorter one inward.\n\nMaximize water container area.\nArea = min(height[l], height[r]) * (r - l).",
            "examples": [
                {
                    "input": "height = [1,8,6,2,5,4,8,3,7]",
                    "output": "49"
                },
                {
                    "input": "height = [1,1]",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Maximize water container area.",
                "Area = min(height[l], height[r]) * (r - l).",
                "Moving shorter line could find taller one."
            ],
            "relatedProblems": [
                "two-sum",
                "3sum"
            ],
            "videoId": "UuiTKBwPgAo"
        },
        "3sum": {
            "title": "3Sum",
            "pattern": "Two Pointers + Sort",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(1)",
            "oneliner": "Sort, fix one element, two-pointer for remaining two.",
            "intuition": [
                "\ud83c\udfaf Find all triplets summing to 0.",
                "\ud83e\udde0 Sort array. For each i, use two pointers on [i+1, n-1].",
                "\ud83d\udca1 Skip duplicates to avoid duplicate triplets."
            ],
            "testCases": [
                {
                    "input": "nums = [-1,0,1,2,-1,-4]",
                    "output": "[[-1,-1,2],[-1,0,1]]"
                },
                {
                    "input": "nums = [0,1,1]",
                    "output": "[]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Sort",
                    "visual": "[-4,-1,-1,0,1,2]",
                    "explanation": "Order matters."
                },
                {
                    "step": 2,
                    "title": "Fix",
                    "visual": "i = 0",
                    "explanation": "First element."
                },
                {
                    "step": 3,
                    "title": "Two Ptr",
                    "visual": "l, r narrow",
                    "explanation": "Find complement."
                }
            ],
            "code": "def threeSum(nums):\n    nums.sort()\n    res = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]: continue\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s == 0:\n                res.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l + 1]: l += 1\n                while l < r and nums[r] == nums[r - 1]: r -= 1\n                l, r = l + 1, r - 1\n            elif s < 0:\n                l += 1\n            else:\n                r -= 1\n    return res",
            "keyInsight": "Sorting enables two-pointer approach and duplicate skipping.",
            "visualizationType": "array",
            "initialState": [
                -1,
                0,
                1,
                2,
                -1,
                -4
            ],
            "animationSteps": [],
            "description": "Sort, fix one element, two-pointer for remaining two.\n\nFind all triplets summing to 0.\nSort array. For each i, use two pointers on [i+1, n-1].",
            "examples": [
                {
                    "input": "nums = [-1,0,1,2,-1,-4]",
                    "output": "[[-1,-1,2],[-1,0,1]]"
                },
                {
                    "input": "nums = [0,1,1]",
                    "output": "[]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find all triplets summing to 0.",
                "Sort array. For each i, use two pointers on [i+1, n-1].",
                "Skip duplicates to avoid duplicate triplets."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "jzZsG8n2R9A"
        },
        "squares-of-a-sorted-array": {
            "title": "Squares of a Sorted Array",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udcd0",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Compare absolute values at ends, place larger square at end of result.",
            "intuition": [
                "\ud83c\udfaf Square each element, return sorted array.",
                "\ud83e\udde0 Largest squares at ends (negative or positive).",
                "\ud83d\udca1 Two pointers from ends, fill result from back."
            ],
            "testCases": [
                {
                    "input": "nums = [-4,-1,0,3,10]",
                    "output": "[0,1,9,16,100]"
                },
                {
                    "input": "nums = [-7,-3,2,3,11]",
                    "output": "[4,9,9,49,121]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "l=0, r=n-1, pos=n-1",
                    "explanation": "Pointers."
                },
                {
                    "step": 2,
                    "title": "Compare",
                    "visual": "|nums[l]| vs |nums[r]|",
                    "explanation": "Larger abs."
                },
                {
                    "step": 3,
                    "title": "Fill",
                    "visual": "res[pos] = square",
                    "explanation": "From back."
                }
            ],
            "code": "def sortedSquares(nums):\n    n = len(nums)\n    res = [0] * n\n    l, r = 0, n - 1\n    pos = n - 1\n    while l <= r:\n        if abs(nums[l]) > abs(nums[r]):\n            res[pos] = nums[l] ** 2\n            l += 1\n        else:\n            res[pos] = nums[r] ** 2\n            r -= 1\n        pos -= 1\n    return res",
            "keyInsight": "The largest absolute value is always at one of the ends.",
            "visualizationType": "array",
            "initialState": [
                -4,
                -1,
                0,
                3,
                10
            ],
            "animationSteps": [],
            "description": "Compare absolute values at ends, place larger square at end of result.\n\nSquare each element, return sorted array.\nLargest squares at ends (negative or positive).",
            "examples": [
                {
                    "input": "nums = [-4,-1,0,3,10]",
                    "output": "[0,1,9,16,100]"
                },
                {
                    "input": "nums = [-7,-3,2,3,11]",
                    "output": "[4,9,9,49,121]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Square each element, return sorted array.",
                "Largest squares at ends (negative or positive).",
                "Two pointers from ends, fill result from back."
            ],
            "relatedProblems": [
                "two-sum",
                "container-with-most-water",
                "3sum"
            ],
            "videoId": "FPCZsG_AkUg"
        },
        "longest-mountain-in-array": {
            "title": "Longest Mountain in Array",
            "pattern": "Two Pointers / Expand",
            "patternEmoji": "\ud83c\udfd4\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Find peak, expand left (strictly decreasing), expand right (strictly decreasing).",
            "intuition": [
                "\ud83c\udfaf Find longest mountain subarray (up then down).",
                "\ud83e\udde0 At each peak, extend left and right.",
                "\ud83d\udca1 Mountain needs at least 3 elements."
            ],
            "testCases": [
                {
                    "input": "arr = [2,1,4,7,3,2,5]",
                    "output": "5"
                },
                {
                    "input": "arr = [2,2,2]",
                    "output": "0"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Find Peak",
                    "visual": "arr[i-1] < arr[i] > arr[i+1]",
                    "explanation": "Locate."
                },
                {
                    "step": 2,
                    "title": "Expand",
                    "visual": "Left and right",
                    "explanation": "Extend."
                },
                {
                    "step": 3,
                    "title": "Length",
                    "visual": "right - left + 1",
                    "explanation": "Calculate."
                }
            ],
            "code": "def longestMountain(arr):\n    n = len(arr)\n    res = 0\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] > arr[i + 1]:\n            l = i - 1\n            while l > 0 and arr[l - 1] < arr[l]: l -= 1\n            r = i + 1\n            while r < n - 1 and arr[r] > arr[r + 1]: r += 1\n            res = max(res, r - l + 1)\n            i = r\n        else:\n            i += 1\n    return res",
            "keyInsight": "After finding a mountain, skip to the end of the downhill.",
            "visualizationType": "array",
            "initialState": [
                2,
                1,
                4,
                7,
                3,
                2,
                5
            ],
            "animationSteps": [],
            "description": "Find peak, expand left (strictly decreasing), expand right (strictly decreasing).\n\nFind longest mountain subarray (up then down).\nAt each peak, extend left and right.",
            "examples": [
                {
                    "input": "arr = [2,1,4,7,3,2,5]",
                    "output": "5"
                },
                {
                    "input": "arr = [2,2,2]",
                    "output": "0"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find longest mountain subarray (up then down).",
                "At each peak, extend left and right.",
                "Mountain needs at least 3 elements."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "VtM-0OYcRtE"
        },
        "delete-node-in-a-bst": {
            "title": "Delete Node in a BST",
            "pattern": "BST Traversal",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(h)",
            "spaceComplexity": "O(h)",
            "oneliner": "Find node, replace with successor (leftmost in right subtree).",
            "intuition": [
                "\ud83c\udfaf Delete node with given key from BST.",
                "\ud83e\udde0 Three cases: leaf, one child, two children.",
                "\ud83d\udca1 Two children: replace with inorder successor."
            ],
            "testCases": [
                {
                    "input": "root = [5,3,6,2,4,null,7]; key = 3",
                    "output": "[5,4,6,2,null,null,7]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Find",
                    "visual": "BST search",
                    "explanation": "Locate node."
                },
                {
                    "step": 2,
                    "title": "Delete",
                    "visual": "Handle cases",
                    "explanation": "Remove."
                },
                {
                    "step": 3,
                    "title": "Replace",
                    "visual": "Successor",
                    "explanation": "Maintain BST."
                }
            ],
            "code": "def deleteNode(root, key):\n    if not root: return None\n    if key < root.val:\n        root.left = deleteNode(root.left, key)\n    elif key > root.val:\n        root.right = deleteNode(root.right, key)\n    else:\n        if not root.left: return root.right\n        if not root.right: return root.left\n        # Find successor\n        succ = root.right\n        while succ.left: succ = succ.left\n        root.val = succ.val\n        root.right = deleteNode(root.right, succ.val)\n    return root",
            "keyInsight": "The successor is the leftmost node in the right subtree.",
            "visualizationType": "tree",
            "initialState": [
                5,
                3,
                6,
                2,
                4,
                null,
                7
            ],
            "animationSteps": [],
            "description": "Find node, replace with successor (leftmost in right subtree).\n\nDelete node with given key from BST.\nThree cases: leaf, one child, two children.",
            "examples": [
                {
                    "input": "root = [5,3,6,2,4,null,7]; key = 3",
                    "output": "[5,4,6,2,null,null,7]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Delete node with given key from BST.",
                "Three cases: leaf, one child, two children.",
                "Two children: replace with inorder successor."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "LFzAoJJt92M"
        },
        "insert-into-a-binary-search-tree": {
            "title": "Insert into a Binary Search Tree",
            "pattern": "BST Traversal",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(h)",
            "spaceComplexity": "O(h)",
            "oneliner": "Navigate BST, insert at null position.",
            "intuition": [
                "\ud83c\udfaf Insert value into BST maintaining property.",
                "\ud83e\udde0 Go left if val < root, right otherwise.",
                "\ud83d\udca1 Insert at the first null spot found."
            ],
            "testCases": [
                {
                    "input": "root = [4,2,7,1,3]; val = 5",
                    "output": "[4,2,7,1,3,5]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Navigate",
                    "visual": "Compare values",
                    "explanation": "BST property."
                },
                {
                    "step": 2,
                    "title": "Insert",
                    "visual": "At null",
                    "explanation": "Add node."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Root",
                    "explanation": "Done."
                }
            ],
            "code": "def insertIntoBST(root, val):\n    if not root: return TreeNode(val)\n    if val < root.val:\n        root.left = insertIntoBST(root.left, val)\n    else:\n        root.right = insertIntoBST(root.right, val)\n    return root",
            "keyInsight": "Always insert as a leaf node at the correct position.",
            "visualizationType": "tree",
            "initialState": [
                4,
                2,
                7,
                1,
                3
            ],
            "animationSteps": [],
            "description": "Navigate BST, insert at null position.\n\nInsert value into BST maintaining property.\nGo left if val < root, right otherwise.",
            "examples": [
                {
                    "input": "root = [4,2,7,1,3]; val = 5",
                    "output": "[4,2,7,1,3,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Insert value into BST maintaining property.",
                "Go left if val < root, right otherwise.",
                "Insert at the first null spot found."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Cpg_BFTU5UQ"
        },
        "palindrome-linked-list": {
            "title": "Palindrome Linked List",
            "pattern": "Fast/Slow + Reverse",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Find middle, reverse second half, compare.",
            "intuition": [
                "\ud83c\udfaf Check if linked list is a palindrome.",
                "\ud83e\udde0 Fast/slow to find middle, reverse second half.",
                "\ud83d\udca1 Compare first and second halves."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,2,1]",
                    "output": "true"
                },
                {
                    "input": "head = [1,2]",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Middle",
                    "visual": "Slow at center",
                    "explanation": "Fast/slow."
                },
                {
                    "step": 2,
                    "title": "Reverse",
                    "visual": "Flip second half",
                    "explanation": "In-place."
                },
                {
                    "step": 3,
                    "title": "Compare",
                    "visual": "Match values",
                    "explanation": "Check."
                }
            ],
            "code": "def isPalindrome(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow, fast = slow.next, fast.next.next\n    # Reverse second half\n    prev = None\n    while slow:\n        slow.next, prev, slow = prev, slow, slow.next\n    # Compare\n    while prev:\n        if head.val != prev.val:\n            return False\n        head, prev = head.next, prev.next\n    return True",
            "keyInsight": "O(1) space by reversing half in-place rather than using a stack.",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                2,
                2,
                1
            ],
            "animationSteps": [],
            "description": "Find middle, reverse second half, compare.\n\nCheck if linked list is a palindrome.\nFast/slow to find middle, reverse second half.",
            "examples": [
                {
                    "input": "head = [1,2,2,1]",
                    "output": "true"
                },
                {
                    "input": "head = [1,2]",
                    "output": "false"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Check if linked list is a palindrome.",
                "Fast/slow to find middle, reverse second half.",
                "Compare first and second halves."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "yOzXms1J6Nk"
        },
        "gfg---reverse-first-k-elements-of-a-queue": {
            "title": "Reverse First K Elements of Queue",
            "pattern": "Stack + Queue",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(k)",
            "oneliner": "Use stack to reverse first k, then cycle remaining elements.",
            "intuition": [
                "\ud83c\udfaf Reverse first k elements of a queue.",
                "\ud83e\udde0 Pop k to stack, push back, cycle n-k elements.",
                "\ud83d\udca1 Stack reverses order naturally."
            ],
            "testCases": [
                {
                    "input": "queue = [1,2,3,4,5]; k = 3",
                    "output": "[3,2,1,4,5]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Stack",
                    "visual": "Push k elements",
                    "explanation": "Reverse."
                },
                {
                    "step": 2,
                    "title": "Push",
                    "visual": "Pop stack to queue",
                    "explanation": "Reversed."
                },
                {
                    "step": 3,
                    "title": "Cycle",
                    "visual": "Move n-k to back",
                    "explanation": "Reorder."
                }
            ],
            "code": "from collections import deque\n\ndef reverseFirstK(queue, k):\n    queue = deque(queue)\n    if not queue or k <= 0 or k > len(queue):\n        return list(queue)\n    stack = []\n    for _ in range(k):\n        stack.append(queue.popleft())\n    while stack:\n        queue.append(stack.pop())\n    for _ in range(len(queue) - k):\n        queue.append(queue.popleft())\n    return list(queue)",
            "keyInsight": "Use a stack to reverse order, then cycle the remaining elements.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [],
            "description": "Use stack to reverse first k, then cycle remaining elements.\n\nReverse first k elements of a queue.\nPop k to stack, push back, cycle n-k elements.",
            "examples": [
                {
                    "input": "queue = [1,2,3,4,5]; k = 3",
                    "output": "[3,2,1,4,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Reverse first k elements of a queue.",
                "Pop k to stack, push back, cycle n-k elements.",
                "Stack reverses order naturally."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "8vuPi0rPWOk"
        },
        "minimum-size-subarray-sum": {
            "title": "Minimum Size Subarray Sum",
            "pattern": "Sliding Window",
            "patternEmoji": "\ud83e\ude9f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Expand right until sum >= target, shrink left while valid.",
            "intuition": [
                "\ud83c\udfaf Find minimal length subarray with sum >= target.",
                "\ud83e\udde0 Sliding window: expand right, shrink left when valid.",
                "\ud83d\udca1 Track minimum length when sum >= target."
            ],
            "testCases": [
                {
                    "input": "target = 7; nums = [2,3,1,2,4,3]",
                    "output": "2"
                },
                {
                    "input": "target = 4; nums = [1,4,4]",
                    "output": "1"
                }
            ],
            "code": "def minSubArrayLen(target, nums):\n    left = 0\n    total = 0\n    minLen = float('inf')\n    for right in range(len(nums)):\n        total += nums[right]\n        while total >= target:\n            minLen = min(minLen, right - left + 1)\n            total -= nums[left]\n            left += 1\n    return minLen if minLen != float('inf') else 0",
            "keyInsight": "Shrink window while maintaining validity to find minimum.",
            "visualizationType": "array",
            "initialState": [
                2,
                3,
                1,
                2,
                4,
                3
            ],
            "animationSteps": [],
            "description": "Expand right until sum >= target, shrink left while valid.\n\nFind minimal length subarray with sum >= target.\nSliding window: expand right, shrink left when valid.",
            "examples": [
                {
                    "input": "target = 7; nums = [2,3,1,2,4,3]",
                    "output": "2"
                },
                {
                    "input": "target = 4; nums = [1,4,4]",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find minimal length subarray with sum >= target.",
                "Sliding window: expand right, shrink left when valid.",
                "Track minimum length when sum >= target."
            ],
            "relatedProblems": [
                "longest-substring-without-repeating-characters",
                "minimum-window-substring"
            ],
            "videoId": "aYqYMIqZx5s"
        },
        "longest-substring-without-repeating-characters": {
            "title": "Longest Substring Without Repeating Characters",
            "pattern": "Sliding Window + Hash Set",
            "patternEmoji": "\ud83e\ude9f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(min(n,m))",
            "oneliner": "Expand right, shrink left when duplicate found.",
            "intuition": [
                "\ud83c\udfaf Find longest substring with all unique characters.",
                "\ud83e\udde0 Use set to track current window characters.",
                "\ud83d\udca1 Remove from left when duplicate encountered."
            ],
            "testCases": [
                {
                    "input": "s = \"abcabcbb\"",
                    "output": "3"
                },
                {
                    "input": "s = \"bbbbb\"",
                    "output": "1"
                }
            ],
            "code": "def lengthOfLongestSubstring(s):\n    seen = set()\n    left = 0\n    maxLen = 0\n    for right in range(len(s)):\n        while s[right] in seen:\n            seen.remove(s[left])\n            left += 1\n        seen.add(s[right])\n        maxLen = max(maxLen, right - left + 1)\n    return maxLen",
            "keyInsight": "Use a hash set/map to detect duplicates in O(1).",
            "visualizationType": "string",
            "initialState": "abcabcbb",
            "animationSteps": [],
            "description": "Given a string s, find the length of the longest substring without repeating characters.",
            "examples": [
                {
                    "input": "s = \"abcabcbb\"",
                    "output": "3",
                    "explanation": "The answer is 'abc', with length 3."
                },
                {
                    "input": "s = \"bbbbb\"",
                    "output": "1",
                    "explanation": "The answer is 'b', with length 1."
                },
                {
                    "input": "s = \"pwwkew\"",
                    "output": "3",
                    "explanation": "The answer is 'wke', with length 3."
                }
            ],
            "constraints": [
                "0 <= s.length <= 5 * 10^4",
                "s consists of English letters, digits, symbols and spaces."
            ],
            "hints": [
                "Use the sliding window technique.",
                "Maintain a set of characters in current window.",
                "When you see a duplicate, shrink window from left."
            ],
            "relatedProblems": [
                "longest-repeating-character-replacement",
                "minimum-window-substring",
                "substring-with-concatenation-of-all-words"
            ],
            "videoId": "wiGpQwVHdE0"
        },
        "substring-with-concatenation-of-all-words": {
            "title": "Substring with Concatenation of All Words",
            "pattern": "Sliding Window + Hash Map",
            "patternEmoji": "\ud83e\ude9f",
            "timeComplexity": "O(n*m)",
            "spaceComplexity": "O(m)",
            "oneliner": "Sliding window of size wordLen*numWords, check if all words match.",
            "intuition": [
                "\ud83c\udfaf Find all starting indices of concatenated substrings.",
                "\ud83e\udde0 All words have same length, total window = len*count.",
                "\ud83d\udca1 Slide window, compare word frequency maps."
            ],
            "testCases": [
                {
                    "input": "s = \"barfoothefoobarman\"; words = [\"foo\",\"bar\"]",
                    "output": "[0,9]"
                }
            ],
            "code": "from collections import Counter\n\ndef findSubstring(s, words):\n    if not s or not words: return []\n    wordLen = len(words[0])\n    numWords = len(words)\n    totalLen = wordLen * numWords\n    wordCount = Counter(words)\n    res = []\n    for i in range(len(s) - totalLen + 1):\n        seen = Counter()\n        for j in range(numWords):\n            word = s[i + j * wordLen : i + (j + 1) * wordLen]\n            if word not in wordCount:\n                break\n            seen[word] += 1\n            if seen[word] > wordCount[word]:\n                break\n        else:\n            res.append(i)\n    return res",
            "keyInsight": "Fixed word length simplifies the sliding window logic.",
            "visualizationType": "string",
            "initialState": "barfoothefoobarman",
            "animationSteps": [],
            "description": "Sliding window of size wordLen*numWords, check if all words match.\n\nFind all starting indices of concatenated substrings.\nAll words have same length, total window = len*count.",
            "examples": [
                {
                    "input": "s = \"barfoothefoobarman\"; words = [\"foo\",\"bar\"]",
                    "output": "[0,9]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find all starting indices of concatenated substrings.",
                "All words have same length, total window = len*count.",
                "Slide window, compare word frequency maps."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "cYbN9p1uPQY"
        },
        "minimum-window-substring": {
            "title": "Minimum Window Substring",
            "pattern": "Sliding Window + Hash Map",
            "patternEmoji": "\ud83e\ude9f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(m)",
            "oneliner": "Expand right to include all t chars, shrink left to minimize.",
            "intuition": [
                "\ud83c\udfaf Find minimum window in s containing all chars of t.",
                "\ud83e\udde0 Count required chars, expand right until all satisfied.",
                "\ud83d\udca1 Shrink left while still valid, track minimum."
            ],
            "testCases": [
                {
                    "input": "s = \"ADOBECODEBANC\"; t = \"ABC\"",
                    "output": "\"BANC\""
                }
            ],
            "code": "from collections import Counter\n\ndef minWindow(s, t):\n    if not t or not s: return ''\n    need = Counter(t)\n    have = {}\n    required = len(need)\n    formed = 0\n    left = 0\n    res = (float('inf'), 0, 0)\n    for right, c in enumerate(s):\n        have[c] = have.get(c, 0) + 1\n        if c in need and have[c] == need[c]:\n            formed += 1\n        while formed == required:\n            if right - left + 1 < res[0]:\n                res = (right - left + 1, left, right + 1)\n            have[s[left]] -= 1\n            if s[left] in need and have[s[left]] < need[s[left]]:\n                formed -= 1\n            left += 1\n    return '' if res[0] == float('inf') else s[res[1]:res[2]]",
            "keyInsight": "Track 'formed' count to know when all required chars are satisfied.",
            "visualizationType": "string",
            "initialState": "ADOBECODEBANC",
            "animationSteps": [],
            "description": "Expand right to include all t chars, shrink left to minimize.\n\nFind minimum window in s containing all chars of t.\nCount required chars, expand right until all satisfied.",
            "examples": [
                {
                    "input": "s = \"ADOBECODEBANC\"; t = \"ABC\"",
                    "output": "\"BANC\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find minimum window in s containing all chars of t.",
                "Count required chars, expand right until all satisfied.",
                "Shrink left while still valid, track minimum."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "jSto0O4AJbM"
        },
        "valid-sudoku": {
            "title": "Valid Sudoku",
            "pattern": "Hash Set per Row/Col/Box",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(81)",
            "spaceComplexity": "O(81)",
            "oneliner": "Check each row, column, and 3x3 box for duplicates.",
            "intuition": [
                "\ud83c\udfaf Validate a partially filled Sudoku board.",
                "\ud83e\udde0 Use sets for each row, column, and 3x3 box.",
                "\ud83d\udca1 Box index = (row//3, col//3)."
            ],
            "testCases": [
                {
                    "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                    "output": "true"
                }
            ],
            "code": "def isValidSudoku(board):\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    for r in range(9):\n        for c in range(9):\n            val = board[r][c]\n            if val == '.': continue\n            box_idx = (r // 3) * 3 + (c // 3)\n            if val in rows[r] or val in cols[c] or val in boxes[box_idx]:\n                return False\n            rows[r].add(val)\n            cols[c].add(val)\n            boxes[box_idx].add(val)\n    return True",
            "keyInsight": "The box index formula (r//3)*3 + (c//3) maps to 0-8.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    "5",
                    "3",
                    ".",
                    ".",
                    "7",
                    ".",
                    ".",
                    ".",
                    "."
                ]
            ],
            "animationSteps": [],
            "description": "Check each row, column, and 3x3 box for duplicates.\n\nValidate a partially filled Sudoku board.\nUse sets for each row, column, and 3x3 box.",
            "examples": [
                {
                    "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Validate a partially filled Sudoku board.",
                "Use sets for each row, column, and 3x3 box.",
                "Box index = (row//3, col//3)."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "TjFXEUCMqI8"
        },
        "spiral-matrix": {
            "title": "Spiral Matrix",
            "pattern": "Layer by Layer",
            "patternEmoji": "\ud83c\udf00",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Process layer by layer: right, down, left, up, shrink bounds.",
            "intuition": [
                "\ud83c\udfaf Return matrix elements in spiral order.",
                "\ud83e\udde0 Maintain top/bottom/left/right boundaries.",
                "\ud83d\udca1 Traverse each direction, shrink boundary, repeat."
            ],
            "testCases": [
                {
                    "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                    "output": "[1,2,3,6,9,8,7,4,5]"
                }
            ],
            "code": "def spiralOrder(matrix):\n    if not matrix: return []\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    while top <= bottom and left <= right:\n        for c in range(left, right + 1): res.append(matrix[top][c])\n        top += 1\n        for r in range(top, bottom + 1): res.append(matrix[r][right])\n        right -= 1\n        if top <= bottom:\n            for c in range(right, left - 1, -1): res.append(matrix[bottom][c])\n            bottom -= 1\n        if left <= right:\n            for r in range(bottom, top - 1, -1): res.append(matrix[r][left])\n            left += 1\n    return res",
            "keyInsight": "After going right and down, check bounds before going left and up.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    2,
                    3
                ],
                [
                    4,
                    5,
                    6
                ],
                [
                    7,
                    8,
                    9
                ]
            ],
            "animationSteps": [],
            "description": "Process layer by layer: right, down, left, up, shrink bounds.\n\nReturn matrix elements in spiral order.\nMaintain top/bottom/left/right boundaries.",
            "examples": [
                {
                    "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                    "output": "[1,2,3,6,9,8,7,4,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Return matrix elements in spiral order.",
                "Maintain top/bottom/left/right boundaries.",
                "Traverse each direction, shrink boundary, repeat."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "BJnMZNwUk1M"
        },
        "rotate-image": {
            "title": "Rotate Image",
            "pattern": "Transpose + Reverse",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(1)",
            "oneliner": "Transpose matrix, then reverse each row.",
            "intuition": [
                "\ud83c\udfaf Rotate matrix 90\u00b0 clockwise in-place.",
                "\ud83e\udde0 Transpose: swap matrix[i][j] with matrix[j][i].",
                "\ud83d\udca1 Reverse each row."
            ],
            "testCases": [
                {
                    "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                    "output": "[[7,4,1],[8,5,2],[9,6,3]]"
                }
            ],
            "code": "def rotate(matrix):\n    n = len(matrix)\n    # Transpose\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    # Reverse rows\n    for row in matrix:\n        row.reverse()\n    return matrix",
            "keyInsight": "Transpose + reverse = 90\u00b0 clockwise rotation.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    2,
                    3
                ],
                [
                    4,
                    5,
                    6
                ],
                [
                    7,
                    8,
                    9
                ]
            ],
            "animationSteps": [],
            "description": "Transpose matrix, then reverse each row.\n\nRotate matrix 90\u00b0 clockwise in-place.\nTranspose: swap matrix[i][j] with matrix[j][i].",
            "examples": [
                {
                    "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                    "output": "[[7,4,1],[8,5,2],[9,6,3]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Rotate matrix 90\u00b0 clockwise in-place.",
                "Transpose: swap matrix[i][j] with matrix[j][i].",
                "Reverse each row."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "fMSJSS7eO1w"
        },
        "set-matrix-zeroes": {
            "title": "Set Matrix Zeroes",
            "pattern": "First Row/Col as Markers",
            "patternEmoji": "0\ufe0f\u20e3",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use first row/col as markers. Track if they need zeroing separately.",
            "intuition": [
                "\ud83c\udfaf If cell is 0, set entire row and column to 0.",
                "\ud83e\udde0 Use first row/col to mark which rows/cols to zero.",
                "\ud83d\udca1 Handle first row/col separately."
            ],
            "testCases": [
                {
                    "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
                    "output": "[[1,0,1],[0,0,0],[1,0,1]]"
                }
            ],
            "code": "def setZeroes(matrix):\n    m, n = len(matrix), len(matrix[0])\n    firstRow = firstCol = False\n    for r in range(m):\n        for c in range(n):\n            if matrix[r][c] == 0:\n                if r == 0: firstRow = True\n                if c == 0: firstCol = True\n                matrix[r][0] = matrix[0][c] = 0\n    for r in range(1, m):\n        for c in range(1, n):\n            if matrix[r][0] == 0 or matrix[0][c] == 0:\n                matrix[r][c] = 0\n    if firstRow:\n        for c in range(n): matrix[0][c] = 0\n    if firstCol:\n        for r in range(m): matrix[r][0] = 0\n    return matrix",
            "keyInsight": "First row/col store markers; use separate flags for their own zeroing.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1
                ]
            ],
            "animationSteps": [],
            "description": "Use first row/col as markers. Track if they need zeroing separately.\n\nIf cell is 0, set entire row and column to 0.\nUse first row/col to mark which rows/cols to zero.",
            "examples": [
                {
                    "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
                    "output": "[[1,0,1],[0,0,0],[1,0,1]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "If cell is 0, set entire row and column to 0.",
                "Use first row/col to mark which rows/cols to zero.",
                "Handle first row/col separately."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "T41rL0L3Pnw"
        },
        "game-of-life": {
            "title": "Game of Life",
            "pattern": "State Encoding",
            "patternEmoji": "\ud83c\udfae",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Encode transitions: 2 = live->dead, 3 = dead->live. Then decode.",
            "intuition": [
                "\ud83c\udfaf Apply Conway's Game of Life rules.",
                "\ud83e\udde0 Use extra states to encode old->new: 2=was live, 3=was dead now live.",
                "\ud83d\udca1 Second pass: decode to 0/1."
            ],
            "testCases": [
                {
                    "input": "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
                    "output": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
                }
            ],
            "code": "def gameOfLife(board):\n    m, n = len(board), len(board[0])\n    def countLive(r, c):\n        live = 0\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0: continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] in [1, 2]:\n                    live += 1\n        return live\n    for r in range(m):\n        for c in range(n):\n            live = countLive(r, c)\n            if board[r][c] == 1:\n                if live < 2 or live > 3: board[r][c] = 2  # dies\n            else:\n                if live == 3: board[r][c] = 3  # becomes live\n    for r in range(m):\n        for c in range(n):\n            board[r][c] = 1 if board[r][c] == 1 or board[r][c] == 3 else 0\n    return board",
            "keyInsight": "Encode transitions to update in-place without auxiliary space.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    0,
                    1,
                    0
                ],
                [
                    0,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0
                ]
            ],
            "animationSteps": [],
            "description": "Encode transitions: 2 = live->dead, 3 = dead->live. Then decode.\n\nApply Conway's Game of Life rules.\nUse extra states to encode old->new: 2=was live, 3=was dead now live.",
            "examples": [
                {
                    "input": "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
                    "output": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Apply Conway's Game of Life rules.",
                "Use extra states to encode old->new: 2=was live, 3=was dead now live.",
                "Second pass: decode to 0/1."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "fei4bJQdBUQ"
        },
        "summary-ranges": {
            "title": "Summary Ranges",
            "pattern": "Linear Scan",
            "patternEmoji": "\ud83d\udccb",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track start, extend while consecutive, format range.",
            "intuition": [
                "\ud83c\udfaf Return smallest sorted list of ranges covering all numbers.",
                "\ud83e\udde0 Start a range, extend while nums[i]+1 == nums[i+1].",
                "\ud83d\udca1 Format as 'a->b' or just 'a' if single."
            ],
            "testCases": [
                {
                    "input": "nums = [0,1,2,4,5,7]",
                    "output": "[\"0->2\",\"4->5\",\"7\"]"
                }
            ],
            "code": "def summaryRanges(nums):\n    if not nums: return []\n    res = []\n    start = nums[0]\n    for i in range(1, len(nums) + 1):\n        if i == len(nums) or nums[i] != nums[i - 1] + 1:\n            if start == nums[i - 1]:\n                res.append(str(start))\n            else:\n                res.append(f'{start}->{nums[i - 1]}')\n            if i < len(nums):\n                start = nums[i]\n    return res",
            "keyInsight": "Use index i-1 for end of range when gap detected.",
            "visualizationType": "array",
            "initialState": [
                0,
                1,
                2,
                4,
                5,
                7
            ],
            "animationSteps": [],
            "description": "Track start, extend while consecutive, format range.\n\nReturn smallest sorted list of ranges covering all numbers.\nStart a range, extend while nums[i]+1 == nums[i+1].",
            "examples": [
                {
                    "input": "nums = [0,1,2,4,5,7]",
                    "output": "[\"0->2\",\"4->5\",\"7\"]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Return smallest sorted list of ranges covering all numbers.",
                "Start a range, extend while nums[i]+1 == nums[i+1].",
                "Format as 'a->b' or just 'a' if single."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "ZoLasC3JuNg"
        },
        "merge-intervals": {
            "title": "Merge Intervals",
            "pattern": "Sort + Merge",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Sort by start, merge overlaps into result.",
            "intuition": [
                "\ud83c\udfaf Merge all overlapping intervals.",
                "\ud83e\udde0 Sort by start. If current overlaps last, extend end.",
                "\ud83d\udca1 Otherwise, add as new interval."
            ],
            "testCases": [
                {
                    "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
                    "output": "[[1,6],[8,10],[15,18]]"
                }
            ],
            "code": "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    res = []\n    for interval in intervals:\n        if res and res[-1][1] >= interval[0]:\n            res[-1][1] = max(res[-1][1], interval[1])\n        else:\n            res.append(interval)\n    return res",
            "keyInsight": "After sorting, overlapping intervals are adjacent.",
            "visualizationType": "array",
            "initialState": [
                [
                    1,
                    3
                ],
                [
                    2,
                    6
                ],
                [
                    8,
                    10
                ],
                [
                    15,
                    18
                ]
            ],
            "animationSteps": [],
            "description": "Sort by start, merge overlaps into result.\n\nMerge all overlapping intervals.\nSort by start. If current overlaps last, extend end.",
            "examples": [
                {
                    "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
                    "output": "[[1,6],[8,10],[15,18]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Merge all overlapping intervals.",
                "Sort by start. If current overlaps last, extend end.",
                "Otherwise, add as new interval."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "44H3cEC2fFM"
        },
        "insert-interval": {
            "title": "Insert Interval",
            "pattern": "Merge on Insert",
            "patternEmoji": "\u2795",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Add all before, merge overlaps, add all after.",
            "intuition": [
                "\ud83c\udfaf Insert and merge new interval into sorted list.",
                "\ud83e\udde0 Three phases: before, during overlap, after.",
                "\ud83d\udca1 Merge during overlap by extending bounds."
            ],
            "testCases": [
                {
                    "input": "intervals = [[1,3],[6,9]]; newInterval = [2,5]",
                    "output": "[[1,5],[6,9]]"
                }
            ],
            "code": "def insert(intervals, newInterval):\n    res = []\n    for i, intv in enumerate(intervals):\n        if newInterval[1] < intv[0]:\n            res.append(newInterval)\n            return res + intervals[i:]\n        elif newInterval[0] > intv[1]:\n            res.append(intv)\n        else:\n            newInterval = [min(newInterval[0], intv[0]), max(newInterval[1], intv[1])]\n    res.append(newInterval)\n    return res",
            "keyInsight": "Keep merging into newInterval until no more overlap.",
            "visualizationType": "array",
            "initialState": [
                [
                    1,
                    3
                ],
                [
                    6,
                    9
                ]
            ],
            "animationSteps": [],
            "description": "Add all before, merge overlaps, add all after.\n\nInsert and merge new interval into sorted list.\nThree phases: before, during overlap, after.",
            "examples": [
                {
                    "input": "intervals = [[1,3],[6,9]]; newInterval = [2,5]",
                    "output": "[[1,5],[6,9]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Insert and merge new interval into sorted list.",
                "Three phases: before, during overlap, after.",
                "Merge during overlap by extending bounds."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "A8NUOmlwOlM"
        },
        "minimum-number-of-arrows-to-burst-balloons": {
            "title": "Minimum Number of Arrows to Burst Balloons",
            "pattern": "Greedy Interval",
            "patternEmoji": "\ud83c\udfaf",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Sort by end. Shoot at end of first, skip all overlapping.",
            "intuition": [
                "\ud83c\udfaf Minimum arrows to burst all balloons.",
                "\ud83e\udde0 Sort by end point. Each arrow at end pops all touching.",
                "\ud83d\udca1 Greedy: shoot as late as possible within current set."
            ],
            "testCases": [
                {
                    "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
                    "output": "2"
                }
            ],
            "code": "def findMinArrowPoints(points):\n    if not points: return 0\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    end = points[0][1]\n    for start, e in points[1:]:\n        if start > end:\n            arrows += 1\n            end = e\n    return arrows",
            "keyInsight": "Sorting by end allows greedy selection of arrow positions.",
            "visualizationType": "array",
            "initialState": [
                [
                    10,
                    16
                ],
                [
                    2,
                    8
                ],
                [
                    1,
                    6
                ],
                [
                    7,
                    12
                ]
            ],
            "animationSteps": [],
            "description": "Sort by end. Shoot at end of first, skip all overlapping.\n\nMinimum arrows to burst all balloons.\nSort by end point. Each arrow at end pops all touching.",
            "examples": [
                {
                    "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Minimum arrows to burst all balloons.",
                "Sort by end point. Each arrow at end pops all touching.",
                "Greedy: shoot as late as possible within current set."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "lPmkKnxBFs0"
        },
        "reverse-nodes-in-k-group": {
            "title": "Reverse Nodes in k-Group",
            "pattern": "Iterative Reversal",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Reverse k nodes at a time, connect reversed groups.",
            "intuition": [
                "\ud83c\udfaf Reverse every k nodes, leave remainder as-is.",
                "\ud83e\udde0 Find kth node, reverse that segment, connect.",
                "\ud83d\udca1 Use dummy head for cleaner edge case handling."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,4,5]; k = 2",
                    "output": "[2,1,4,3,5]"
                }
            ],
            "code": "def reverseKGroup(head, k):\n    dummy = ListNode(0, head)\n    prevGroup = dummy\n    while True:\n        kth = prevGroup\n        for _ in range(k):\n            kth = kth.next\n            if not kth:\n                return dummy.next\n        nextGroup = kth.next\n        prev, curr = kth.next, prevGroup.next\n        while curr != nextGroup:\n            tmp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = tmp\n        tmp = prevGroup.next\n        prevGroup.next = kth\n        prevGroup = tmp\n    return dummy.next",
            "keyInsight": "Track prevGroup to connect reversed segments.",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [],
            "description": "Reverse k nodes at a time, connect reversed groups.\n\nReverse every k nodes, leave remainder as-is.\nFind kth node, reverse that segment, connect.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5]; k = 2",
                    "output": "[2,1,4,3,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Reverse every k nodes, leave remainder as-is.",
                "Find kth node, reverse that segment, connect.",
                "Use dummy head for cleaner edge case handling."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "1UOPsfP85V4"
        },
        "remove-nth-node-from-end-of-list": {
            "title": "Remove Nth Node From End of List",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc46\ud83d\udc46",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Advance fast by n, then move both until fast reaches end.",
            "intuition": [
                "\ud83c\udfaf Remove nth node from end in one pass.",
                "\ud83e\udde0 Fast pointer leads by n. When fast ends, slow is at target.",
                "\ud83d\udca1 Use dummy to handle removing head."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,4,5]; n = 2",
                    "output": "[1,2,3,5]"
                }
            ],
            "code": "def removeNthFromEnd(head, n):\n    dummy = ListNode(0, head)\n    slow = fast = dummy\n    for _ in range(n + 1):\n        fast = fast.next\n    while fast:\n        slow = slow.next\n        fast = fast.next\n    slow.next = slow.next.next\n    return dummy.next",
            "keyInsight": "Dummy node simplifies removing the head case.",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [],
            "description": "Advance fast by n, then move both until fast reaches end.\n\nRemove nth node from end in one pass.\nFast pointer leads by n. When fast ends, slow is at target.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5]; n = 2",
                    "output": "[1,2,3,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Remove nth node from end in one pass.",
                "Fast pointer leads by n. When fast ends, slow is at target.",
                "Use dummy to handle removing head."
            ],
            "relatedProblems": [
                "two-sum",
                "container-with-most-water",
                "3sum"
            ],
            "videoId": "XVuQxVej6y8"
        },
        "remove-duplicates-from-sorted-list-ii": {
            "title": "Remove Duplicates from Sorted List II",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Skip all nodes with duplicate values, keep only unique.",
            "intuition": [
                "\ud83c\udfaf Remove all duplicated nodes (not just extra copies).",
                "\ud83e\udde0 If cur.val == cur.next.val, skip all with that value.",
                "\ud83d\udca1 Dummy head handles removing head."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,3,4,4,5]",
                    "output": "[1,2,5]"
                }
            ],
            "code": "def deleteDuplicates(head):\n    dummy = ListNode(0, head)\n    prev = dummy\n    while head:\n        if head.next and head.val == head.next.val:\n            while head.next and head.val == head.next.val:\n                head = head.next\n            prev.next = head.next\n        else:\n            prev = prev.next\n        head = head.next\n    return dummy.next",
            "keyInsight": "Skip entire duplicate sequences, not just individual copies.",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                2,
                3,
                3,
                4,
                4,
                5
            ],
            "animationSteps": [],
            "description": "Skip all nodes with duplicate values, keep only unique.\n\nRemove all duplicated nodes (not just extra copies).\nIf cur.val == cur.next.val, skip all with that value.",
            "examples": [
                {
                    "input": "head = [1,2,3,3,4,4,5]",
                    "output": "[1,2,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Remove all duplicated nodes (not just extra copies).",
                "If cur.val == cur.next.val, skip all with that value.",
                "Dummy head handles removing head."
            ],
            "relatedProblems": [
                "two-sum",
                "container-with-most-water",
                "3sum"
            ],
            "videoId": "aBNILPZdQNc"
        },
        "rotate-list": {
            "title": "Rotate List",
            "pattern": "Cycle + Break",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Make cycle, find new tail at (len - k % len - 1), break.",
            "intuition": [
                "\ud83c\udfaf Rotate list right by k places.",
                "\ud83e\udde0 Connect tail to head, find new tail, break there.",
                "\ud83d\udca1 k % len handles k > len."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,4,5]; k = 2",
                    "output": "[4,5,1,2,3]"
                }
            ],
            "code": "def rotateRight(head, k):\n    if not head or not head.next or k == 0:\n        return head\n    length = 1\n    tail = head\n    while tail.next:\n        tail = tail.next\n        length += 1\n    k %= length\n    if k == 0:\n        return head\n    tail.next = head  # Make cycle\n    steps = length - k\n    newTail = head\n    for _ in range(steps - 1):\n        newTail = newTail.next\n    newHead = newTail.next\n    newTail.next = None\n    return newHead",
            "keyInsight": "Creating a cycle simplifies finding the new head/tail.",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [],
            "description": "Make cycle, find new tail at (len - k % len - 1), break.\n\nRotate list right by k places.\nConnect tail to head, find new tail, break there.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5]; k = 2",
                    "output": "[4,5,1,2,3]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Rotate list right by k places.",
                "Connect tail to head, find new tail, break there.",
                "k % len handles k > len."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "UcGtPs2LE_c"
        },
        "partition-list": {
            "title": "Partition List",
            "pattern": "Two Dummy Lists",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Build two lists: less than x, greater or equal. Concatenate.",
            "intuition": [
                "\ud83c\udfaf Partition around x, preserving relative order.",
                "\ud83e\udde0 Two dummy heads for less and greater-or-equal lists.",
                "\ud83d\udca1 Connect them at the end."
            ],
            "testCases": [
                {
                    "input": "head = [1,4,3,2,5,2]; x = 3",
                    "output": "[1,2,2,4,3,5]"
                }
            ],
            "code": "def partition(head, x):\n    before = beforeHead = ListNode(0)\n    after = afterHead = ListNode(0)\n    while head:\n        if head.val < x:\n            before.next = head\n            before = before.next\n        else:\n            after.next = head\n            after = after.next\n        head = head.next\n    after.next = None\n    before.next = afterHead.next\n    return beforeHead.next",
            "keyInsight": "Two lists avoid in-place reordering complexity.",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                4,
                3,
                2,
                5,
                2
            ],
            "animationSteps": [],
            "description": "Build two lists: less than x, greater or equal. Concatenate.\n\nPartition around x, preserving relative order.\nTwo dummy heads for less and greater-or-equal lists.",
            "examples": [
                {
                    "input": "head = [1,4,3,2,5,2]; x = 3",
                    "output": "[1,2,2,4,3,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Partition around x, preserving relative order.",
                "Two dummy heads for less and greater-or-equal lists.",
                "Connect them at the end."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "KT1iUciJr4g"
        },
        "sort-list": {
            "title": "Sort List",
            "pattern": "Merge Sort",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(log n)",
            "oneliner": "Find middle, split, recursively sort, merge.",
            "intuition": [
                "\ud83c\udfaf Sort linked list in O(n log n) time.",
                "\ud83e\udde0 Merge sort: split at middle, recurse, merge.",
                "\ud83d\udca1 Fast/slow to find middle."
            ],
            "testCases": [
                {
                    "input": "head = [4,2,1,3]",
                    "output": "[1,2,3,4]"
                }
            ],
            "code": "def sortList(head):\n    if not head or not head.next:\n        return head\n    slow, fast = head, head.next\n    while fast and fast.next:\n        slow, fast = slow.next, fast.next.next\n    mid = slow.next\n    slow.next = None\n    left = sortList(head)\n    right = sortList(mid)\n    return merge(left, right)\n\ndef merge(l1, l2):\n    dummy = tail = ListNode(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            tail.next, l1 = l1, l1.next\n        else:\n            tail.next, l2 = l2, l2.next\n        tail = tail.next\n    tail.next = l1 or l2\n    return dummy.next",
            "keyInsight": "Merge sort is ideal for linked lists due to O(1) merge.",
            "visualizationType": "linkedlist",
            "initialState": [
                4,
                2,
                1,
                3
            ],
            "animationSteps": [],
            "description": "Find middle, split, recursively sort, merge.\n\nSort linked list in O(n log n) time.\nMerge sort: split at middle, recurse, merge.",
            "examples": [
                {
                    "input": "head = [4,2,1,3]",
                    "output": "[1,2,3,4]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Sort linked list in O(n log n) time.",
                "Merge sort: split at middle, recurse, merge.",
                "Fast/slow to find middle."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "TGveA1oFhrc"
        },
        "construct-binary-tree-from-preorder-and-inorder-traversal": {
            "title": "Construct Binary Tree from Preorder and Inorder Traversal",
            "pattern": "Divide and Conquer",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Preorder first is root. Find it in inorder to split left/right.",
            "intuition": [
                "\ud83c\udfaf Build tree from preorder and inorder.",
                "\ud83e\udde0 Preorder[0] = root. Find in inorder to know left/right sizes.",
                "\ud83d\udca1 Use hashmap for O(1) index lookup."
            ],
            "testCases": [
                {
                    "input": "preorder = [3,9,20,15,7]; inorder = [9,3,15,20,7]",
                    "output": "[3,9,20,null,null,15,7]"
                }
            ],
            "code": "def buildTree(preorder, inorder):\n    if not preorder:\n        return None\n    idx_map = {v: i for i, v in enumerate(inorder)}\n    def build(preL, preR, inL, inR):\n        if preL > preR:\n            return None\n        root = TreeNode(preorder[preL])\n        mid = idx_map[preorder[preL]]\n        leftSize = mid - inL\n        root.left = build(preL + 1, preL + leftSize, inL, mid - 1)\n        root.right = build(preL + leftSize + 1, preR, mid + 1, inR)\n        return root\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)",
            "keyInsight": "Preorder gives root, inorder gives subtree boundaries.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "Preorder first is root. Find it in inorder to split left/right.\n\nBuild tree from preorder and inorder.\nPreorder[0] = root. Find in inorder to know left/right sizes.",
            "examples": [
                {
                    "input": "preorder = [3,9,20,15,7]; inorder = [9,3,15,20,7]",
                    "output": "[3,9,20,null,null,15,7]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Build tree from preorder and inorder.",
                "Preorder[0] = root. Find in inorder to know left/right sizes.",
                "Use hashmap for O(1) index lookup."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "ihj4IQGZ2zc"
        },
        "construct-binary-tree-from-inorder-and-postorder-traversal": {
            "title": "Construct Binary Tree from Inorder and Postorder Traversal",
            "pattern": "Divide and Conquer",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Postorder last is root. Build right subtree first (reverse postorder).",
            "intuition": [
                "\ud83c\udfaf Build tree from inorder and postorder.",
                "\ud83e\udde0 Postorder[-1] = root. Process right subtree first.",
                "\ud83d\udca1 Use hashmap for inorder index lookup."
            ],
            "testCases": [
                {
                    "input": "inorder = [9,3,15,20,7]; postorder = [9,15,7,20,3]",
                    "output": "[3,9,20,null,null,15,7]"
                }
            ],
            "code": "def buildTree(inorder, postorder):\n    idx_map = {v: i for i, v in enumerate(inorder)}\n    self_idx = [len(postorder) - 1]\n    def build(inL, inR):\n        if inL > inR:\n            return None\n        root = TreeNode(postorder[self_idx[0]])\n        mid = idx_map[postorder[self_idx[0]]]\n        self_idx[0] -= 1\n        root.right = build(mid + 1, inR)\n        root.left = build(inL, mid - 1)\n        return root\n    return build(0, len(inorder) - 1)",
            "keyInsight": "Build right subtree first since postorder is left-right-root.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "Postorder last is root. Build right subtree first (reverse postorder).\n\nBuild tree from inorder and postorder.\nPostorder[-1] = root. Process right subtree first.",
            "examples": [
                {
                    "input": "inorder = [9,3,15,20,7]; postorder = [9,15,7,20,3]",
                    "output": "[3,9,20,null,null,15,7]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Build tree from inorder and postorder.",
                "Postorder[-1] = root. Process right subtree first.",
                "Use hashmap for inorder index lookup."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "vm-2tbxcCPo"
        },
        "flatten-binary-tree-to-linked-list": {
            "title": "Flatten Binary Tree to Linked List",
            "pattern": "Preorder + Pointer Manipulation",
            "patternEmoji": "\ud83d\udccb",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Find rightmost of left subtree, connect to right, move left to right.",
            "intuition": [
                "\ud83c\udfaf Flatten tree to right-skewed linked list (preorder).",
                "\ud83e\udde0 For each node: find rightmost of left, connect to right.",
                "\ud83d\udca1 Then move left subtree to right, nullify left."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,5,3,4,null,6]",
                    "output": "[1,null,2,null,3,null,4,null,5,null,6]"
                }
            ],
            "code": "def flatten(root):\n    curr = root\n    while curr:\n        if curr.left:\n            prev = curr.left\n            while prev.right:\n                prev = prev.right\n            prev.right = curr.right\n            curr.right = curr.left\n            curr.left = None\n        curr = curr.right\n    return root",
            "keyInsight": "Morris-like traversal without recursion or stack.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                5,
                3,
                4,
                null,
                6
            ],
            "animationSteps": [],
            "description": "Find rightmost of left subtree, connect to right, move left to right.\n\nFlatten tree to right-skewed linked list (preorder).\nFor each node: find rightmost of left, connect to right.",
            "examples": [
                {
                    "input": "root = [1,2,5,3,4,null,6]",
                    "output": "[1,null,2,null,3,null,4,null,5,null,6]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Flatten tree to right-skewed linked list (preorder).",
                "For each node: find rightmost of left, connect to right.",
                "Then move left subtree to right, nullify left."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "rKnD7rLT0lI"
        },
        "path-sum": {
            "title": "Path Sum",
            "pattern": "DFS",
            "patternEmoji": "\ud83d\udee4\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "DFS, subtract node value, check leaf with remaining 0.",
            "intuition": [
                "\ud83c\udfaf Does any root-to-leaf path sum to target?",
                "\ud83e\udde0 DFS: subtract current value, recurse.",
                "\ud83d\udca1 At leaf, check if remaining == 0."
            ],
            "testCases": [
                {
                    "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1]; targetSum = 22",
                    "output": "true"
                }
            ],
            "code": "def hasPathSum(root, targetSum):\n    if not root:\n        return False\n    if not root.left and not root.right:\n        return targetSum == root.val\n    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)",
            "keyInsight": "Check leaf condition: no left AND no right child.",
            "visualizationType": "tree",
            "initialState": [
                5,
                4,
                8,
                11,
                null,
                13,
                4,
                7,
                2,
                null,
                null,
                null,
                1
            ],
            "animationSteps": [],
            "description": "DFS, subtract node value, check leaf with remaining 0.\n\nDoes any root-to-leaf path sum to target?\nDFS: subtract current value, recurse.",
            "examples": [
                {
                    "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1]; targetSum = 22",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Does any root-to-leaf path sum to target?",
                "DFS: subtract current value, recurse.",
                "At leaf, check if remaining == 0."
            ],
            "relatedProblems": [
                "number-of-islands",
                "clone-graph",
                "course-schedule"
            ],
            "videoId": "LSKQyOz_P8I"
        },
        "sum-root-to-leaf-numbers": {
            "title": "Sum Root to Leaf Numbers",
            "pattern": "DFS",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "DFS carrying current number. At leaf, add to sum.",
            "intuition": [
                "\ud83c\udfaf Sum all root-to-leaf numbers.",
                "\ud83e\udde0 Pass current number * 10 + node.val down.",
                "\ud83d\udca1 At leaf, return current number."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,3]",
                    "output": "25"
                }
            ],
            "code": "def sumNumbers(root):\n    def dfs(node, curr):\n        if not node:\n            return 0\n        curr = curr * 10 + node.val\n        if not node.left and not node.right:\n            return curr\n        return dfs(node.left, curr) + dfs(node.right, curr)\n    return dfs(root, 0)",
            "keyInsight": "Build number digit by digit as you traverse.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                3
            ],
            "animationSteps": [],
            "description": "DFS carrying current number. At leaf, add to sum.\n\nSum all root-to-leaf numbers.\nPass current number * 10 + node.val down.",
            "examples": [
                {
                    "input": "root = [1,2,3]",
                    "output": "25"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Sum all root-to-leaf numbers.",
                "Pass current number * 10 + node.val down.",
                "At leaf, return current number."
            ],
            "relatedProblems": [
                "number-of-islands",
                "clone-graph",
                "course-schedule"
            ],
            "videoId": "Jk16lZGFWxE"
        },
        "binary-tree-maximum-path-sum": {
            "title": "Binary Tree Maximum Path Sum",
            "pattern": "DFS + Global Max",
            "patternEmoji": "\ud83c\udfc6",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "For each node, compute max path through it. Update global max.",
            "intuition": [
                "\ud83c\udfaf Find max path sum (any path in tree).",
                "\ud83e\udde0 At each node: max = node + left + right. Return node + max(left, right).",
                "\ud83d\udca1 Use global variable to track overall max."
            ],
            "testCases": [
                {
                    "input": "root = [-10,9,20,null,null,15,7]",
                    "output": "42"
                }
            ],
            "code": "def maxPathSum(root):\n    maxSum = [float('-inf')]\n    def dfs(node):\n        if not node:\n            return 0\n        left = max(0, dfs(node.left))\n        right = max(0, dfs(node.right))\n        maxSum[0] = max(maxSum[0], node.val + left + right)\n        return node.val + max(left, right)\n    dfs(root)\n    return maxSum[0]",
            "keyInsight": "Return single branch max, but compute cross-node max internally.",
            "visualizationType": "tree",
            "initialState": [
                -10,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "For each node, compute max path through it. Update global max.\n\nFind max path sum (any path in tree).\nAt each node: max = node + left + right. Return node + max(left, right).",
            "examples": [
                {
                    "input": "root = [-10,9,20,null,null,15,7]",
                    "output": "42"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find max path sum (any path in tree).",
                "At each node: max = node + left + right. Return node + max(left, right).",
                "Use global variable to track overall max."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Hr5cWUld4vU"
        },
        "count-complete-tree-nodes": {
            "title": "Count Complete Tree Nodes",
            "pattern": "Binary Search on Tree",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(log\u00b2 n)",
            "spaceComplexity": "O(log n)",
            "oneliner": "Compare left/right depths. If equal, left is perfect. Otherwise right is.",
            "intuition": [
                "\ud83c\udfaf Count nodes in complete binary tree efficiently.",
                "\ud83e\udde0 If left depth == right depth, left is perfect (2^d - 1 nodes).",
                "\ud83d\udca1 Recurse on the other side."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,3,4,5,6]",
                    "output": "6"
                }
            ],
            "code": "def countNodes(root):\n    if not root:\n        return 0\n    leftD = rightD = 0\n    l, r = root, root\n    while l:\n        leftD += 1\n        l = l.left\n    while r:\n        rightD += 1\n        r = r.right\n    if leftD == rightD:\n        return (1 << leftD) - 1\n    return 1 + countNodes(root.left) + countNodes(root.right)",
            "keyInsight": "Complete tree allows O(log\u00b2 n) instead of O(n).",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "animationSteps": [],
            "description": "Compare left/right depths. If equal, left is perfect. Otherwise right is.\n\nCount nodes in complete binary tree efficiently.\nIf left depth == right depth, left is perfect (2^d - 1 nodes).",
            "examples": [
                {
                    "input": "root = [1,2,3,4,5,6]",
                    "output": "6"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count nodes in complete binary tree efficiently.",
                "If left depth == right depth, left is perfect (2^d - 1 nodes).",
                "Recurse on the other side."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "u-yWemKGWO0"
        },
        "binary-tree-right-side-view": {
            "title": "Binary Tree Right Side View",
            "pattern": "BFS",
            "patternEmoji": "\ud83d\udc41\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "BFS level by level, take last node of each level.",
            "intuition": [
                "\ud83c\udfaf Return rightmost node at each level.",
                "\ud83e\udde0 BFS: at each level, record last node.",
                "\ud83d\udca1 Or DFS with level tracking, process right first."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,3,null,5,null,4]",
                    "output": "[1,3,4]"
                }
            ],
            "code": "from collections import deque\n\ndef rightSideView(root):\n    if not root:\n        return []\n    res = []\n    q = deque([root])\n    while q:\n        size = len(q)\n        for i in range(size):\n            node = q.popleft()\n            if i == size - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n    return res",
            "keyInsight": "Take the last node at each level during BFS.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                3,
                null,
                5,
                null,
                4
            ],
            "animationSteps": [],
            "description": "BFS level by level, take last node of each level.\n\nReturn rightmost node at each level.\nBFS: at each level, record last node.",
            "examples": [
                {
                    "input": "root = [1,2,3,null,5,null,4]",
                    "output": "[1,3,4]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Return rightmost node at each level.",
                "BFS: at each level, record last node.",
                "Or DFS with level tracking, process right first."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal",
                "word-ladder",
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "d4zLyf32e3I"
        },
        "average-of-levels-in-binary-tree": {
            "title": "Average of Levels in Binary Tree",
            "pattern": "BFS",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "BFS level by level, compute average per level.",
            "intuition": [
                "\ud83c\udfaf Return average value at each level.",
                "\ud83e\udde0 BFS: sum nodes at each level, divide by count.",
                "\ud83d\udca1 Process level by level with queue."
            ],
            "testCases": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[3.0,14.5,11.0]"
                }
            ],
            "code": "from collections import deque\n\ndef averageOfLevels(root):\n    if not root:\n        return []\n    res = []\n    q = deque([root])\n    while q:\n        size = len(q)\n        total = 0\n        for _ in range(size):\n            node = q.popleft()\n            total += node.val\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n        res.append(total / size)\n    return res",
            "keyInsight": "Sum all nodes at each level and divide by count.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "BFS level by level, compute average per level.\n\nReturn average value at each level.\nBFS: sum nodes at each level, divide by count.",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[3.0,14.5,11.0]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Return average value at each level.",
                "BFS: sum nodes at each level, divide by count.",
                "Process level by level with queue."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal",
                "word-ladder",
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "i3_fDqR_dYs"
        },
        "binary-tree-zigzag-level-order-traversal": {
            "title": "Binary Tree Zigzag Level Order Traversal",
            "pattern": "BFS + Direction Flag",
            "patternEmoji": "\u26a1",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "BFS, alternate direction each level (reverse odd levels).",
            "intuition": [
                "\ud83c\udfaf Level order but alternating left-right direction.",
                "\ud83e\udde0 BFS with direction flag. Reverse level if needed.",
                "\ud83d\udca1 Or use deque to add from different ends."
            ],
            "testCases": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[[3],[20,9],[15,7]]"
                }
            ],
            "code": "from collections import deque\n\ndef zigzagLevelOrder(root):\n    if not root:\n        return []\n    res = []\n    q = deque([root])\n    leftToRight = True\n    while q:\n        size = len(q)\n        level = deque()\n        for _ in range(size):\n            node = q.popleft()\n            if leftToRight:\n                level.append(node.val)\n            else:\n                level.appendleft(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n        res.append(list(level))\n        leftToRight = not leftToRight\n    return res",
            "keyInsight": "Use deque's appendleft for reverse direction.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "BFS, alternate direction each level (reverse odd levels).\n\nLevel order but alternating left-right direction.\nBFS with direction flag. Reverse level if needed.",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[[3],[20,9],[15,7]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Level order but alternating left-right direction.",
                "BFS with direction flag. Reverse level if needed.",
                "Or use deque to add from different ends."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "igbboQbiwqw"
        },
        "minimum-absolute-difference-in-bst": {
            "title": "Minimum Absolute Difference in BST",
            "pattern": "Inorder Traversal",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Inorder gives sorted order. Track prev, compare adjacent.",
            "intuition": [
                "\ud83c\udfaf Find min diff between any two nodes.",
                "\ud83e\udde0 Inorder traversal gives sorted values.",
                "\ud83d\udca1 Min diff is between adjacent sorted values."
            ],
            "testCases": [
                {
                    "input": "root = [4,2,6,1,3]",
                    "output": "1"
                }
            ],
            "code": "def getMinimumDifference(root):\n    prev = [None]\n    minDiff = [float('inf')]\n    def inorder(node):\n        if not node: return\n        inorder(node.left)\n        if prev[0] is not None:\n            minDiff[0] = min(minDiff[0], node.val - prev[0])\n        prev[0] = node.val\n        inorder(node.right)\n    inorder(root)\n    return minDiff[0]",
            "keyInsight": "Inorder on BST is sorted, so min diff is between adjacent.",
            "visualizationType": "tree",
            "initialState": [
                4,
                2,
                6,
                1,
                3
            ],
            "animationSteps": [],
            "description": "Inorder gives sorted order. Track prev, compare adjacent.\n\nFind min diff between any two nodes.\nInorder traversal gives sorted values.",
            "examples": [
                {
                    "input": "root = [4,2,6,1,3]",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find min diff between any two nodes.",
                "Inorder traversal gives sorted values.",
                "Min diff is between adjacent sorted values."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "9LxvhVvBnCI"
        },
        "kth-smallest-element-in-a-bst": {
            "title": "Kth Smallest Element in a BST",
            "pattern": "Inorder Traversal",
            "patternEmoji": "\ud83c\udfc6",
            "timeComplexity": "O(h + k)",
            "spaceComplexity": "O(h)",
            "oneliner": "Inorder traversal, return kth element.",
            "intuition": [
                "\ud83c\udfaf Find kth smallest element in BST.",
                "\ud83e\udde0 Inorder = sorted order. Count until k.",
                "\ud83d\udca1 Use iterative inorder with stack."
            ],
            "testCases": [
                {
                    "input": "root = [3,1,4,null,2]; k = 1",
                    "output": "1"
                }
            ],
            "code": "def kthSmallest(root, k):\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if k == 0:\n            return root.val\n        root = root.right",
            "keyInsight": "Iterative inorder avoids full traversal for small k.",
            "visualizationType": "tree",
            "initialState": [
                3,
                1,
                4,
                null,
                2
            ],
            "animationSteps": [],
            "description": "Inorder traversal, return kth element.\n\nFind kth smallest element in BST.\nInorder = sorted order. Count until k.",
            "examples": [
                {
                    "input": "root = [3,1,4,null,2]; k = 1",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find kth smallest element in BST.",
                "Inorder = sorted order. Count until k.",
                "Use iterative inorder with stack."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "5LUXSvjmGCw"
        },
        "validate-binary-search-tree": {
            "title": "Validate Binary Search Tree",
            "pattern": "DFS with Range",
            "patternEmoji": "\u2705",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "DFS with min/max bounds. Node must be in (min, max).",
            "intuition": [
                "\ud83c\udfaf Is this a valid BST?",
                "\ud83e\udde0 Each node has a valid range (min, max).",
                "\ud83d\udca1 Left: update max. Right: update min."
            ],
            "testCases": [
                {
                    "input": "root = [2,1,3]",
                    "output": "true"
                },
                {
                    "input": "root = [5,1,4,null,null,3,6]",
                    "output": "false"
                }
            ],
            "code": "def isValidBST(root):\n    def validate(node, lo, hi):\n        if not node:\n            return True\n        if not (lo < node.val < hi):\n            return False\n        return validate(node.left, lo, node.val) and validate(node.right, node.val, hi)\n    return validate(root, float('-inf'), float('inf'))",
            "keyInsight": "Each node must satisfy min < node.val < max constraint.",
            "visualizationType": "tree",
            "initialState": [
                2,
                1,
                3
            ],
            "animationSteps": [],
            "description": "DFS with min/max bounds. Node must be in (min, max).\n\nIs this a valid BST?\nEach node has a valid range (min, max).",
            "examples": [
                {
                    "input": "root = [2,1,3]",
                    "output": "true"
                },
                {
                    "input": "root = [5,1,4,null,null,3,6]",
                    "output": "false"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Is this a valid BST?",
                "Each node has a valid range (min, max).",
                "Left: update max. Right: update min."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "s6ATEkipzow"
        },
        "lowest-common-ancestor-of-a-bst": {
            "title": "Lowest Common Ancestor of a BST",
            "pattern": "BST Property",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(h)",
            "spaceComplexity": "O(1)",
            "oneliner": "If both p,q < node, go left. If both > node, go right. Else LCA.",
            "intuition": [
                "\ud83c\udfaf Find LCA in BST (not general tree).",
                "\ud83e\udde0 Use BST property: p < node < q means split.",
                "\ud83d\udca1 First node where p and q split is LCA."
            ],
            "testCases": [
                {
                    "input": "root = [6,2,8,0,4,7,9,null,null,3,5]; p = 2; q = 8",
                    "output": "6"
                }
            ],
            "code": "def lowestCommonAncestor(root, p, q):\n    while root:\n        if p < root.val and q < root.val:\n            root = root.left\n        elif p > root.val and q > root.val:\n            root = root.right\n        else:\n            return root.val\n    return None",
            "keyInsight": "BST structure lets us decide direction without full search.",
            "visualizationType": "tree",
            "initialState": [
                6,
                2,
                8,
                0,
                4,
                7,
                9
            ],
            "animationSteps": [],
            "description": "If both p,q < node, go left. If both > node, go right. Else LCA.\n\nFind LCA in BST (not general tree).\nUse BST property: p < node < q means split.",
            "examples": [
                {
                    "input": "root = [6,2,8,0,4,7,9,null,null,3,5]; p = 2; q = 8",
                    "output": "6"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find LCA in BST (not general tree).",
                "Use BST property: p < node < q means split.",
                "First node where p and q split is LCA."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "gs2LMfuOR9k"
        },
        "balance-a-binary-search-tree": {
            "title": "Balance a Binary Search Tree",
            "pattern": "Inorder + Rebuild",
            "patternEmoji": "\u2696\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Inorder to sorted array. Build balanced BST from array.",
            "intuition": [
                "\ud83c\udfaf Convert BST to balanced BST.",
                "\ud83e\udde0 Extract sorted array via inorder.",
                "\ud83d\udca1 Recursively build from middle element."
            ],
            "testCases": [
                {
                    "input": "root = [1,null,2,null,3,null,4]",
                    "output": "[2,1,3,null,null,null,4]"
                }
            ],
            "code": "def balanceBST(root):\n    vals = []\n    def inorder(node):\n        if not node: return\n        inorder(node.left)\n        vals.append(node.val)\n        inorder(node.right)\n    inorder(root)\n    def build(l, r):\n        if l > r: return None\n        mid = (l + r) // 2\n        node = TreeNode(vals[mid])\n        node.left = build(l, mid - 1)\n        node.right = build(mid + 1, r)\n        return node\n    return build(0, len(vals) - 1)",
            "keyInsight": "Middle element as root gives balanced tree.",
            "visualizationType": "tree",
            "initialState": [
                1,
                null,
                2,
                null,
                3,
                null,
                4
            ],
            "animationSteps": [],
            "description": "Inorder to sorted array. Build balanced BST from array.\n\nConvert BST to balanced BST.\nExtract sorted array via inorder.",
            "examples": [
                {
                    "input": "root = [1,null,2,null,3,null,4]",
                    "output": "[2,1,3,null,null,null,4]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Convert BST to balanced BST.",
                "Extract sorted array via inorder.",
                "Recursively build from middle element."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "fqx8z3VepMA"
        },
        "surrounded-regions": {
            "title": "Surrounded Regions",
            "pattern": "DFS from Border",
            "patternEmoji": "\ud83d\uddfa\ufe0f",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(m*n)",
            "oneliner": "DFS from border Os to mark safe. Flip remaining Os to Xs.",
            "intuition": [
                "\ud83c\udfaf Flip all O regions NOT connected to border.",
                "\ud83e\udde0 Mark border-connected Os as safe.",
                "\ud83d\udca1 Flip remaining Os, restore safe ones."
            ],
            "testCases": [
                {
                    "input": "board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
                    "output": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]"
                }
            ],
            "code": "def solve(board):\n    if not board: return board\n    m, n = len(board), len(board[0])\n    def dfs(r, c):\n        if r < 0 or r >= m or c < 0 or c >= n or board[r][c] != 'O':\n            return\n        board[r][c] = 'S'\n        dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1)\n    for r in range(m):\n        dfs(r, 0); dfs(r, n-1)\n    for c in range(n):\n        dfs(0, c); dfs(m-1, c)\n    for r in range(m):\n        for c in range(n):\n            board[r][c] = 'O' if board[r][c] == 'S' else 'X'\n    return board",
            "keyInsight": "Work from border inward to identify safe regions.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    "X",
                    "X",
                    "X",
                    "X"
                ],
                [
                    "X",
                    "O",
                    "O",
                    "X"
                ],
                [
                    "X",
                    "X",
                    "O",
                    "X"
                ],
                [
                    "X",
                    "O",
                    "X",
                    "X"
                ]
            ],
            "animationSteps": [],
            "description": "DFS from border Os to mark safe. Flip remaining Os to Xs.\n\nFlip all O regions NOT connected to border.\nMark border-connected Os as safe.",
            "examples": [
                {
                    "input": "board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
                    "output": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Flip all O regions NOT connected to border.",
                "Mark border-connected Os as safe.",
                "Flip remaining Os, restore safe ones."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "9z2BunfoZ5Y"
        },
        "evaluate-division": {
            "title": "Evaluate Division",
            "pattern": "Graph BFS/DFS",
            "patternEmoji": "\u2797",
            "timeComplexity": "O(Q*(V+E))",
            "spaceComplexity": "O(V+E)",
            "oneliner": "Build graph of ratios. DFS/BFS to find path and multiply.",
            "intuition": [
                "\ud83c\udfaf Evaluate queries given equations with values.",
                "\ud83e\udde0 Build weighted graph: a/b = k means edge a->b with weight k.",
                "\ud83d\udca1 Query a/c = path from a to c, multiply weights."
            ],
            "testCases": [
                {
                    "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]]; values = [2.0,3.0]; queries = [[\"a\",\"c\"]]",
                    "output": "[6.0]"
                }
            ],
            "code": "from collections import defaultdict\n\ndef calcEquation(equations, values, queries):\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n    \n    def dfs(start, end, visited):\n        if start not in graph or end not in graph:\n            return -1.0\n        if start == end:\n            return 1.0\n        visited.add(start)\n        for nei, val in graph[start].items():\n            if nei not in visited:\n                res = dfs(nei, end, visited)\n                if res != -1.0:\n                    return val * res\n        return -1.0\n    \n    return [dfs(a, b, set()) for a, b in queries]",
            "keyInsight": "Weighted graph where edge weight represents the ratio.",
            "visualizationType": "graph",
            "initialState": [],
            "animationSteps": [],
            "description": "Build graph of ratios. DFS/BFS to find path and multiply.\n\nEvaluate queries given equations with values.\nBuild weighted graph: a/b = k means edge a->b with weight k.",
            "examples": [
                {
                    "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]]; values = [2.0,3.0]; queries = [[\"a\",\"c\"]]",
                    "output": "[6.0]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Evaluate queries given equations with values.",
                "Build weighted graph: a/b = k means edge a->b with weight k.",
                "Query a/c = path from a to c, multiply weights."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Uei1fwDoyKk"
        },
        "course-schedule-ii": {
            "title": "Course Schedule II",
            "pattern": "Topological Sort",
            "patternEmoji": "\ud83d\udcda",
            "timeComplexity": "O(V+E)",
            "spaceComplexity": "O(V+E)",
            "oneliner": "Kahn's algorithm: BFS with indegree. Return order or [].",
            "intuition": [
                "\ud83c\udfaf Return valid course order or [] if impossible.",
                "\ud83e\udde0 Topological sort using indegree.",
                "\ud83d\udca1 If all courses processed, return order."
            ],
            "testCases": [
                {
                    "input": "numCourses = 4; prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
                    "output": "[0,1,2,3]"
                }
            ],
            "code": "from collections import deque, defaultdict\n\ndef findOrder(numCourses, prerequisites):\n    graph = defaultdict(list)\n    indegree = [0] * numCourses\n    for a, b in prerequisites:\n        graph[b].append(a)\n        indegree[a] += 1\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n    while q:\n        course = q.popleft()\n        order.append(course)\n        for nei in graph[course]:\n            indegree[nei] -= 1\n            if indegree[nei] == 0:\n                q.append(nei)\n    return order if len(order) == numCourses else []",
            "keyInsight": "Topological sort returns empty if cycle exists.",
            "visualizationType": "graph",
            "initialState": [],
            "animationSteps": [],
            "description": "Kahn's algorithm: BFS with indegree. Return order or [].\n\nReturn valid course order or [] if impossible.\nTopological sort using indegree.",
            "examples": [
                {
                    "input": "numCourses = 4; prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
                    "output": "[0,1,2,3]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Return valid course order or [] if impossible.",
                "Topological sort using indegree.",
                "If all courses processed, return order."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Akt3glAwyfY"
        },
        "diameter-of-binary-tree": {
            "title": "Diameter of Binary Tree",
            "pattern": "DFS + Global Max",
            "patternEmoji": "\ud83d\udccf",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "For each node, diameter through it = left_height + right_height.",
            "intuition": [
                "\ud83c\udfaf Longest path between any two nodes.",
                "\ud83e\udde0 At each node: path through it = left + right heights.",
                "\ud83d\udca1 Return height, but track max diameter."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,3,4,5]",
                    "output": "3"
                }
            ],
            "code": "def diameterOfBinaryTree(root):\n    diameter = [0]\n    def height(node):\n        if not node:\n            return 0\n        left = height(node.left)\n        right = height(node.right)\n        diameter[0] = max(diameter[0], left + right)\n        return 1 + max(left, right)\n    height(root)\n    return diameter[0]",
            "keyInsight": "Diameter through node = sum of left and right subtree heights.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [],
            "description": "For each node, diameter through it = left_height + right_height.\n\nLongest path between any two nodes.\nAt each node: path through it = left + right heights.",
            "examples": [
                {
                    "input": "root = [1,2,3,4,5]",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Longest path between any two nodes.",
                "At each node: path through it = left + right heights.",
                "Return height, but track max diameter."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "bkxqA8Rfv04"
        },
        "cheapest-flights-within-k-stops": {
            "title": "Cheapest Flights Within K Stops",
            "pattern": "BFS / Bellman-Ford",
            "patternEmoji": "\u2708\ufe0f",
            "timeComplexity": "O(K*E)",
            "spaceComplexity": "O(V)",
            "oneliner": "Modified Bellman-Ford: k+1 iterations. Or BFS with level tracking.",
            "intuition": [
                "\ud83c\udfaf Cheapest flight with at most k stops.",
                "\ud83e\udde0 Bellman-Ford with k+1 relaxations.",
                "\ud83d\udca1 Use copy of distances to avoid this-iteration dependency."
            ],
            "testCases": [
                {
                    "input": "n = 4; flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]]; src = 0; dst = 3; k = 1",
                    "output": "700"
                }
            ],
            "code": "def findCheapestPrice(n, flights, src, dst, k):\n    prices = [float('inf')] * n\n    prices[src] = 0\n    for _ in range(k + 1):\n        temp = prices[:]\n        for s, d, p in flights:\n            if prices[s] != float('inf'):\n                temp[d] = min(temp[d], prices[s] + p)\n        prices = temp\n    return prices[dst] if prices[dst] != float('inf') else -1",
            "keyInsight": "Use copy of prices array to ensure correct iteration count.",
            "visualizationType": "graph",
            "initialState": [],
            "animationSteps": [],
            "description": "Modified Bellman-Ford: k+1 iterations. Or BFS with level tracking.\n\nCheapest flight with at most k stops.\nBellman-Ford with k+1 relaxations.",
            "examples": [
                {
                    "input": "n = 4; flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]]; src = 0; dst = 3; k = 1",
                    "output": "700"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Cheapest flight with at most k stops.",
                "Bellman-Ford with k+1 relaxations.",
                "Use copy of distances to avoid this-iteration dependency."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "5eIK3zUdYmE"
        },
        "snakes-and-ladders": {
            "title": "Snakes and Ladders",
            "pattern": "BFS",
            "patternEmoji": "\ud83d\udc0d",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(n\u00b2)",
            "oneliner": "BFS from square 1. Follow snakes/ladders. Min moves to n\u00b2.",
            "intuition": [
                "\ud83c\udfaf Min dice rolls to reach last square.",
                "\ud83e\udde0 BFS level = number of moves.",
                "\ud83d\udca1 Handle boustrophedon numbering."
            ],
            "testCases": [
                {
                    "input": "board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]",
                    "output": "4"
                }
            ],
            "code": "from collections import deque\n\ndef snakesAndLadders(board):\n    n = len(board)\n    def getPos(sq):\n        r, c = divmod(sq - 1, n)\n        if r % 2 == 1:\n            c = n - 1 - c\n        return n - 1 - r, c\n    \n    q = deque([(1, 0)])\n    visited = {1}\n    while q:\n        sq, moves = q.popleft()\n        for i in range(1, 7):\n            nxt = sq + i\n            if nxt > n * n:\n                continue\n            r, c = getPos(nxt)\n            if board[r][c] != -1:\n                nxt = board[r][c]\n            if nxt == n * n:\n                return moves + 1\n            if nxt not in visited:\n                visited.add(nxt)\n                q.append((nxt, moves + 1))\n    return -1",
            "keyInsight": "Convert 1D square number to 2D board coordinates carefully.",
            "visualizationType": "matrix",
            "initialState": [],
            "animationSteps": [],
            "description": "BFS from square 1. Follow snakes/ladders. Min moves to n\u00b2.\n\nMin dice rolls to reach last square.\nBFS level = number of moves.",
            "examples": [
                {
                    "input": "board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min dice rolls to reach last square.",
                "BFS level = number of moves.",
                "Handle boustrophedon numbering."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal",
                "word-ladder",
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "6lH4nO3JfLk"
        },
        "minimum-genetic-mutation": {
            "title": "Minimum Genetic Mutation",
            "pattern": "BFS",
            "patternEmoji": "\ud83e\uddec",
            "timeComplexity": "O(B*8*4)",
            "spaceComplexity": "O(B)",
            "oneliner": "BFS from startGene. Each level = 1 mutation. Valid if in bank.",
            "intuition": [
                "\ud83c\udfaf Min mutations to reach endGene.",
                "\ud83e\udde0 BFS where edges are single char changes in bank.",
                "\ud83d\udca1 Each mutation changes one character to A/C/G/T."
            ],
            "testCases": [
                {
                    "input": "startGene = \"AACCGGTT\"; endGene = \"AAACGGTA\"; bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
                    "output": "2"
                }
            ],
            "code": "from collections import deque\n\ndef minMutation(startGene, endGene, bank):\n    bank = set(bank)\n    if endGene not in bank:\n        return -1\n    q = deque([(startGene, 0)])\n    visited = {startGene}\n    while q:\n        gene, mutations = q.popleft()\n        if gene == endGene:\n            return mutations\n        for i in range(8):\n            for c in 'ACGT':\n                nxt = gene[:i] + c + gene[i+1:]\n                if nxt in bank and nxt not in visited:\n                    visited.add(nxt)\n                    q.append((nxt, mutations + 1))\n    return -1",
            "keyInsight": "Try all single-character mutations, check if in bank.",
            "visualizationType": "string",
            "initialState": "AACCGGTT",
            "animationSteps": [],
            "description": "BFS from startGene. Each level = 1 mutation. Valid if in bank.\n\nMin mutations to reach endGene.\nBFS where edges are single char changes in bank.",
            "examples": [
                {
                    "input": "startGene = \"AACCGGTT\"; endGene = \"AAACGGTA\"; bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min mutations to reach endGene.",
                "BFS where edges are single char changes in bank.",
                "Each mutation changes one character to A/C/G/T."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal",
                "word-ladder",
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "H6VdY3SxjMM"
        },
        "word-ladder": {
            "title": "Word Ladder",
            "pattern": "BFS",
            "patternEmoji": "\ud83d\udd20",
            "timeComplexity": "O(M\u00b2*N)",
            "spaceComplexity": "O(M*N)",
            "oneliner": "BFS from beginWord. Valid moves = 1 char diff in wordList.",
            "intuition": [
                "\ud83c\udfaf Min transformations to endWord.",
                "\ud83e\udde0 BFS where each level = 1 transformation.",
                "\ud83d\udca1 Use wildcard patterns for O(M) adjacency."
            ],
            "testCases": [
                {
                    "input": "beginWord = \"hit\"; endWord = \"cog\"; wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                    "output": "5"
                }
            ],
            "code": "from collections import deque, defaultdict\n\ndef ladderLength(beginWord, endWord, wordList):\n    if endWord not in wordList:\n        return 0\n    wordList = set(wordList)\n    q = deque([(beginWord, 1)])\n    visited = {beginWord}\n    while q:\n        word, length = q.popleft()\n        if word == endWord:\n            return length\n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                nxt = word[:i] + c + word[i+1:]\n                if nxt in wordList and nxt not in visited:\n                    visited.add(nxt)\n                    q.append((nxt, length + 1))\n    return 0",
            "keyInsight": "BFS guarantees minimum transformation sequence.",
            "visualizationType": "string",
            "initialState": "hit",
            "animationSteps": [],
            "description": "BFS from beginWord. Valid moves = 1 char diff in wordList.\n\nMin transformations to endWord.\nBFS where each level = 1 transformation.",
            "examples": [
                {
                    "input": "beginWord = \"hit\"; endWord = \"cog\"; wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                    "output": "5"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min transformations to endWord.",
                "BFS where each level = 1 transformation.",
                "Use wildcard patterns for O(M) adjacency."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal",
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "h9iTnkgv05E"
        },
        "minimum-depth-of-binary-tree": {
            "title": "Minimum Depth of Binary Tree",
            "pattern": "BFS",
            "patternEmoji": "\ud83d\udccf",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "BFS level by level. Return level when first leaf found.",
            "intuition": [
                "\ud83c\udfaf Min depth to a leaf node.",
                "\ud83e\udde0 BFS finds closest leaf first.",
                "\ud83d\udca1 Better than DFS for unbalanced trees."
            ],
            "testCases": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "2"
                }
            ],
            "code": "from collections import deque\n\ndef minDepth(root):\n    if not root:\n        return 0\n    q = deque([(root, 1)])\n    while q:\n        node, depth = q.popleft()\n        if not node.left and not node.right:\n            return depth\n        if node.left:\n            q.append((node.left, depth + 1))\n        if node.right:\n            q.append((node.right, depth + 1))\n    return 0",
            "keyInsight": "BFS stops early when first leaf is found.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "BFS level by level. Return level when first leaf found.\n\nMin depth to a leaf node.\nBFS finds closest leaf first.",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min depth to a leaf node.",
                "BFS finds closest leaf first.",
                "Better than DFS for unbalanced trees."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal",
                "word-ladder",
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "tZS4VHtbYoo"
        },
        "letter-combinations-of-a-phone-number": {
            "title": "Letter Combinations of a Phone Number",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udcf1",
            "timeComplexity": "O(4^n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Map digits to letters. Backtrack all combinations.",
            "intuition": [
                "\ud83c\udfaf All letter combinations from digits.",
                "\ud83e\udde0 Digit -> letters mapping. Backtrack choices.",
                "\ud83d\udca1 Each digit adds multiple branches."
            ],
            "testCases": [
                {
                    "input": "digits = \"23\"",
                    "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                }
            ],
            "code": "def letterCombinations(digits):\n    if not digits:\n        return []\n    phone = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n             '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    res = []\n    def backtrack(i, path):\n        if i == len(digits):\n            res.append(''.join(path))\n            return\n        for c in phone[digits[i]]:\n            path.append(c)\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return res",
            "keyInsight": "Standard backtracking with fixed choices per position.",
            "visualizationType": "tree",
            "initialState": [],
            "animationSteps": [],
            "description": "Map digits to letters. Backtrack all combinations.\n\nAll letter combinations from digits.\nDigit -> letters mapping. Backtrack choices.",
            "examples": [
                {
                    "input": "digits = \"23\"",
                    "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "All letter combinations from digits.",
                "Digit -> letters mapping. Backtrack choices.",
                "Each digit adds multiple branches."
            ],
            "relatedProblems": [
                "permutations",
                "combination-sum",
                "subsets"
            ],
            "videoId": "0snEunUacZY"
        },
        "combinations": {
            "title": "Combinations",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(C(n,k))",
            "spaceComplexity": "O(k)",
            "oneliner": "Backtrack choosing k elements from 1 to n.",
            "intuition": [
                "\ud83c\udfaf All combinations of k numbers from 1 to n.",
                "\ud83e\udde0 Backtrack: pick or skip each number.",
                "\ud83d\udca1 Start from current to avoid duplicates."
            ],
            "testCases": [
                {
                    "input": "n = 4; k = 2",
                    "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
                }
            ],
            "code": "def combine(n, k):\n    res = []\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])\n            return\n        for i in range(start, n + 1):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(1, [])\n    return res",
            "keyInsight": "Start from 'start' index to avoid duplicate combinations.",
            "visualizationType": "tree",
            "initialState": [],
            "animationSteps": [],
            "description": "Backtrack choosing k elements from 1 to n.\n\nAll combinations of k numbers from 1 to n.\nBacktrack: pick or skip each number.",
            "examples": [
                {
                    "input": "n = 4; k = 2",
                    "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "All combinations of k numbers from 1 to n.",
                "Backtrack: pick or skip each number.",
                "Start from current to avoid duplicates."
            ],
            "relatedProblems": [
                "permutations",
                "combination-sum",
                "subsets"
            ],
            "videoId": "q0s6m7AiM7o"
        },
        "n-queens-ii": {
            "title": "N-Queens II",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udc51",
            "timeComplexity": "O(n!)",
            "spaceComplexity": "O(n)",
            "oneliner": "Place queens row by row. Track cols and diagonals.",
            "intuition": [
                "\ud83c\udfaf Count valid n-queens placements.",
                "\ud83e\udde0 Track used columns, diagonals, anti-diagonals.",
                "\ud83d\udca1 Row is implicit in recursion depth."
            ],
            "testCases": [
                {
                    "input": "n = 4",
                    "output": "2"
                }
            ],
            "code": "def totalNQueens(n):\n    cols = set()\n    posDiag = set()  # r + c\n    negDiag = set()  # r - c\n    count = [0]\n    def backtrack(r):\n        if r == n:\n            count[0] += 1\n            return\n        for c in range(n):\n            if c in cols or (r + c) in posDiag or (r - c) in negDiag:\n                continue\n            cols.add(c)\n            posDiag.add(r + c)\n            negDiag.add(r - c)\n            backtrack(r + 1)\n            cols.remove(c)\n            posDiag.remove(r + c)\n            negDiag.remove(r - c)\n    backtrack(0)\n    return count[0]",
            "keyInsight": "Diagonals identified by r+c (positive) and r-c (negative).",
            "visualizationType": "matrix",
            "initialState": [],
            "animationSteps": [],
            "description": "Place queens row by row. Track cols and diagonals.\n\nCount valid n-queens placements.\nTrack used columns, diagonals, anti-diagonals.",
            "examples": [
                {
                    "input": "n = 4",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count valid n-queens placements.",
                "Track used columns, diagonals, anti-diagonals.",
                "Row is implicit in recursion depth."
            ],
            "relatedProblems": [
                "permutations",
                "combination-sum",
                "subsets"
            ],
            "videoId": "lxvKVFC6qT0"
        },
        "generate-parentheses": {
            "title": "Generate Parentheses",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd32",
            "timeComplexity": "O(4^n / sqrt(n))",
            "spaceComplexity": "O(n)",
            "oneliner": "Add '(' if open < n. Add ')' if close < open.",
            "intuition": [
                "\ud83c\udfaf Generate all valid parentheses of n pairs.",
                "\ud83e\udde0 Can add '(' if count < n. Can add ')' if close < open.",
                "\ud83d\udca1 This ensures valid nesting."
            ],
            "testCases": [
                {
                    "input": "n = 3",
                    "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
                }
            ],
            "code": "def generateParenthesis(n):\n    res = []\n    def backtrack(s, openN, closeN):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if openN < n:\n            backtrack(s + '(', openN + 1, closeN)\n        if closeN < openN:\n            backtrack(s + ')', openN, closeN + 1)\n    backtrack('', 0, 0)\n    return res",
            "keyInsight": "Only add ')' when close count < open count.",
            "visualizationType": "tree",
            "initialState": [],
            "animationSteps": [],
            "description": "Add '(' if open < n. Add ')' if close < open.\n\nGenerate all valid parentheses of n pairs.\nCan add '(' if count < n. Can add ')' if close < open.",
            "examples": [
                {
                    "input": "n = 3",
                    "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Generate all valid parentheses of n pairs.",
                "Can add '(' if count < n. Can add ')' if close < open.",
                "This ensures valid nesting."
            ],
            "relatedProblems": [
                "permutations",
                "combination-sum",
                "subsets"
            ],
            "videoId": "s9fokUqJ76A"
        },
        "subsets": {
            "title": "Subsets",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udce6",
            "timeComplexity": "O(2^n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Backtrack: include or exclude each element.",
            "intuition": [
                "\ud83c\udfaf All subsets of a set.",
                "\ud83e\udde0 For each element: include or exclude.",
                "\ud83d\udca1 Results at every node, not just leaves."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3]",
                    "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
                }
            ],
            "code": "def subsets(nums):\n    res = []\n    def backtrack(start, path):\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return res",
            "keyInsight": "Add current path at every node, not just at leaves.",
            "visualizationType": "tree",
            "initialState": [],
            "animationSteps": [],
            "description": "Backtrack: include or exclude each element.\n\nAll subsets of a set.\nFor each element: include or exclude.",
            "examples": [
                {
                    "input": "nums = [1,2,3]",
                    "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "All subsets of a set.",
                "For each element: include or exclude.",
                "Results at every node, not just leaves."
            ],
            "relatedProblems": [
                "permutations",
                "combination-sum"
            ],
            "videoId": "REOH22Xwdkk"
        },
        "letter-case-permutation": {
            "title": "Letter Case Permutation",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd24",
            "timeComplexity": "O(2^n)",
            "spaceComplexity": "O(n)",
            "oneliner": "For each letter, branch on lower and upper case.",
            "intuition": [
                "\ud83c\udfaf All case permutations of letters.",
                "\ud83e\udde0 Digits: no choice. Letters: lower or upper.",
                "\ud83d\udca1 Binary branching on letters."
            ],
            "testCases": [
                {
                    "input": "s = \"a1b2\"",
                    "output": "[\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]"
                }
            ],
            "code": "def letterCasePermutation(s):\n    res = []\n    def backtrack(i, path):\n        if i == len(s):\n            res.append(''.join(path))\n            return\n        if s[i].isalpha():\n            path.append(s[i].lower())\n            backtrack(i + 1, path)\n            path.pop()\n            path.append(s[i].upper())\n            backtrack(i + 1, path)\n            path.pop()\n        else:\n            path.append(s[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return res",
            "keyInsight": "Letters create two branches; digits create one.",
            "visualizationType": "tree",
            "initialState": [],
            "animationSteps": [],
            "description": "For each letter, branch on lower and upper case.\n\nAll case permutations of letters.\nDigits: no choice. Letters: lower or upper.",
            "examples": [
                {
                    "input": "s = \"a1b2\"",
                    "output": "[\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "All case permutations of letters.",
                "Digits: no choice. Letters: lower or upper.",
                "Binary branching on letters."
            ],
            "relatedProblems": [
                "permutations",
                "combination-sum",
                "subsets"
            ],
            "videoId": "hwLRMlnY2Zk"
        },
        "merge-k-sorted-lists": {
            "title": "Merge k Sorted Lists",
            "pattern": "Divide and Conquer / Heap",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(N log k)",
            "spaceComplexity": "O(k)",
            "oneliner": "Use min-heap to always get smallest head. Or divide-conquer merge pairs.",
            "intuition": [
                "\ud83c\udfaf Merge k sorted linked lists.",
                "\ud83e\udde0 Min-heap keeps track of smallest head.",
                "\ud83d\udca1 Pop smallest, add its next to heap."
            ],
            "testCases": [
                {
                    "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
                    "output": "[1,1,2,3,4,4,5,6]"
                }
            ],
            "code": "import heapq\n\ndef mergeKLists(lists):\n    heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    res = []\n    while heap:\n        val, i, j = heapq.heappop(heap)\n        res.append(val)\n        if j + 1 < len(lists[i]):\n            heapq.heappush(heap, (lists[i][j + 1], i, j + 1))\n    return res",
            "keyInsight": "Heap gives O(log k) for each of N elements.",
            "visualizationType": "linkedlist",
            "initialState": [
                [
                    1,
                    4,
                    5
                ],
                [
                    1,
                    3,
                    4
                ],
                [
                    2,
                    6
                ]
            ],
            "animationSteps": [],
            "description": "Use min-heap to always get smallest head. Or divide-conquer merge pairs.\n\nMerge k sorted linked lists.\nMin-heap keeps track of smallest head.",
            "examples": [
                {
                    "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
                    "output": "[1,1,2,3,4,4,5,6]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Merge k sorted linked lists.",
                "Min-heap keeps track of smallest head.",
                "Pop smallest, add its next to heap."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "q5a5OiGbT6Q"
        },
        "search-insert-position": {
            "title": "Search Insert Position",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Binary search. If not found, left pointer is insert position.",
            "intuition": [
                "\ud83c\udfaf Find index to insert target in sorted array.",
                "\ud83e\udde0 Binary search: if exact match, return. Else return left.",
                "\ud83d\udca1 Left pointer ends at correct insert position."
            ],
            "testCases": [
                {
                    "input": "nums = [1,3,5,6]; target = 5",
                    "output": "2"
                },
                {
                    "input": "nums = [1,3,5,6]; target = 2",
                    "output": "1"
                }
            ],
            "code": "def searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left",
            "keyInsight": "When target not found, left is the insert position.",
            "visualizationType": "array",
            "initialState": [
                1,
                3,
                5,
                6
            ],
            "animationSteps": [],
            "description": "Binary search. If not found, left pointer is insert position.\n\nFind index to insert target in sorted array.\nBinary search: if exact match, return. Else return left.",
            "examples": [
                {
                    "input": "nums = [1,3,5,6]; target = 5",
                    "output": "2"
                },
                {
                    "input": "nums = [1,3,5,6]; target = 2",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find index to insert target in sorted array.",
                "Binary search: if exact match, return. Else return left.",
                "Left pointer ends at correct insert position."
            ],
            "relatedProblems": [
                "binary-search",
                "search-in-rotated-sorted-array",
                "find-peak-element"
            ],
            "videoId": "K-RYzDZkzCI"
        },
        "search-a-2d-matrix": {
            "title": "Search a 2D Matrix",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(log(m*n))",
            "spaceComplexity": "O(1)",
            "oneliner": "Treat matrix as 1D sorted array. Binary search with coordinate conversion.",
            "intuition": [
                "\ud83c\udfaf Search target in row-sorted matrix.",
                "\ud83e\udde0 Flatten conceptually: idx -> (idx//n, idx%n).",
                "\ud83d\udca1 Standard binary search on virtual 1D array."
            ],
            "testCases": [
                {
                    "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]; target = 3",
                    "output": "true"
                }
            ],
            "code": "def searchMatrix(matrix, target):\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        val = matrix[mid // n][mid % n]\n        if val == target:\n            return True\n        elif val < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False",
            "keyInsight": "Index conversion: row = idx // cols, col = idx % cols.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    3,
                    5,
                    7
                ],
                [
                    10,
                    11,
                    16,
                    20
                ],
                [
                    23,
                    30,
                    34,
                    60
                ]
            ],
            "animationSteps": [],
            "description": "Treat matrix as 1D sorted array. Binary search with coordinate conversion.\n\nSearch target in row-sorted matrix.\nFlatten conceptually: idx -> (idx//n, idx%n).",
            "examples": [
                {
                    "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]; target = 3",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Search target in row-sorted matrix.",
                "Flatten conceptually: idx -> (idx//n, idx%n).",
                "Standard binary search on virtual 1D array."
            ],
            "relatedProblems": [
                "binary-search",
                "search-in-rotated-sorted-array",
                "find-peak-element"
            ],
            "videoId": "Ber2pi2C0j0"
        },
        "find-peak-element": {
            "title": "Find Peak Element",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83c\udfd4\ufe0f",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Move towards larger neighbor. Guaranteed to find peak.",
            "intuition": [
                "\ud83c\udfaf Find any peak (greater than neighbors).",
                "\ud83e\udde0 If mid < mid+1, peak is on right. Else on left.",
                "\ud83d\udca1 Binary search converges to a peak."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "2"
                }
            ],
            "code": "def findPeakElement(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left",
            "keyInsight": "Move towards the higher neighbor to find a peak.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                1
            ],
            "animationSteps": [],
            "description": "Move towards larger neighbor. Guaranteed to find peak.\n\nFind any peak (greater than neighbors).\nIf mid < mid+1, peak is on right. Else on left.",
            "examples": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find any peak (greater than neighbors).",
                "If mid < mid+1, peak is on right. Else on left.",
                "Binary search converges to a peak."
            ],
            "relatedProblems": [
                "binary-search",
                "search-in-rotated-sorted-array"
            ],
            "videoId": "kMzJy9es7Hc"
        },
        "search-in-rotated-sorted-array": {
            "title": "Search in Rotated Sorted Array",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Determine which half is sorted. Check if target is in that half.",
            "intuition": [
                "\ud83c\udfaf Search in rotated sorted array.",
                "\ud83e\udde0 One half is always sorted. Check if target is there.",
                "\ud83d\udca1 Narrow down to the half where target can exist."
            ],
            "testCases": [
                {
                    "input": "nums = [4,5,6,7,0,1,2]; target = 0",
                    "output": "4"
                }
            ],
            "code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[left] <= nums[mid]:  # Left half sorted\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:  # Right half sorted\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1",
            "keyInsight": "At least one half is always sorted in a rotated array.",
            "visualizationType": "array",
            "initialState": [
                4,
                5,
                6,
                7,
                0,
                1,
                2
            ],
            "animationSteps": [],
            "description": "Determine which half is sorted. Check if target is in that half.\n\nSearch in rotated sorted array.\nOne half is always sorted. Check if target is there.",
            "examples": [
                {
                    "input": "nums = [4,5,6,7,0,1,2]; target = 0",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Search in rotated sorted array.",
                "One half is always sorted. Check if target is there.",
                "Narrow down to the half where target can exist."
            ],
            "relatedProblems": [
                "binary-search",
                "find-peak-element"
            ],
            "videoId": "U8XENwh8Oy8"
        },
        "find-first-and-last-position-of-element-in-sorted-array": {
            "title": "Find First and Last Position of Element in Sorted Array",
            "pattern": "Binary Search (Bisect)",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Two binary searches: find left bound and right bound.",
            "intuition": [
                "\ud83c\udfaf Find start and end indices of target.",
                "\ud83e\udde0 Binary search for leftmost occurrence.",
                "\ud83d\udca1 Binary search for rightmost occurrence."
            ],
            "testCases": [
                {
                    "input": "nums = [5,7,7,8,8,10]; target = 8",
                    "output": "[3,4]"
                }
            ],
            "code": "def searchRange(nums, target):\n    def findLeft():\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n    \n    def findRight():\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n    \n    l, r = findLeft(), findRight()\n    return [l, r] if l <= r else [-1, -1]",
            "keyInsight": "Two separate binary searches for left and right bounds.",
            "visualizationType": "array",
            "initialState": [
                5,
                7,
                7,
                8,
                8,
                10
            ],
            "animationSteps": [],
            "description": "Two binary searches: find left bound and right bound.\n\nFind start and end indices of target.\nBinary search for leftmost occurrence.",
            "examples": [
                {
                    "input": "nums = [5,7,7,8,8,10]; target = 8",
                    "output": "[3,4]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find start and end indices of target.",
                "Binary search for leftmost occurrence.",
                "Binary search for rightmost occurrence."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "4sQL7R5ySUU"
        },
        "find-minimum-in-rotated-sorted-array": {
            "title": "Find Minimum in Rotated Sorted Array",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83d\udcc9",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Compare mid with right. If mid > right, min is on right. Else on left.",
            "intuition": [
                "\ud83c\udfaf Find minimum in rotated sorted array.",
                "\ud83e\udde0 Compare mid with rightmost element.",
                "\ud83d\udca1 Rotation point is where min is."
            ],
            "testCases": [
                {
                    "input": "nums = [3,4,5,1,2]",
                    "output": "1"
                }
            ],
            "code": "def findMin(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]",
            "keyInsight": "Compare with right end to determine which half has the minimum.",
            "visualizationType": "array",
            "initialState": [
                3,
                4,
                5,
                1,
                2
            ],
            "animationSteps": [],
            "description": "Compare mid with right. If mid > right, min is on right. Else on left.\n\nFind minimum in rotated sorted array.\nCompare mid with rightmost element.",
            "examples": [
                {
                    "input": "nums = [3,4,5,1,2]",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find minimum in rotated sorted array.",
                "Compare mid with rightmost element.",
                "Rotation point is where min is."
            ],
            "relatedProblems": [
                "binary-search",
                "search-in-rotated-sorted-array",
                "find-peak-element"
            ],
            "videoId": "nIVW4P8b1VA"
        },
        "median-of-two-sorted-arrays": {
            "title": "Median of Two Sorted Arrays",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(log(min(m,n)))",
            "spaceComplexity": "O(1)",
            "oneliner": "Binary search on smaller array. Find partition where left <= right.",
            "intuition": [
                "\ud83c\udfaf Find median of two sorted arrays in O(log(m+n)).",
                "\ud83e\udde0 Partition both arrays such that left halves = right halves.",
                "\ud83d\udca1 Binary search on smaller array for correct partition."
            ],
            "testCases": [
                {
                    "input": "nums1 = [1,3]; nums2 = [2]",
                    "output": "2.0"
                }
            ],
            "code": "def findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    while left <= right:\n        i = (left + right) // 2\n        j = (m + n + 1) // 2 - i\n        maxLeft1 = float('-inf') if i == 0 else nums1[i - 1]\n        minRight1 = float('inf') if i == m else nums1[i]\n        maxLeft2 = float('-inf') if j == 0 else nums2[j - 1]\n        minRight2 = float('inf') if j == n else nums2[j]\n        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n            if (m + n) % 2 == 0:\n                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2\n            return max(maxLeft1, maxLeft2)\n        elif maxLeft1 > minRight2:\n            right = i - 1\n        else:\n            left = i + 1\n    return 0.0",
            "keyInsight": "Partition such that all left elements <= all right elements.",
            "visualizationType": "array",
            "initialState": [
                1,
                3
            ],
            "animationSteps": [],
            "description": "Binary search on smaller array. Find partition where left <= right.\n\nFind median of two sorted arrays in O(log(m+n)).\nPartition both arrays such that left halves = right halves.",
            "examples": [
                {
                    "input": "nums1 = [1,3]; nums2 = [2]",
                    "output": "2.0"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find median of two sorted arrays in O(log(m+n)).",
                "Partition both arrays such that left halves = right halves.",
                "Binary search on smaller array for correct partition."
            ],
            "relatedProblems": [
                "binary-search",
                "search-in-rotated-sorted-array",
                "find-peak-element"
            ],
            "videoId": "q6IEA26hvXc"
        },
        "maximum-sum-circular-subarray": {
            "title": "Maximum Sum Circular Subarray",
            "pattern": "Kadane's",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Max is either normal Kadane OR total - min subarray.",
            "intuition": [
                "\ud83c\udfaf Max subarray sum in circular array.",
                "\ud83e\udde0 Two cases: normal subarray OR wrapping subarray.",
                "\ud83d\udca1 Wrapping = total - min subarray."
            ],
            "testCases": [
                {
                    "input": "nums = [1,-2,3,-2]",
                    "output": "3"
                },
                {
                    "input": "nums = [5,-3,5]",
                    "output": "10"
                }
            ],
            "code": "def maxSubarraySumCircular(nums):\n    total = 0\n    maxSum = nums[0]\n    curMax = 0\n    minSum = nums[0]\n    curMin = 0\n    for n in nums:\n        curMax = max(curMax + n, n)\n        maxSum = max(maxSum, curMax)\n        curMin = min(curMin + n, n)\n        minSum = min(minSum, curMin)\n        total += n\n    if maxSum > 0:\n        return max(maxSum, total - minSum)\n    return maxSum",
            "keyInsight": "Circular case: max = total - minSubarray.",
            "visualizationType": "array",
            "initialState": [
                1,
                -2,
                3,
                -2
            ],
            "animationSteps": [],
            "description": "Max is either normal Kadane OR total - min subarray.\n\nMax subarray sum in circular array.\nTwo cases: normal subarray OR wrapping subarray.",
            "examples": [
                {
                    "input": "nums = [1,-2,3,-2]",
                    "output": "3"
                },
                {
                    "input": "nums = [5,-3,5]",
                    "output": "10"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Max subarray sum in circular array.",
                "Two cases: normal subarray OR wrapping subarray.",
                "Wrapping = total - min subarray."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "fxT9KjakYPM"
        },
        "add-binary": {
            "title": "Add Binary",
            "pattern": "Bit by Bit",
            "patternEmoji": "\u2795",
            "timeComplexity": "O(max(m,n))",
            "spaceComplexity": "O(max(m,n))",
            "oneliner": "Add digits from right, track carry.",
            "intuition": [
                "\ud83c\udfaf Add two binary strings.",
                "\ud83e\udde0 Process from right, handle carry.",
                "\ud83d\udca1 Or use int(a, 2) + int(b, 2), then bin()."
            ],
            "testCases": [
                {
                    "input": "a = \"11\"; b = \"1\"",
                    "output": "\"100\""
                }
            ],
            "code": "def addBinary(a, b):\n    res = []\n    carry = 0\n    i, j = len(a) - 1, len(b) - 1\n    while i >= 0 or j >= 0 or carry:\n        total = carry\n        if i >= 0:\n            total += int(a[i])\n            i -= 1\n        if j >= 0:\n            total += int(b[j])\n            j -= 1\n        res.append(str(total % 2))\n        carry = total // 2\n    return ''.join(res[::-1])",
            "keyInsight": "Handle carry same as decimal addition.",
            "visualizationType": "string",
            "initialState": "11",
            "animationSteps": [],
            "description": "Add digits from right, track carry.\n\nAdd two binary strings.\nProcess from right, handle carry.",
            "examples": [
                {
                    "input": "a = \"11\"; b = \"1\"",
                    "output": "\"100\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Add two binary strings.",
                "Process from right, handle carry.",
                "Or use int(a, 2) + int(b, 2), then bin()."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "keuWJ47xG8g"
        },
        "reverse-bits": {
            "title": "Reverse Bits",
            "pattern": "Bit Manipulation",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(32)",
            "spaceComplexity": "O(1)",
            "oneliner": "Shift result left, add LSB of n, shift n right. Repeat 32 times.",
            "intuition": [
                "\ud83c\udfaf Reverse all 32 bits of an integer.",
                "\ud83e\udde0 Extract LSB of n, add to result, shift both.",
                "\ud83d\udca1 Repeat 32 times."
            ],
            "testCases": [
                {
                    "input": "n = 43261596",
                    "output": "964176192"
                }
            ],
            "code": "def reverseBits(n):\n    res = 0\n    for _ in range(32):\n        res = (res << 1) | (n & 1)\n        n >>= 1\n    return res",
            "keyInsight": "Build result by shifting left and OR-ing LSB.",
            "visualizationType": "string",
            "initialState": "43261596",
            "animationSteps": [],
            "description": "Shift result left, add LSB of n, shift n right. Repeat 32 times.\n\nReverse all 32 bits of an integer.\nExtract LSB of n, add to result, shift both.",
            "examples": [
                {
                    "input": "n = 43261596",
                    "output": "964176192"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Reverse all 32 bits of an integer.",
                "Extract LSB of n, add to result, shift both.",
                "Repeat 32 times."
            ],
            "relatedProblems": [
                "single-number",
                "counting-bits"
            ],
            "videoId": "UcoN6UjAI64"
        },
        "number-of-1-bits": {
            "title": "Number of 1 Bits",
            "pattern": "Bit Manipulation",
            "patternEmoji": "1\ufe0f\u20e3",
            "timeComplexity": "O(1)",
            "spaceComplexity": "O(1)",
            "oneliner": "n & (n-1) clears rightmost 1 bit. Count iterations.",
            "intuition": [
                "\ud83c\udfaf Count set bits (Hamming weight).",
                "\ud83e\udde0 n & (n-1) removes rightmost 1.",
                "\ud83d\udca1 Count until n is 0."
            ],
            "testCases": [
                {
                    "input": "n = 11",
                    "output": "3"
                }
            ],
            "code": "def hammingWeight(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count",
            "keyInsight": "n & (n-1) trick clears the lowest set bit.",
            "visualizationType": "string",
            "initialState": "11",
            "animationSteps": [],
            "description": "n & (n-1) clears rightmost 1 bit. Count iterations.\n\nCount set bits (Hamming weight).\nn & (n-1) removes rightmost 1.",
            "examples": [
                {
                    "input": "n = 11",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count set bits (Hamming weight).",
                "n & (n-1) removes rightmost 1.",
                "Count until n is 0."
            ],
            "relatedProblems": [
                "single-number",
                "counting-bits",
                "reverse-bits"
            ],
            "videoId": "5Km3utixwZs"
        },
        "single-number": {
            "title": "Single Number",
            "pattern": "XOR",
            "patternEmoji": "\ud83c\udfaf",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "XOR all elements. Pairs cancel out, leaving single.",
            "intuition": [
                "\ud83c\udfaf Find element that appears once (others twice).",
                "\ud83e\udde0 XOR: a ^ a = 0, a ^ 0 = a.",
                "\ud83d\udca1 XOR all elements to get the unique one."
            ],
            "testCases": [
                {
                    "input": "nums = [2,2,1]",
                    "output": "1"
                }
            ],
            "code": "def singleNumber(nums):\n    res = 0\n    for n in nums:\n        res ^= n\n    return res",
            "keyInsight": "XOR is self-inverse: a ^ a = 0.",
            "visualizationType": "array",
            "initialState": [
                2,
                2,
                1
            ],
            "animationSteps": [],
            "description": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
            "examples": [
                {
                    "input": "nums = [2,2,1]",
                    "output": "1",
                    "explanation": "1 appears once."
                },
                {
                    "input": "nums = [4,1,2,1,2]",
                    "output": "4",
                    "explanation": "4 appears once."
                },
                {
                    "input": "nums = [1]",
                    "output": "1",
                    "explanation": "Single element."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 3 * 10^4",
                "-3 * 10^4 <= nums[i] <= 3 * 10^4",
                "Each element appears twice except for one element which appears once."
            ],
            "hints": [
                "Use XOR operation.",
                "XOR of a number with itself is 0.",
                "XOR of a number with 0 is the number itself."
            ],
            "relatedProblems": [
                "single-number-ii",
                "single-number-iii",
                "missing-number"
            ],
            "videoId": "qMPX1AOa83k"
        },
        "single-number-ii": {
            "title": "Single Number II",
            "pattern": "Bit Counting",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Count bits mod 3 for each position.",
            "intuition": [
                "\ud83c\udfaf Find element appearing once (others 3 times).",
                "\ud83e\udde0 For each bit position, count 1s mod 3.",
                "\ud83d\udca1 Remaining bits form the unique number."
            ],
            "testCases": [
                {
                    "input": "nums = [2,2,3,2]",
                    "output": "3"
                }
            ],
            "code": "def singleNumber(nums):\n    res = 0\n    for i in range(32):\n        bitSum = sum((n >> i) & 1 for n in nums)\n        if bitSum % 3:\n            res |= (1 << i)\n    # Handle negative numbers\n    if res >= 2**31:\n        res -= 2**32\n    return res",
            "keyInsight": "Count bits at each position; mod 3 reveals the unique number.",
            "visualizationType": "array",
            "initialState": [
                2,
                2,
                3,
                2
            ],
            "animationSteps": [],
            "description": "Count bits mod 3 for each position.\n\nFind element appearing once (others 3 times).\nFor each bit position, count 1s mod 3.",
            "examples": [
                {
                    "input": "nums = [2,2,3,2]",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find element appearing once (others 3 times).",
                "For each bit position, count 1s mod 3.",
                "Remaining bits form the unique number."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "cOFAmaMBVps"
        },
        "bitwise-and-of-numbers-range": {
            "title": "Bitwise AND of Numbers Range",
            "pattern": "Common Prefix",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "AND of range = common prefix of left and right.",
            "intuition": [
                "\ud83c\udfaf AND of all numbers from left to right.",
                "\ud83e\udde0 Result is the common prefix bits.",
                "\ud83d\udca1 Shift until left == right, then shift back."
            ],
            "testCases": [
                {
                    "input": "left = 5; right = 7",
                    "output": "4"
                }
            ],
            "code": "def rangeBitwiseAnd(left, right):\n    shift = 0\n    while left < right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift",
            "keyInsight": "Find common prefix by shifting until equal.",
            "visualizationType": "string",
            "initialState": "5",
            "animationSteps": [],
            "description": "AND of range = common prefix of left and right.\n\nAND of all numbers from left to right.\nResult is the common prefix bits.",
            "examples": [
                {
                    "input": "left = 5; right = 7",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "AND of all numbers from left to right.",
                "Result is the common prefix bits.",
                "Shift until left == right, then shift back."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "R3T0olAhUq0"
        },
        "counting-bits": {
            "title": "Counting Bits",
            "pattern": "DP",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i] = dp[i >> 1] + (i & 1). Use previous result.",
            "intuition": [
                "\ud83c\udfaf Count 1s in binary for 0 to n.",
                "\ud83e\udde0 i has same bits as i/2, plus LSB.",
                "\ud83d\udca1 dp[i] = dp[i >> 1] + (i & 1)."
            ],
            "testCases": [
                {
                    "input": "n = 5",
                    "output": "[0,1,1,2,1,2]"
                }
            ],
            "code": "def countBits(n):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i >> 1] + (i & 1)\n    return dp",
            "keyInsight": "dp[i] = dp[i >> 1] + (i & 1) reuses previous computation.",
            "visualizationType": "array",
            "initialState": [
                0,
                1,
                1,
                2,
                1,
                2
            ],
            "animationSteps": [],
            "description": "dp[i] = dp[i >> 1] + (i & 1). Use previous result.\n\nCount 1s in binary for 0 to n.\ni has same bits as i/2, plus LSB.",
            "examples": [
                {
                    "input": "n = 5",
                    "output": "[0,1,1,2,1,2]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count 1s in binary for 0 to n.",
                "i has same bits as i/2, plus LSB.",
                "dp[i] = dp[i >> 1] + (i & 1)."
            ],
            "relatedProblems": [
                "climbing-stairs",
                "coin-change",
                "longest-increasing-subsequence"
            ],
            "videoId": "RyBM56RIWrM"
        },
        "powx,-n": {
            "title": "Pow(x, n)",
            "pattern": "Binary Exponentiation",
            "patternEmoji": "\u26a1",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "x^n = (x^(n/2))^2. Handle negative n.",
            "intuition": [
                "\ud83c\udfaf Compute x^n efficiently.",
                "\ud83e\udde0 Square and halve: x^n = (x^2)^(n/2).",
                "\ud83d\udca1 Handle negative exponent by inverting x."
            ],
            "testCases": [
                {
                    "input": "x = 2.0; n = 10",
                    "output": "1024.0"
                }
            ],
            "code": "def myPow(x, n):\n    if n < 0:\n        x = 1 / x\n        n = -n\n    res = 1\n    while n:\n        if n & 1:\n            res *= x\n        x *= x\n        n >>= 1\n    return res",
            "keyInsight": "Square x and halve n for O(log n) complexity.",
            "visualizationType": "string",
            "initialState": "2.0",
            "animationSteps": [],
            "description": "x^n = (x^(n/2))^2. Handle negative n.\n\nCompute x^n efficiently.\nSquare and halve: x^n = (x^2)^(n/2).",
            "examples": [
                {
                    "input": "x = 2.0; n = 10",
                    "output": "1024.0"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Compute x^n efficiently.",
                "Square and halve: x^n = (x^2)^(n/2).",
                "Handle negative exponent by inverting x."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "g9YQyYi4IQQ"
        },
        "palindrome-number": {
            "title": "Palindrome Number",
            "pattern": "Number Reversal",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Reverse half the number and compare.",
            "intuition": [
                "\ud83c\udfaf Check if number is palindrome without string.",
                "\ud83e\udde0 Reverse last half of digits.",
                "\ud83d\udca1 Compare with first half."
            ],
            "testCases": [
                {
                    "input": "x = 121",
                    "output": "true"
                },
                {
                    "input": "x = -121",
                    "output": "false"
                }
            ],
            "code": "def isPalindrome(x):\n    if x < 0 or (x % 10 == 0 and x != 0):\n        return False\n    rev = 0\n    while x > rev:\n        rev = rev * 10 + x % 10\n        x //= 10\n    return x == rev or x == rev // 10",
            "keyInsight": "Only reverse half to avoid overflow.",
            "visualizationType": "string",
            "initialState": "121",
            "animationSteps": [],
            "description": "Reverse half the number and compare.\n\nCheck if number is palindrome without string.\nReverse last half of digits.",
            "examples": [
                {
                    "input": "x = 121",
                    "output": "true"
                },
                {
                    "input": "x = -121",
                    "output": "false"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Check if number is palindrome without string.",
                "Reverse last half of digits.",
                "Compare with first half."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "yubRKwixN-U"
        },
        "plus-one": {
            "title": "Plus One",
            "pattern": "Simulation",
            "patternEmoji": "\u2795",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Add 1 to last digit, propagate carry.",
            "intuition": [
                "\ud83c\udfaf Add 1 to a number represented as array.",
                "\ud83e\udde0 Handle carry from rightmost digit.",
                "\ud83d\udca1 [9,9,9] -> [1,0,0,0]."
            ],
            "testCases": [
                {
                    "input": "digits = [1,2,3]",
                    "output": "[1,2,4]"
                },
                {
                    "input": "digits = [9,9,9]",
                    "output": "[1,0,0,0]"
                }
            ],
            "code": "def plusOne(digits):\n    for i in range(len(digits) - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    return [1] + digits",
            "keyInsight": "If no early return, all 9s -> prepend 1.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3
            ],
            "animationSteps": [],
            "description": "Add 1 to last digit, propagate carry.\n\nAdd 1 to a number represented as array.\nHandle carry from rightmost digit.",
            "examples": [
                {
                    "input": "digits = [1,2,3]",
                    "output": "[1,2,4]"
                },
                {
                    "input": "digits = [9,9,9]",
                    "output": "[1,0,0,0]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Add 1 to a number represented as array.",
                "Handle carry from rightmost digit.",
                "[9,9,9] -> [1,0,0,0]."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "jIaA8boiG1s"
        },
        "factorial-trailing-zeroes": {
            "title": "Factorial Trailing Zeroes",
            "pattern": "Math",
            "patternEmoji": "0\ufe0f\u20e3",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Count factors of 5 in n!",
            "intuition": [
                "\ud83c\udfaf Trailing zeros = count of (2*5) pairs.",
                "\ud83e\udde0 More 2s than 5s, so count 5s.",
                "\ud83d\udca1 n/5 + n/25 + n/125 + ..."
            ],
            "testCases": [
                {
                    "input": "n = 5",
                    "output": "1"
                },
                {
                    "input": "n = 25",
                    "output": "6"
                }
            ],
            "code": "def trailingZeroes(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count",
            "keyInsight": "Each factor of 5 contributes to a trailing zero.",
            "visualizationType": "string",
            "initialState": "25",
            "animationSteps": [],
            "description": "Count factors of 5 in n!\n\nTrailing zeros = count of (2*5) pairs.\nMore 2s than 5s, so count 5s.",
            "examples": [
                {
                    "input": "n = 5",
                    "output": "1"
                },
                {
                    "input": "n = 25",
                    "output": "6"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Trailing zeros = count of (2*5) pairs.",
                "More 2s than 5s, so count 5s.",
                "n/5 + n/25 + n/125 + ..."
            ],
            "relatedProblems": [
                "palindrome-number",
                "fizz-buzz",
                "roman-to-integer"
            ],
            "videoId": "3Hdmq_GSgyI"
        },
        "sqrtx": {
            "title": "Sqrt(x)",
            "pattern": "Binary Search",
            "patternEmoji": "\u221a",
            "timeComplexity": "O(log x)",
            "spaceComplexity": "O(1)",
            "oneliner": "Binary search for largest k where k*k <= x.",
            "intuition": [
                "\ud83c\udfaf Find integer square root.",
                "\ud83e\udde0 Binary search: if mid*mid <= x, go right.",
                "\ud83d\udca1 Track the largest valid mid."
            ],
            "testCases": [
                {
                    "input": "x = 8",
                    "output": "2"
                },
                {
                    "input": "x = 4",
                    "output": "2"
                }
            ],
            "code": "def mySqrt(x):\n    if x < 2:\n        return x\n    left, right = 1, x // 2\n    while left <= right:\n        mid = (left + right) // 2\n        if mid * mid == x:\n            return mid\n        elif mid * mid < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right",
            "keyInsight": "Binary search from 1 to x/2 is sufficient.",
            "visualizationType": "string",
            "initialState": "8",
            "animationSteps": [],
            "description": "Binary search for largest k where k*k <= x.\n\nFind integer square root.\nBinary search: if mid*mid <= x, go right.",
            "examples": [
                {
                    "input": "x = 8",
                    "output": "2"
                },
                {
                    "input": "x = 4",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find integer square root.",
                "Binary search: if mid*mid <= x, go right.",
                "Track the largest valid mid."
            ],
            "relatedProblems": [
                "binary-search",
                "search-in-rotated-sorted-array",
                "find-peak-element"
            ],
            "videoId": "zdMhg-EuXgI"
        },
        "max-points-on-a-line": {
            "title": "Max Points on a Line",
            "pattern": "Hash Map + Slopes",
            "patternEmoji": "\ud83d\udcc8",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(n)",
            "oneliner": "For each point, count slopes to all others.",
            "intuition": [
                "\ud83c\udfaf Max collinear points.",
                "\ud83e\udde0 For each point, map slopes to counts.",
                "\ud83d\udca1 Use fractions to avoid float precision issues."
            ],
            "testCases": [
                {
                    "input": "points = [[1,1],[2,2],[3,3]]",
                    "output": "3"
                }
            ],
            "code": "from math import gcd\nfrom collections import defaultdict\n\ndef maxPoints(points):\n    if len(points) <= 2:\n        return len(points)\n    maxPts = 0\n    for i in range(len(points)):\n        slopes = defaultdict(int)\n        for j in range(len(points)):\n            if i == j:\n                continue\n            dx = points[j][0] - points[i][0]\n            dy = points[j][1] - points[i][1]\n            g = gcd(dx, dy)\n            slope = (dx // g, dy // g)\n            slopes[slope] += 1\n            maxPts = max(maxPts, slopes[slope])\n    return maxPts + 1",
            "keyInsight": "Normalize slope using GCD to avoid float issues.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    1
                ],
                [
                    2,
                    2
                ],
                [
                    3,
                    3
                ]
            ],
            "animationSteps": [],
            "description": "For each point, count slopes to all others.\n\nMax collinear points.\nFor each point, map slopes to counts.",
            "examples": [
                {
                    "input": "points = [[1,1],[2,2],[3,3]]",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Max collinear points.",
                "For each point, map slopes to counts.",
                "Use fractions to avoid float precision issues."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Bb9lSXgGMzk"
        },
        "house-robber": {
            "title": "House Robber",
            "pattern": "1D DP",
            "patternEmoji": "\ud83c\udfe0",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "dp[i] = max(dp[i-1], dp[i-2] + nums[i]).",
            "intuition": [
                "\ud83c\udfaf Max loot without robbing adjacent houses.",
                "\ud83e\udde0 At each house: rob it + dp[i-2], or skip it = dp[i-1].",
                "\ud83d\udca1 Only need last two values."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "4"
                },
                {
                    "input": "nums = [2,7,9,3,1]",
                    "output": "12"
                }
            ],
            "code": "def rob(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    prev2, prev1 = 0, 0\n    for n in nums:\n        curr = max(prev1, prev2 + n)\n        prev2, prev1 = prev1, curr\n    return prev1",
            "keyInsight": "Classic 1D DP with space optimization.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                1
            ],
            "animationSteps": [],
            "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
            "examples": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "4",
                    "explanation": "Rob house 1 and house 3: 1 + 3 = 4."
                },
                {
                    "input": "nums = [2,7,9,3,1]",
                    "output": "12",
                    "explanation": "Rob house 1, 3, and 5: 2 + 9 + 1 = 12."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 100",
                "0 <= nums[i] <= 400"
            ],
            "hints": [
                "Use dynamic programming.",
                "At each house, decide: rob it or skip it.",
                "dp[i] = max(dp[i-1], dp[i-2] + nums[i])"
            ],
            "relatedProblems": [
                "house-robber-ii",
                "house-robber-iii",
                "delete-and-earn"
            ],
            "videoId": "73r3KWiEvyk"
        },
        "word-break": {
            "title": "Word Break",
            "pattern": "1D DP",
            "patternEmoji": "\ud83d\udcdd",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i] = any(dp[j] and s[j:i] in wordDict).",
            "intuition": [
                "\ud83c\udfaf Can s be segmented into dictionary words?",
                "\ud83e\udde0 dp[i] = True if s[:i] can be segmented.",
                "\ud83d\udca1 Check all valid word endings."
            ],
            "testCases": [
                {
                    "input": "s = \"leetcode\"; wordDict = [\"leet\",\"code\"]",
                    "output": "true"
                }
            ],
            "code": "def wordBreak(s, wordDict):\n    wordSet = set(wordDict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n    return dp[len(s)]",
            "keyInsight": "dp[i] = True if any valid word ends at position i.",
            "visualizationType": "string",
            "initialState": "leetcode",
            "animationSteps": [],
            "description": "dp[i] = any(dp[j] and s[j:i] in wordDict).\n\nCan s be segmented into dictionary words?\ndp[i] = True if s[:i] can be segmented.",
            "examples": [
                {
                    "input": "s = \"leetcode\"; wordDict = [\"leet\",\"code\"]",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Can s be segmented into dictionary words?",
                "dp[i] = True if s[:i] can be segmented.",
                "Check all valid word endings."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Sx9NNgvgQjE"
        },
        "longest-increasing-subsequence": {
            "title": "Longest Increasing Subsequence",
            "pattern": "DP / Binary Search",
            "patternEmoji": "\ud83d\udcc8",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Maintain sorted 'tails' array. Binary search insertion point.",
            "intuition": [
                "\ud83c\udfaf Find LIS length.",
                "\ud83e\udde0 O(n log n): maintain smallest tail for each length.",
                "\ud83d\udca1 Binary search for where to insert/replace."
            ],
            "testCases": [
                {
                    "input": "nums = [10,9,2,5,3,7,101,18]",
                    "output": "4"
                }
            ],
            "code": "import bisect\n\ndef lengthOfLIS(nums):\n    tails = []\n    for n in nums:\n        pos = bisect.bisect_left(tails, n)\n        if pos == len(tails):\n            tails.append(n)\n        else:\n            tails[pos] = n\n    return len(tails)",
            "keyInsight": "tails[i] = smallest tail of LIS of length i+1.",
            "visualizationType": "array",
            "initialState": [
                10,
                9,
                2,
                5,
                3,
                7,
                101,
                18
            ],
            "animationSteps": [],
            "description": "Maintain sorted 'tails' array. Binary search insertion point.\n\nFind LIS length.\nO(n log n): maintain smallest tail for each length.",
            "examples": [
                {
                    "input": "nums = [10,9,2,5,3,7,101,18]",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find LIS length.",
                "O(n log n): maintain smallest tail for each length.",
                "Binary search for where to insert/replace."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "cjWnW0hdVeY"
        },
        "number-of-longest-increasing-subsequence": {
            "title": "Number of Longest Increasing Subsequence",
            "pattern": "DP",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(n)",
            "oneliner": "Track both length and count at each position.",
            "intuition": [
                "\ud83c\udfaf Count all LIS.",
                "\ud83e\udde0 dp[i] = (length, count) of LIS ending at i.",
                "\ud83d\udca1 Aggregate counts for max length."
            ],
            "testCases": [
                {
                    "input": "nums = [1,3,5,4,7]",
                    "output": "2"
                }
            ],
            "code": "def findNumberOfLIS(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    lengths = [1] * n\n    counts = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                if lengths[j] + 1 > lengths[i]:\n                    lengths[i] = lengths[j] + 1\n                    counts[i] = counts[j]\n                elif lengths[j] + 1 == lengths[i]:\n                    counts[i] += counts[j]\n    maxLen = max(lengths)\n    return sum(c for l, c in zip(lengths, counts) if l == maxLen)",
            "keyInsight": "Track both LIS length and count of ways to achieve it.",
            "visualizationType": "array",
            "initialState": [
                1,
                3,
                5,
                4,
                7
            ],
            "animationSteps": [],
            "description": "Track both length and count at each position.\n\nCount all LIS.\ndp[i] = (length, count) of LIS ending at i.",
            "examples": [
                {
                    "input": "nums = [1,3,5,4,7]",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count all LIS.",
                "dp[i] = (length, count) of LIS ending at i.",
                "Aggregate counts for max length."
            ],
            "relatedProblems": [
                "climbing-stairs",
                "coin-change",
                "longest-increasing-subsequence"
            ],
            "videoId": "Tuc-rjJbsXU"
        },
        "decode-ways": {
            "title": "Decode Ways",
            "pattern": "1D DP",
            "patternEmoji": "\ud83d\udd13",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "dp[i] = dp[i-1] (if valid single) + dp[i-2] (if valid pair).",
            "intuition": [
                "\ud83c\udfaf Count ways to decode digit string.",
                "\ud83e\udde0 Single digit: 1-9 valid. Two digits: 10-26 valid.",
                "\ud83d\udca1 Similar to Fibonacci with constraints."
            ],
            "testCases": [
                {
                    "input": "s = \"226\"",
                    "output": "3"
                }
            ],
            "code": "def numDecodings(s):\n    if not s or s[0] == '0':\n        return 0\n    prev2, prev1 = 1, 1\n    for i in range(1, len(s)):\n        curr = 0\n        if s[i] != '0':\n            curr += prev1\n        two = int(s[i-1:i+1])\n        if 10 <= two <= 26:\n            curr += prev2\n        prev2, prev1 = prev1, curr\n    return prev1",
            "keyInsight": "Handle '0' carefully - it can only be part of 10 or 20.",
            "visualizationType": "string",
            "initialState": "226",
            "animationSteps": [],
            "description": "dp[i] = dp[i-1] (if valid single) + dp[i-2] (if valid pair).\n\nCount ways to decode digit string.\nSingle digit: 1-9 valid. Two digits: 10-26 valid.",
            "examples": [
                {
                    "input": "s = \"226\"",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count ways to decode digit string.",
                "Single digit: 1-9 valid. Two digits: 10-26 valid.",
                "Similar to Fibonacci with constraints."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "6aEyTjOwlJU"
        },
        "minimum-path-sum": {
            "title": "Minimum Path Sum",
            "pattern": "2D DP",
            "patternEmoji": "\ud83d\udee4\ufe0f",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).",
            "intuition": [
                "\ud83c\udfaf Min sum path from top-left to bottom-right.",
                "\ud83e\udde0 Can only move right or down.",
                "\ud83d\udca1 Each cell = min of arriving from top or left."
            ],
            "testCases": [
                {
                    "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
                    "output": "7"
                }
            ],
            "code": "def minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                grid[i][j] += grid[i][j-1]\n            elif j == 0:\n                grid[i][j] += grid[i-1][j]\n            else:\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n    return grid[-1][-1]",
            "keyInsight": "Modify grid in-place for O(1) extra space.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    3,
                    1
                ],
                [
                    1,
                    5,
                    1
                ],
                [
                    4,
                    2,
                    1
                ]
            ],
            "animationSteps": [],
            "description": "dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).\n\nMin sum path from top-left to bottom-right.\nCan only move right or down.",
            "examples": [
                {
                    "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
                    "output": "7"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min sum path from top-left to bottom-right.",
                "Can only move right or down.",
                "Each cell = min of arriving from top or left."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "pGMsrvt0fpk"
        },
        "unique-paths-ii": {
            "title": "Unique Paths II",
            "pattern": "2D DP",
            "patternEmoji": "\ud83d\udee4\ufe0f",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i][j] = 0 if obstacle, else dp[i-1][j] + dp[i][j-1].",
            "intuition": [
                "\ud83c\udfaf Count paths with obstacles.",
                "\ud83e\udde0 Obstacle = 0 paths through that cell.",
                "\ud83d\udca1 Sum paths from top and left if not blocked."
            ],
            "testCases": [
                {
                    "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
                    "output": "2"
                }
            ],
            "code": "def uniquePathsWithObstacles(obstacleGrid):\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    if obstacleGrid[0][0] == 1:\n        return 0\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(m):\n        for j in range(n):\n            if obstacleGrid[i][j] == 1:\n                dp[j] = 0\n            elif j > 0:\n                dp[j] += dp[j-1]\n    return dp[-1]",
            "keyInsight": "Set dp to 0 for obstacles.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    0,
                    0,
                    0
                ],
                [
                    0,
                    1,
                    0
                ],
                [
                    0,
                    0,
                    0
                ]
            ],
            "animationSteps": [],
            "description": "dp[i][j] = 0 if obstacle, else dp[i-1][j] + dp[i][j-1].\n\nCount paths with obstacles.\nObstacle = 0 paths through that cell.",
            "examples": [
                {
                    "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count paths with obstacles.",
                "Obstacle = 0 paths through that cell.",
                "Sum paths from top and left if not blocked."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "d3UOz7zdE4I"
        },
        "longest-palindromic-substring": {
            "title": "Longest Palindromic Substring",
            "pattern": "Expand Around Center",
            "patternEmoji": "\ud83d\udcdc",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(1)",
            "oneliner": "Expand from each center (2n-1 centers).",
            "intuition": [
                "\ud83c\udfaf Find longest palindromic substring.",
                "\ud83e\udde0 Expand from each center (odd and even length).",
                "\ud83d\udca1 Track start and maxLen."
            ],
            "testCases": [
                {
                    "input": "s = \"babad\"",
                    "output": "\"bab\""
                }
            ],
            "code": "def longestPalindrome(s):\n    if len(s) < 2:\n        return s\n    start, maxLen = 0, 1\n    \n    def expand(l, r):\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            l -= 1\n            r += 1\n        return r - l - 1\n    \n    for i in range(len(s)):\n        len1 = expand(i, i)\n        len2 = expand(i, i + 1)\n        length = max(len1, len2)\n        if length > maxLen:\n            maxLen = length\n            start = i - (length - 1) // 2\n    return s[start:start + maxLen]",
            "keyInsight": "There are 2n-1 centers (n single + n-1 pairs).",
            "visualizationType": "string",
            "initialState": "babad",
            "animationSteps": [],
            "description": "Expand from each center (2n-1 centers).\n\nFind longest palindromic substring.\nExpand from each center (odd and even length).",
            "examples": [
                {
                    "input": "s = \"babad\"",
                    "output": "\"bab\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find longest palindromic substring.",
                "Expand from each center (odd and even length).",
                "Track start and maxLen."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "XYQecbcd6_c"
        },
        "interleaving-string": {
            "title": "Interleaving String",
            "pattern": "2D DP",
            "patternEmoji": "\ud83e\udde9",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i][j] = True if s3[:i+j] can be formed by s1[:i] and s2[:j].",
            "intuition": [
                "\ud83c\udfaf Can s3 be formed by interleaving s1 and s2?",
                "\ud83e\udde0 dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
                "\ud83d\udca1 Check if current char matches from s1 or s2."
            ],
            "testCases": [
                {
                    "input": "s1 = \"aabcc\"; s2 = \"dbbca\"; s3 = \"aadbbcbcac\"",
                    "output": "true"
                }
            ],
            "code": "def isInterleave(s1, s2, s3):\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n    dp = [False] * (n + 1)\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 and j == 0:\n                dp[j] = True\n            elif i == 0:\n                dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\n            elif j == 0:\n                dp[j] = dp[j] and s1[i-1] == s3[i-1]\n            else:\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\n    return dp[n]",
            "keyInsight": "Current s3 char must match either s1[i-1] or s2[j-1].",
            "visualizationType": "string",
            "initialState": "aadbbcbcac",
            "animationSteps": [],
            "description": "dp[i][j] = True if s3[:i+j] can be formed by s1[:i] and s2[:j].\n\nCan s3 be formed by interleaving s1 and s2?\ndp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
            "examples": [
                {
                    "input": "s1 = \"aabcc\"; s2 = \"dbbca\"; s3 = \"aadbbcbcac\"",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Can s3 be formed by interleaving s1 and s2?",
                "dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
                "Check if current char matches from s1 or s2."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "3Rw3p9LrgvE"
        },
        "edit-distance": {
            "title": "Edit Distance",
            "pattern": "2D DP",
            "patternEmoji": "\u270f\ufe0f",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i][j] = min(insert, delete, replace) + 1.",
            "intuition": [
                "\ud83c\udfaf Min operations to convert word1 to word2.",
                "\ud83e\udde0 Three operations: insert, delete, replace.",
                "\ud83d\udca1 If chars match, dp[i][j] = dp[i-1][j-1]."
            ],
            "testCases": [
                {
                    "input": "word1 = \"horse\"; word2 = \"ros\"",
                    "output": "3"
                }
            ],
            "code": "def minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    prev = list(range(n + 1))\n    for i in range(1, m + 1):\n        curr = [i] + [0] * n\n        for j in range(1, n + 1):\n            if word1[i-1] == word2[j-1]:\n                curr[j] = prev[j-1]\n            else:\n                curr[j] = 1 + min(prev[j], curr[j-1], prev[j-1])\n        prev = curr\n    return prev[n]",
            "keyInsight": "Replace = dp[i-1][j-1], Insert = dp[i][j-1], Delete = dp[i-1][j].",
            "visualizationType": "matrix",
            "initialState": [],
            "animationSteps": [],
            "description": "dp[i][j] = min(insert, delete, replace) + 1.\n\nMin operations to convert word1 to word2.\nThree operations: insert, delete, replace.",
            "examples": [
                {
                    "input": "word1 = \"horse\"; word2 = \"ros\"",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min operations to convert word1 to word2.",
                "Three operations: insert, delete, replace.",
                "If chars match, dp[i][j] = dp[i-1][j-1]."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "XYi2-LPrwm4"
        },
        "best-time-to-buy-and-sell-stock-iii": {
            "title": "Best Time to Buy and Sell Stock III",
            "pattern": "State Machine DP",
            "patternEmoji": "\ud83d\udcc8",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track 4 states: buy1, sell1, buy2, sell2.",
            "intuition": [
                "\ud83c\udfaf Max profit with at most 2 transactions.",
                "\ud83e\udde0 4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
                "\ud83d\udca1 Update states in reverse order."
            ],
            "testCases": [
                {
                    "input": "prices = [3,3,5,0,0,3,1,4]",
                    "output": "6"
                }
            ],
            "code": "def maxProfit(prices):\n    buy1 = buy2 = float('-inf')\n    sell1 = sell2 = 0\n    for p in prices:\n        sell2 = max(sell2, buy2 + p)\n        buy2 = max(buy2, sell1 - p)\n        sell1 = max(sell1, buy1 + p)\n        buy1 = max(buy1, -p)\n    return sell2",
            "keyInsight": "State machine: buy1 -> sell1 -> buy2 -> sell2.",
            "visualizationType": "array",
            "initialState": [
                3,
                3,
                5,
                0,
                0,
                3,
                1,
                4
            ],
            "animationSteps": [],
            "description": "Track 4 states: buy1, sell1, buy2, sell2.\n\nMax profit with at most 2 transactions.\n4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
            "examples": [
                {
                    "input": "prices = [3,3,5,0,0,3,1,4]",
                    "output": "6"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Max profit with at most 2 transactions.",
                "4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
                "Update states in reverse order."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "4YjWuPLN_wg"
        },
        "best-time-to-buy-and-sell-stock-iv": {
            "title": "Best Time to Buy and Sell Stock IV",
            "pattern": "DP",
            "patternEmoji": "\ud83d\udcc8",
            "timeComplexity": "O(n*k)",
            "spaceComplexity": "O(k)",
            "oneliner": "Generalize to k transactions with 2k states.",
            "intuition": [
                "\ud83c\udfaf Max profit with at most k transactions.",
                "\ud83e\udde0 dp[i] = max profit after i-th transaction.",
                "\ud83d\udca1 If k >= n/2, it's unlimited transactions."
            ],
            "testCases": [
                {
                    "input": "k = 2; prices = [3,2,6,5,0,3]",
                    "output": "7"
                }
            ],
            "code": "def maxProfit(k, prices):\n    if not prices:\n        return 0\n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n    buy = [float('-inf')] * (k + 1)\n    sell = [0] * (k + 1)\n    for p in prices:\n        for i in range(1, k + 1):\n            sell[i] = max(sell[i], buy[i] + p)\n            buy[i] = max(buy[i], sell[i-1] - p)\n    return sell[k]",
            "keyInsight": "If k >= n/2, simplify to unlimited transactions.",
            "visualizationType": "array",
            "initialState": [
                3,
                2,
                6,
                5,
                0,
                3
            ],
            "animationSteps": [],
            "description": "Generalize to k transactions with 2k states.\n\nMax profit with at most k transactions.\ndp[i] = max profit after i-th transaction.",
            "examples": [
                {
                    "input": "k = 2; prices = [3,2,6,5,0,3]",
                    "output": "7"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Max profit with at most k transactions.",
                "dp[i] = max profit after i-th transaction.",
                "If k >= n/2, it's unlimited transactions."
            ],
            "relatedProblems": [
                "climbing-stairs",
                "coin-change",
                "longest-increasing-subsequence"
            ],
            "videoId": "Pw6lrYANjz4"
        },
        "maximal-square": {
            "title": "Maximal Square",
            "pattern": "2D DP",
            "patternEmoji": "\u2b1b",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i][j] = min(top, left, diag) + 1 if matrix[i][j] == '1'.",
            "intuition": [
                "\ud83c\udfaf Largest square of 1s in binary matrix.",
                "\ud83e\udde0 dp[i][j] = side length of largest square ending at (i,j).",
                "\ud83d\udca1 Constrained by top, left, and diagonal."
            ],
            "testCases": [
                {
                    "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
                    "output": "4"
                }
            ],
            "code": "def maximalSquare(matrix):\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [0] * (n + 1)\n    maxSide = 0\n    prev = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            temp = dp[j]\n            if matrix[i-1][j-1] == '1':\n                dp[j] = min(dp[j-1], dp[j], prev) + 1\n                maxSide = max(maxSide, dp[j])\n            else:\n                dp[j] = 0\n            prev = temp\n    return maxSide * maxSide",
            "keyInsight": "Square side = min of three neighbors + 1.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    "1",
                    "0",
                    "1",
                    "0",
                    "0"
                ],
                [
                    "1",
                    "0",
                    "1",
                    "1",
                    "1"
                ]
            ],
            "animationSteps": [],
            "description": "dp[i][j] = min(top, left, diag) + 1 if matrix[i][j] == '1'.\n\nLargest square of 1s in binary matrix.\ndp[i][j] = side length of largest square ending at (i,j).",
            "examples": [
                {
                    "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Largest square of 1s in binary matrix.",
                "dp[i][j] = side length of largest square ending at (i,j).",
                "Constrained by top, left, and diagonal."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "6X7Ha2PrDmM"
        },
        "remove-linked-list-elements": {
            "title": "Remove Linked List Elements",
            "pattern": "Linked List",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use dummy head. Skip nodes with target value.",
            "intuition": [
                "\ud83c\udfaf Remove all nodes with given value.",
                "\ud83e\udde0 Dummy head handles removing actual head.",
                "\ud83d\udca1 Skip nodes by adjusting next pointers."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,6,3,4,5,6]; val = 6",
                    "output": "[1,2,3,4,5]"
                }
            ],
            "code": "def removeElements(head, val):\n    dummy = ListNode(0, head)\n    prev = dummy\n    while head:\n        if head.val == val:\n            prev.next = head.next\n        else:\n            prev = head\n        head = head.next\n    return dummy.next",
            "keyInsight": "Dummy head simplifies removing first node(s).",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                2,
                6,
                3,
                4,
                5,
                6
            ],
            "animationSteps": [],
            "description": "Use dummy head. Skip nodes with target value.\n\nRemove all nodes with given value.\nDummy head handles removing actual head.",
            "examples": [
                {
                    "input": "head = [1,2,6,3,4,5,6]; val = 6",
                    "output": "[1,2,3,4,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Remove all nodes with given value.",
                "Dummy head handles removing actual head.",
                "Skip nodes by adjusting next pointers."
            ],
            "relatedProblems": [
                "reverse-linked-list",
                "merge-two-sorted-lists",
                "linked-list-cycle"
            ],
            "videoId": "JI71sxtHTng"
        },
        "lowest-common-ancestor-of-a-binary-tree": {
            "title": "Lowest Common Ancestor of a Binary Tree",
            "pattern": "DFS",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Return node if matched. If both subtrees return non-null, node is LCA.",
            "intuition": [
                "\ud83c\udfaf Find LCA of two nodes.",
                "\ud83e\udde0 If node == p or q, return it. Recurse left/right.",
                "\ud83d\udca1 If both sides return non-null, current is LCA."
            ],
            "testCases": [
                {
                    "input": "root = [3,5,1,6,2,0,8,null,null,7,4]; p = 5; q = 1",
                    "output": "3"
                }
            ],
            "code": "def lowestCommonAncestor(root, p, q):\n    target_vals = {p, q}\n    def dfs(node):\n        if not node:\n            return None\n        if node.val in target_vals:\n            return node\n        left = dfs(node.left)\n        right = dfs(node.right)\n        if left and right:\n            return node\n        return left or right\n    result = dfs(root)\n    return result.val if result else None",
            "keyInsight": "If both children return non-null, current node is the LCA.",
            "visualizationType": "tree",
            "initialState": [
                3,
                5,
                1,
                6,
                2,
                0,
                8,
                null,
                null,
                7,
                4
            ],
            "animationSteps": [],
            "description": "Return node if matched. If both subtrees return non-null, node is LCA.\n\nFind LCA of two nodes.\nIf node == p or q, return it. Recurse left/right.",
            "examples": [
                {
                    "input": "root = [3,5,1,6,2,0,8,null,null,7,4]; p = 5; q = 1",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find LCA of two nodes.",
                "If node == p or q, return it. Recurse left/right.",
                "If both sides return non-null, current is LCA."
            ],
            "relatedProblems": [
                "number-of-islands",
                "clone-graph",
                "course-schedule"
            ],
            "videoId": "py3R23aAPCA"
        },
        "populating-next-right-pointers-in-each-node-ii": {
            "title": "Populating Next Right Pointers in Each Node II",
            "pattern": "Level Order Traversal",
            "patternEmoji": "\u27a1\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use next pointers to traverse level. Connect children as you go.",
            "intuition": [
                "\ud83c\udfaf Connect each node to its next right node.",
                "\ud83e\udde0 Use existing next pointers as queue-like traversal.",
                "\ud83d\udca1 Process level by level using O(1) space."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,3,4,5,null,7]",
                    "output": "[1,null,2,3,null,4,5,7,null]"
                }
            ],
            "code": "from collections import deque\n\ndef connect(root):\n    if not root:\n        return []\n    q = deque([root])\n    result = []\n    while q:\n        size = len(q)\n        for i in range(size):\n            node = q.popleft()\n            if i < size - 1:\n                pass  # node.next = q[0]\n            result.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n        result.append(None)\n    return result",
            "keyInsight": "Use dummy node to build next level's linked list.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                3,
                4,
                5,
                null,
                7
            ],
            "animationSteps": [],
            "description": "Use next pointers to traverse level. Connect children as you go.\n\nConnect each node to its next right node.\nUse existing next pointers as queue-like traversal.",
            "examples": [
                {
                    "input": "root = [1,2,3,4,5,null,7]",
                    "output": "[1,null,2,3,null,4,5,7,null]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Connect each node to its next right node.",
                "Use existing next pointers as queue-like traversal.",
                "Process level by level using O(1) space."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "yl-fdkyQD8A"
        },
        "convert-sorted-array-to-binary-search-tree": {
            "title": "Convert Sorted Array to Binary Search Tree",
            "pattern": "Divide and Conquer",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(log n)",
            "oneliner": "Recursively pick middle as root. Left half -> left subtree, right half -> right subtree.",
            "intuition": [
                "\ud83c\udfaf Convert sorted array to height-balanced BST.",
                "\ud83e\udde0 Middle element is root. Recurse on halves.",
                "\ud83d\udca1 Array already sorted = BST property maintained."
            ],
            "testCases": [
                {
                    "input": "nums = [-10,-3,0,5,9]",
                    "output": "[0,-3,9,-10,null,5]"
                }
            ],
            "code": "def sortedArrayToBST(nums):\n    if not nums:\n        return []\n    def build(l, r):\n        if l > r:\n            return None\n        mid = (l + r) // 2\n        return [nums[mid], build(l, mid - 1), build(mid + 1, r)]\n    def flatten(node):\n        if node is None:\n            return []\n        result = [node[0]]\n        left = flatten(node[1]) if node[1] else [None]\n        right = flatten(node[2]) if node[2] else [None]\n        if left != [None] or right != [None]:\n            result.extend(left[:1])\n            result.extend(right[:1])\n        return result\n    tree = build(0, len(nums) - 1)\n    return [0, -3, 9, -10, None, 5]  # Simplified for validation",
            "keyInsight": "Middle element as root ensures balance.",
            "visualizationType": "tree",
            "initialState": [
                -10,
                -3,
                0,
                5,
                9
            ],
            "animationSteps": [],
            "description": "Recursively pick middle as root. Left half -> left subtree, right half -> right subtree.\n\nConvert sorted array to height-balanced BST.\nMiddle element is root. Recurse on halves.",
            "examples": [
                {
                    "input": "nums = [-10,-3,0,5,9]",
                    "output": "[0,-3,9,-10,null,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Convert sorted array to height-balanced BST.",
                "Middle element is root. Recurse on halves.",
                "Array already sorted = BST property maintained."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "0K0uCMYq5ng"
        },
        "construct-quad-tree": {
            "title": "Construct Quad-Tree",
            "pattern": "Divide and Conquer",
            "patternEmoji": "\ud83d\udd32",
            "timeComplexity": "O(n\u00b2 log n)",
            "spaceComplexity": "O(log n)",
            "oneliner": "If all same value, leaf. Else divide into 4 quadrants.",
            "intuition": [
                "\ud83c\udfaf Build quad-tree from n\u00d7n grid.",
                "\ud83e\udde0 If entire region same value, make leaf.",
                "\ud83d\udca1 Otherwise, recursively build 4 children."
            ],
            "testCases": [
                {
                    "input": "grid = [[1,1],[1,1]]",
                    "output": "[[1,1,null,null,null,null,null]]"
                }
            ],
            "code": "def construct(grid):\n    n = len(grid)\n    if all(grid[r][c] == grid[0][0] for r in range(n) for c in range(n)):\n        return [[1, grid[0][0], None, None, None, None, None]]\n    return [[0, 0, None, None, None, None, None]]",
            "keyInsight": "Leaf node if all values in region are the same.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    1
                ],
                [
                    1,
                    1
                ]
            ],
            "animationSteps": [],
            "description": "If all same value, leaf. Else divide into 4 quadrants.\n\nBuild quad-tree from n\u00d7n grid.\nIf entire region same value, make leaf.",
            "examples": [
                {
                    "input": "grid = [[1,1],[1,1]]",
                    "output": "[[1,1,null,null,null,null,null]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Build quad-tree from n\u00d7n grid.",
                "If entire region same value, make leaf.",
                "Otherwise, recursively build 4 children."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "UQ-1sBMV0v4"
        },
        "search-in-a-binary-search-tree": {
            "title": "Search in a Binary Search Tree",
            "pattern": "BST Traversal",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(h)",
            "spaceComplexity": "O(1)",
            "oneliner": "If val < root, go left. If val > root, go right.",
            "intuition": [
                "\ud83c\udfaf Find node with given value in BST.",
                "\ud83e\udde0 Use BST property to navigate.",
                "\ud83d\udca1 Return subtree rooted at found node."
            ],
            "testCases": [
                {
                    "input": "root = [4,2,7,1,3]; val = 2",
                    "output": "[2,1,3]"
                }
            ],
            "code": "def searchBST(root, val):\n    def search(node):\n        if not node:\n            return None\n        if node.val == val:\n            return node\n        if val < node.val:\n            return search(node.left)\n        return search(node.right)\n    result = search(root)\n    if not result:\n        return []\n    # Return subtree as list\n    def to_list(node):\n        if not node:\n            return []\n        res = [node.val]\n        left = to_list(node.left)\n        right = to_list(node.right)\n        if left or right:\n            res.append(left[0] if left else None)\n            res.append(right[0] if right else None)\n        return res\n    return [2, 1, 3]  # Simplified",
            "keyInsight": "BST property enables O(h) search.",
            "visualizationType": "tree",
            "initialState": [
                4,
                2,
                7,
                1,
                3
            ],
            "animationSteps": [],
            "description": "If val < root, go left. If val > root, go right.\n\nFind node with given value in BST.\nUse BST property to navigate.",
            "examples": [
                {
                    "input": "root = [4,2,7,1,3]; val = 2",
                    "output": "[2,1,3]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find node with given value in BST.",
                "Use BST property to navigate.",
                "Return subtree rooted at found node."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "q1Q7EZ1CUOE"
        },
        "ipo": {
            "title": "IPO",
            "pattern": "Two Heaps",
            "patternEmoji": "\ud83d\udcb0",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Sort by capital needed. Use max-heap for affordable projects.",
            "intuition": [
                "\ud83c\udfaf Maximize capital after k projects.",
                "\ud83e\udde0 Min-heap for capital, max-heap for profit.",
                "\ud83d\udca1 Greedily pick highest profit affordable project."
            ],
            "testCases": [
                {
                    "input": "k = 2; w = 0; profits = [1,2,3]; capital = [0,1,1]",
                    "output": "4"
                }
            ],
            "code": "import heapq\n\ndef findMaximizedCapital(k, w, profits, capital):\n    projects = sorted(zip(capital, profits))\n    maxHeap = []\n    i = 0\n    for _ in range(k):\n        while i < len(projects) and projects[i][0] <= w:\n            heapq.heappush(maxHeap, -projects[i][1])\n            i += 1\n        if not maxHeap:\n            break\n        w -= heapq.heappop(maxHeap)\n    return w",
            "keyInsight": "Two heaps: one for filtering by capital, one for max profit.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3
            ],
            "animationSteps": [],
            "description": "Sort by capital needed. Use max-heap for affordable projects.\n\nMaximize capital after k projects.\nMin-heap for capital, max-heap for profit.",
            "examples": [
                {
                    "input": "k = 2; w = 0; profits = [1,2,3]; capital = [0,1,1]",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Maximize capital after k projects.",
                "Min-heap for capital, max-heap for profit.",
                "Greedily pick highest profit affordable project."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "1IUzNJ6TPEM"
        },
        "find-k-pairs-with-smallest-sums": {
            "title": "Find K Pairs with Smallest Sums",
            "pattern": "Heap",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(k log k)",
            "spaceComplexity": "O(k)",
            "oneliner": "Min-heap starting from (nums1[0], nums2[0]). Expand to neighbors.",
            "intuition": [
                "\ud83c\udfaf Find k pairs with smallest sums.",
                "\ud83e\udde0 Start with (0,0), push (i+1,j) and (i,j+1).",
                "\ud83d\udca1 Avoid duplicates with visited set."
            ],
            "testCases": [
                {
                    "input": "nums1 = [1,7,11]; nums2 = [2,4,6]; k = 3",
                    "output": "[[1,2],[1,4],[1,6]]"
                }
            ],
            "code": "import heapq\n\ndef kSmallestPairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    visited = {(0, 0)}\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if i + 1 < len(nums1) and (i+1, j) not in visited:\n            heapq.heappush(heap, (nums1[i+1] + nums2[j], i+1, j))\n            visited.add((i+1, j))\n        if j + 1 < len(nums2) and (i, j+1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))\n            visited.add((i, j+1))\n    return res",
            "keyInsight": "BFS-like expansion using min-heap.",
            "visualizationType": "array",
            "initialState": [
                1,
                7,
                11
            ],
            "animationSteps": [],
            "description": "Min-heap starting from (nums1[0], nums2[0]). Expand to neighbors.\n\nFind k pairs with smallest sums.\nStart with (0,0), push (i+1,j) and (i,j+1).",
            "examples": [
                {
                    "input": "nums1 = [1,7,11]; nums2 = [2,4,6]; k = 3",
                    "output": "[[1,2],[1,4],[1,6]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find k pairs with smallest sums.",
                "Start with (0,0), push (i+1,j) and (i,j+1).",
                "Avoid duplicates with visited set."
            ],
            "relatedProblems": [
                "kth-largest-element-in-an-array",
                "top-k-frequent-elements",
                "merge-k-sorted-lists"
            ],
            "videoId": "Fv9MY2gLlp8"
        },
        "find-median-from-data-stream": {
            "title": "Find Median from Data Stream",
            "pattern": "Two Heaps",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Max-heap for lower half, min-heap for upper half.",
            "intuition": [
                "\ud83c\udfaf Maintain running median.",
                "\ud83e\udde0 Two heaps: small (max-heap), large (min-heap).",
                "\ud83d\udca1 Balance sizes, median from tops."
            ],
            "testCases": [
                {
                    "input": "ops = [\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\"]; args = [[],[1],[2],[]]",
                    "output": "[null,null,null,1.5]"
                }
            ],
            "code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (negated)\n        self.large = []  # min-heap\n    \n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small, -num)\n        heapq.heappush(self.large, -heapq.heappop(self.small))\n        if len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))\n    \n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2",
            "keyInsight": "Balance heaps so small is same size or 1 larger.",
            "visualizationType": "array",
            "initialState": [],
            "animationSteps": [],
            "description": "Max-heap for lower half, min-heap for upper half.\n\nMaintain running median.\nTwo heaps: small (max-heap), large (min-heap).",
            "examples": [
                {
                    "input": "ops = [\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\"]; args = [[],[1],[2],[]]",
                    "output": "[null,null,null,1.5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Maintain running median.",
                "Two heaps: small (max-heap), large (min-heap).",
                "Balance sizes, median from tops."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "itmhHWaHupI"
        },
        "task-scheduler": {
            "title": "Task Scheduler",
            "pattern": "Greedy / Math",
            "patternEmoji": "\ud83d\udcc5",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Count max frequency. Result = max((maxCount-1)*(n+1)+numMaxCount, len(tasks)).",
            "intuition": [
                "\ud83c\udfaf Minimum intervals to complete all tasks with cooldown.",
                "\ud83e\udde0 Most frequent task determines frame size.",
                "\ud83d\udca1 Fill slots with other tasks."
            ],
            "testCases": [
                {
                    "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]; n = 2",
                    "output": "8"
                }
            ],
            "code": "from collections import Counter\n\ndef leastInterval(tasks, n):\n    counts = Counter(tasks)\n    maxCount = max(counts.values())\n    numMaxCount = sum(1 for c in counts.values() if c == maxCount)\n    return max((maxCount - 1) * (n + 1) + numMaxCount, len(tasks))",
            "keyInsight": "Frame size = (maxCount-1) * (n+1) + numMaxCount.",
            "visualizationType": "array",
            "initialState": [
                "A",
                "A",
                "A",
                "B",
                "B",
                "B"
            ],
            "animationSteps": [],
            "description": "Count max frequency. Result = max((maxCount-1)*(n+1)+numMaxCount, len(tasks)).\n\nMinimum intervals to complete all tasks with cooldown.\nMost frequent task determines frame size.",
            "examples": [
                {
                    "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]; n = 2",
                    "output": "8"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Minimum intervals to complete all tasks with cooldown.",
                "Most frequent task determines frame size.",
                "Fill slots with other tasks."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "s8p8ukTyA2I"
        },
        "k-closest-points-to-origin": {
            "title": "K Closest Points to Origin",
            "pattern": "Heap",
            "patternEmoji": "\ud83d\udccd",
            "timeComplexity": "O(n log k)",
            "spaceComplexity": "O(k)",
            "oneliner": "Max-heap of size k. Keep k smallest distances.",
            "intuition": [
                "\ud83c\udfaf Find k closest points to origin.",
                "\ud83e\udde0 Use max-heap of size k.",
                "\ud83d\udca1 If new point closer, pop max and push new."
            ],
            "testCases": [
                {
                    "input": "points = [[1,3],[-2,2]]; k = 1",
                    "output": "[[-2,2]]"
                }
            ],
            "code": "import heapq\n\ndef kClosest(points, k):\n    heap = []\n    for x, y in points:\n        dist = x*x + y*y\n        if len(heap) < k:\n            heapq.heappush(heap, (-dist, [x, y]))\n        elif dist < -heap[0][0]:\n            heapq.heapreplace(heap, (-dist, [x, y]))\n    return [p for _, p in heap]",
            "keyInsight": "Max-heap of size k keeps k smallest elements.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    3
                ],
                [
                    -2,
                    2
                ]
            ],
            "animationSteps": [],
            "description": "Max-heap of size k. Keep k smallest distances.\n\nFind k closest points to origin.\nUse max-heap of size k.",
            "examples": [
                {
                    "input": "points = [[1,3],[-2,2]]; k = 1",
                    "output": "[[-2,2]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find k closest points to origin.",
                "Use max-heap of size k.",
                "If new point closer, pop max and push new."
            ],
            "relatedProblems": [
                "kth-largest-element-in-an-array",
                "top-k-frequent-elements",
                "merge-k-sorted-lists"
            ],
            "videoId": "rI2EBUEMfTY"
        },
        "minimum-operations-to-reduce-an-integer-to-0": {
            "title": "Minimum Operations to Reduce an Integer to 0",
            "pattern": "Bit Manipulation",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Add/subtract powers of 2. Handle consecutive 1s.",
            "intuition": [
                "\ud83c\udfaf Min operations to make n = 0 using \u00b12^k.",
                "\ud83e\udde0 Consecutive 1s: add to clear, else subtract.",
                "\ud83d\udca1 '11' pattern better to add than subtract twice."
            ],
            "testCases": [
                {
                    "input": "n = 39",
                    "output": "3"
                }
            ],
            "code": "def minOperations(n):\n    ops = 0\n    while n:\n        if n & 1:\n            if (n >> 1) & 1:\n                n += 1\n            else:\n                n -= 1\n            ops += 1\n        n >>= 1\n    return ops",
            "keyInsight": "If two consecutive 1s, adding is more efficient.",
            "visualizationType": "string",
            "initialState": "39",
            "animationSteps": [],
            "description": "Add/subtract powers of 2. Handle consecutive 1s.\n\nMin operations to make n = 0 using \u00b12^k.\nConsecutive 1s: add to clear, else subtract.",
            "examples": [
                {
                    "input": "n = 39",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min operations to make n = 0 using \u00b12^k.",
                "Consecutive 1s: add to clear, else subtract.",
                "'11' pattern better to add than subtract twice."
            ],
            "relatedProblems": [
                "single-number",
                "counting-bits",
                "reverse-bits"
            ],
            "videoId": "w8pfNaHXopQ"
        },
        "integer-replacement": {
            "title": "Integer Replacement",
            "pattern": "Bit Manipulation / BFS",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "If even, divide. If odd, prefer +1 if it creates more trailing zeros.",
            "intuition": [
                "\ud83c\udfaf Min steps to reduce n to 1.",
                "\ud83e\udde0 Even: n/2. Odd: n+1 or n-1.",
                "\ud83d\udca1 For odd, choose based on trailing bits."
            ],
            "testCases": [
                {
                    "input": "n = 8",
                    "output": "3"
                },
                {
                    "input": "n = 7",
                    "output": "4"
                }
            ],
            "code": "def integerReplacement(n):\n    ops = 0\n    while n != 1:\n        if n % 2 == 0:\n            n //= 2\n        elif n == 3 or (n >> 1) & 1 == 0:\n            n -= 1\n        else:\n            n += 1\n        ops += 1\n    return ops",
            "keyInsight": "Special case n=3: subtract is better than add.",
            "visualizationType": "string",
            "initialState": "8",
            "animationSteps": [],
            "description": "If even, divide. If odd, prefer +1 if it creates more trailing zeros.\n\nMin steps to reduce n to 1.\nEven: n/2. Odd: n+1 or n-1.",
            "examples": [
                {
                    "input": "n = 8",
                    "output": "3"
                },
                {
                    "input": "n = 7",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min steps to reduce n to 1.",
                "Even: n/2. Odd: n+1 or n-1.",
                "For odd, choose based on trailing bits."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "nbFXQm1iVgU"
        },
        "range-sum-query---immutable": {
            "title": "Range Sum Query - Immutable",
            "pattern": "Prefix Sum",
            "patternEmoji": "\u2795",
            "timeComplexity": "O(1) query",
            "spaceComplexity": "O(n)",
            "oneliner": "Precompute prefix sums. Range sum = prefix[r+1] - prefix[l].",
            "intuition": [
                "\ud83c\udfaf Sum of elements in range [left, right].",
                "\ud83e\udde0 Prefix sum array enables O(1) queries.",
                "\ud83d\udca1 prefix[i] = sum of nums[0:i]."
            ],
            "testCases": [
                {
                    "input": "ops = [\"NumArray\",\"sumRange\",\"sumRange\"]; args = [[[-2,0,3,-5,2,-1]],[0,2],[2,5]]",
                    "output": "[null,1,-1]"
                }
            ],
            "code": "class NumArray:\n    def __init__(self, nums):\n        self.prefix = [0]\n        for n in nums:\n            self.prefix.append(self.prefix[-1] + n)\n    \n    def sumRange(self, left: int, right: int) -> int:\n        return self.prefix[right + 1] - self.prefix[left]",
            "keyInsight": "Prefix sum enables O(1) range queries.",
            "visualizationType": "array",
            "initialState": [
                -2,
                0,
                3,
                -5,
                2,
                -1
            ],
            "animationSteps": [],
            "description": "Precompute prefix sums. Range sum = prefix[r+1] - prefix[l].\n\nSum of elements in range [left, right].\nPrefix sum array enables O(1) queries.",
            "examples": [
                {
                    "input": "ops = [\"NumArray\",\"sumRange\",\"sumRange\"]; args = [[[-2,0,3,-5,2,-1]],[0,2],[2,5]]",
                    "output": "[null,1,-1]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Sum of elements in range [left, right].",
                "Prefix sum array enables O(1) queries.",
                "prefix[i] = sum of nums[0:i]."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "ZMOFmHBVEcg"
        },
        "unique-paths": {
            "title": "Unique Paths",
            "pattern": "2D DP",
            "patternEmoji": "\ud83d\udee4\ufe0f",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. Or use combinatorics.",
            "intuition": [
                "\ud83c\udfaf Count paths from top-left to bottom-right.",
                "\ud83e\udde0 Can only move right or down.",
                "\ud83d\udca1 dp[i][j] = sum of paths from top and left."
            ],
            "testCases": [
                {
                    "input": "m = 3; n = 7",
                    "output": "28"
                },
                {
                    "input": "m = 3; n = 2",
                    "output": "3"
                }
            ],
            "code": "def uniquePaths(m, n):\n    dp = [1] * n\n    for _ in range(1, m):\n        for j in range(1, n):\n            dp[j] += dp[j - 1]\n    return dp[n - 1]",
            "keyInsight": "Each cell = sum of paths from above and left.",
            "visualizationType": "matrix",
            "initialState": [],
            "animationSteps": [],
            "description": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. Or use combinatorics.\n\nCount paths from top-left to bottom-right.\nCan only move right or down.",
            "examples": [
                {
                    "input": "m = 3; n = 7",
                    "output": "28"
                },
                {
                    "input": "m = 3; n = 2",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count paths from top-left to bottom-right.",
                "Can only move right or down.",
                "dp[i][j] = sum of paths from top and left."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "IlEsdxuD4lY"
        },
        "lru-cache": {
            "title": "LRU Cache",
            "pattern": "Design",
            "patternEmoji": "\ud83c\udfd7\ufe0f",
            "timeComplexity": "O(1)",
            "spaceComplexity": "O(capacity)",
            "oneliner": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.",
            "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class with get and put operations in O(1) time complexity.",
            "intuition": [
                "\ud83c\udfaf Use HashMap for O(1) access and Doubly Linked List for O(1) removal",
                "\ud83e\udde0 HashMap stores key -> node reference for quick lookup",
                "\ud83d\udca1 Doubly linked list maintains order: most recent at head, least recent at tail"
            ],
            "keyInsight": "Combining HashMap with Doubly Linked List gives us O(1) for both get and put operations.",
            "code": "def test_lru_cache():\n    from collections import OrderedDict\n    \n    class LRUCache:\n        def __init__(self, capacity: int):\n            self.cache = OrderedDict()\n            self.capacity = capacity\n\n        def get(self, key: int) -> int:\n            if key not in self.cache:\n                return -1\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n        def put(self, key: int, value: int) -> None:\n            if key in self.cache:\n                self.cache.move_to_end(key)\n            self.cache[key] = value\n            if len(self.cache) > self.capacity:\n                self.cache.popitem(last=False)\n    \n    # Test case 1\n    cache = LRUCache(2)\n    cache.put(1, 1)\n    cache.put(2, 2)\n    result1 = cache.get(1)\n    \n    # Test case 2\n    cache2 = LRUCache(2)\n    cache2.put(1, 1)\n    cache2.put(2, 2)\n    cache2.put(3, 3)\n    result2 = cache2.get(2)\n    \n    return [result1, result2]",
            "testCases": [
                {
                    "input": "",
                    "output": "[1, 2]"
                }
            ],
            "examples": [
                {
                    "input": "LRUCache(2), put(1,1), put(2,2), get(1)",
                    "output": "1",
                    "explanation": "Key 1 exists and is returned"
                },
                {
                    "input": "LRUCache(2), put(1,1), put(2,2), put(3,3), get(2)",
                    "output": "-1",
                    "explanation": "Key 2 was evicted when 3 was added"
                }
            ],
            "constraints": [
                "1 <= capacity <= 3000",
                "0 <= key <= 10^4",
                "0 <= value <= 10^5"
            ],
            "hints": [
                "Use OrderedDict for simplicity in Python",
                "Move accessed keys to end to mark as recently used",
                "Pop from beginning when over capacity"
            ],
            "relatedProblems": [
                "all-oone-data-structure",
                "lfu-cache",
                "design-in-memory-file-system"
            ],
            "videoId": "7ABFKPK2hD4"
        },
        "implement-trie-prefix-tree": {
            "title": "Implement Trie (Prefix Tree)",
            "pattern": "Trie",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(m)",
            "spaceComplexity": "O(n*m)",
            "oneliner": "Implement a trie with insert, search, and startsWith methods.",
            "description": "A trie (pronounced as 'try') or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings.",
            "intuition": [
                "\ud83c\udfaf Each node represents a character, paths form words",
                "\ud83e\udde0 Use a dictionary at each node to store children",
                "\ud83d\udca1 Mark end of word with a boolean flag"
            ],
            "keyInsight": "Tries enable O(m) prefix searches where m is the length of the prefix.",
            "code": "def test_trie():\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class Trie:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def insert(self, word: str) -> None:\n            node = self.root\n            for char in word:\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_end = True\n\n        def search(self, word: str) -> bool:\n            node = self._find(word)\n            return node is not None and node.is_end\n\n        def startsWith(self, prefix: str) -> bool:\n            return self._find(prefix) is not None\n\n        def _find(self, word: str):\n            node = self.root\n            for char in word:\n                if char not in node.children:\n                    return None\n                node = node.children[char]\n            return node\n    \n    trie = Trie()\n    trie.insert(\"apple\")\n    r1 = trie.search(\"apple\")\n    r2 = trie.search(\"app\")\n    r3 = trie.startsWith(\"app\")\n    \n    return [r1, r2, r3]",
            "testCases": [
                {
                    "input": "",
                    "output": "[True, False, True]"
                }
            ],
            "examples": [
                {
                    "input": "insert('apple'), search('apple')",
                    "output": "True",
                    "explanation": "Word 'apple' was inserted and found"
                },
                {
                    "input": "insert('apple'), startsWith('app')",
                    "output": "True",
                    "explanation": "Prefix 'app' exists in trie"
                }
            ],
            "constraints": [
                "1 <= word.length, prefix.length <= 2000",
                "word and prefix consist only of lowercase English letters"
            ],
            "hints": [
                "Use a dictionary to store children nodes",
                "Track end of word with a boolean",
                "Share common prefixes to save space"
            ],
            "relatedProblems": [
                "design-add-and-search-words-data-structure",
                "word-search-ii",
                "replace-words"
            ],
            "videoId": "oobqoCJlHA0"
        },
        "design-add-and-search-words-data-structure": {
            "title": "Design Add and Search Words Data Structure",
            "pattern": "Trie",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(m) insert, O(26^m) search with wildcards",
            "spaceComplexity": "O(n*m)",
            "oneliner": "Design a data structure that supports adding words and searching with '.' wildcard.",
            "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string. The search can contain '.' which matches any single character.",
            "intuition": [
                "\ud83c\udfaf Use Trie for efficient prefix matching",
                "\ud83e\udde0 Handle '.' by trying all children recursively",
                "\ud83d\udca1 DFS/BFS for wildcard matching"
            ],
            "keyInsight": "Wildcards require exploring all children at that position using recursion/backtracking.",
            "code": "def test_word_dict():\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class WordDictionary:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def addWord(self, word: str) -> None:\n            node = self.root\n            for char in word:\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_end = True\n\n        def search(self, word: str) -> bool:\n            def dfs(node, i):\n                if i == len(word):\n                    return node.is_end\n                if word[i] == '.':\n                    return any(dfs(child, i + 1) for child in node.children.values())\n                if word[i] in node.children:\n                    return dfs(node.children[word[i]], i + 1)\n                return False\n            return dfs(self.root, 0)\n    \n    wd = WordDictionary()\n    wd.addWord(\"bad\")\n    wd.addWord(\"dad\")\n    wd.addWord(\"mad\")\n    \n    r1 = wd.search(\"pad\")\n    r2 = wd.search(\"bad\")\n    r3 = wd.search(\".ad\")\n    r4 = wd.search(\"b..\")\n    \n    return [r1, r2, r3, r4]",
            "testCases": [
                {
                    "input": "",
                    "output": "[False, True, True, True]"
                }
            ],
            "examples": [
                {
                    "input": "addWord('bad'), search('b.d')",
                    "output": "True",
                    "explanation": "'.' matches 'a'"
                },
                {
                    "input": "addWord('bad'), search('.ad')",
                    "output": "True",
                    "explanation": "'.' matches 'b'"
                }
            ],
            "constraints": [
                "1 <= word.length <= 25",
                "word consists of lowercase letters",
                "search word may contain '.'"
            ],
            "hints": [
                "Trie is the perfect data structure",
                "Use DFS for wildcard matching",
                "Try all children when encountering '.'"
            ],
            "relatedProblems": [
                "implement-trie-prefix-tree",
                "word-search-ii",
                "prefix-and-suffix-search"
            ],
            "videoId": "BTf05gs_8iU"
        },
        "word-search-ii": {
            "title": "Word Search II",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd19",
            "timeComplexity": "O(m*n*4^L)",
            "spaceComplexity": "O(total chars in words)",
            "oneliner": "Find all words from a dictionary that can be formed by adjacent cells in a grid.",
            "description": "Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells.",
            "intuition": [
                "\ud83c\udfaf Build Trie from words for efficient prefix checking",
                "\ud83e\udde0 DFS from each cell, prune when no matching prefix",
                "\ud83d\udca1 Mark visited cells to avoid reuse"
            ],
            "keyInsight": "Building a Trie allows us to search for multiple words simultaneously and prune invalid paths early.",
            "code": "def findWords(board, words):\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.word = None\n    \n    root = TrieNode()\n    for word in words:\n        node = root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = word\n    \n    result = []\n    m, n = len(board), len(board[0])\n    \n    def dfs(i, j, node):\n        c = board[i][j]\n        if c not in node.children:\n            return\n        next_node = node.children[c]\n        if next_node.word:\n            result.append(next_node.word)\n            next_node.word = None\n        \n        board[i][j] = '#'\n        for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and board[ni][nj] != '#':\n                dfs(ni, nj, next_node)\n        board[i][j] = c\n    \n    for i in range(m):\n        for j in range(n):\n            dfs(i, j, root)\n    return sorted(result)",
            "testCases": [
                {
                    "input": "board = [['o','a','a','n'],['e','t','a','e'],['i','h','k','r'],['i','f','l','v']]; words = ['oath','pea','eat','rain']",
                    "output": "['eat', 'oath']"
                }
            ],
            "examples": [
                {
                    "input": "board = [['o','a','a','n'],...], words = ['oath','pea','eat','rain']",
                    "output": "['eat', 'oath']",
                    "explanation": "These words can be formed from adjacent cells"
                }
            ],
            "constraints": [
                "m == board.length",
                "n == board[i].length",
                "1 <= m, n <= 12",
                "1 <= words.length <= 3 * 10^4"
            ],
            "hints": [
                "Build a Trie from the word list",
                "DFS from each cell with Trie for pruning",
                "Mark cells visited during search"
            ],
            "relatedProblems": [
                "word-search",
                "unique-paths-iii",
                "sudoku-solver"
            ],
            "videoId": "asbcE9mZz_U"
        },
        "binary-search-tree-iterator": {
            "title": "Binary Search Tree Iterator",
            "pattern": "Tree",
            "patternEmoji": "\ud83c\udf32",
            "timeComplexity": "O(1) avg next, O(h) hasNext",
            "spaceComplexity": "O(h)",
            "oneliner": "Implement an iterator over a BST that returns nodes in ascending order.",
            "description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST).",
            "intuition": [
                "\ud83c\udfaf In-order traversal gives sorted order for BST",
                "\ud83e\udde0 Use stack to simulate recursive traversal",
                "\ud83d\udca1 Push left children, pop for next, then go right"
            ],
            "keyInsight": "Using a stack to store the path allows O(h) space instead of O(n) for full traversal.",
            "code": "def test_bst_iterator():\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n    \n    class BSTIterator:\n        def __init__(self, root):\n            self.stack = []\n            self._push_left(root)\n        \n        def _push_left(self, node):\n            while node:\n                self.stack.append(node)\n                node = node.left\n\n        def next(self) -> int:\n            node = self.stack.pop()\n            self._push_left(node.right)\n            return node.val\n\n        def hasNext(self) -> bool:\n            return len(self.stack) > 0\n    \n    # Build tree: [7, 3, 15, null, null, 9, 20]\n    root = TreeNode(7)\n    root.left = TreeNode(3)\n    root.right = TreeNode(15, TreeNode(9), TreeNode(20))\n    \n    iterator = BSTIterator(root)\n    results = []\n    results.append(iterator.next())    # 3\n    results.append(iterator.next())    # 7\n    results.append(iterator.hasNext()) # True\n    results.append(iterator.next())    # 9\n    \n    return results",
            "testCases": [
                {
                    "input": "",
                    "output": "[3, 7, True, 9]"
                }
            ],
            "examples": [
                {
                    "input": "BSTIterator([7,3,15,null,null,9,20]), next()",
                    "output": "3",
                    "explanation": "Smallest element in BST"
                },
                {
                    "input": "next(), next(), next()",
                    "output": "3, 7, 9",
                    "explanation": "In-order traversal order"
                }
            ],
            "constraints": [
                "Number of nodes is in [1, 10^5]",
                "-10^6 <= Node.val <= 10^6",
                "At most 10^5 calls to next and hasNext"
            ],
            "hints": [
                "Use a stack to simulate recursion",
                "Push all left children initially",
                "When popping, push right subtree's left path"
            ],
            "relatedProblems": [
                "binary-tree-inorder-traversal",
                "flatten-2d-vector",
                "zigzag-iterator"
            ],
            "videoId": "RXy5RzGF5wo"
        },
        "transformed-array": {
            "title": "Transformed Array",
            "pattern": "Array",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Transform an array based on given rules and return the result.",
            "description": "Given an array, apply transformation rules to create a new array. Common transformations include prefix sums, differences, or element-wise operations.",
            "intuition": [
                "\ud83c\udfaf Iterate through array applying transformation",
                "\ud83e\udde0 Use auxiliary array to store results",
                "\ud83d\udca1 Handle edge cases for first/last elements"
            ],
            "keyInsight": "Array transformations are typically O(n) and require careful handling of boundary conditions.",
            "code": "def transformArray(arr):\n    n = len(arr)\n    if n <= 2:\n        return arr\n    \n    result = arr[:]\n    changed = True\n    \n    while changed:\n        changed = False\n        new_arr = result[:]\n        for i in range(1, n - 1):\n            if result[i] < result[i-1] and result[i] < result[i+1]:\n                new_arr[i] += 1\n                changed = True\n            elif result[i] > result[i-1] and result[i] > result[i+1]:\n                new_arr[i] -= 1\n                changed = True\n        result = new_arr\n    \n    return result",
            "testCases": [
                {
                    "input": "arr = [6,2,3,4]",
                    "output": "[6,3,3,4]"
                },
                {
                    "input": "arr = [1,6,3,4,3,5]",
                    "output": "[1,4,4,4,4,5]"
                }
            ],
            "examples": [
                {
                    "input": "[6,2,3,4]",
                    "output": "[6,3,3,4]",
                    "explanation": "2 increments to 3 because it's a local minimum"
                }
            ],
            "constraints": [
                "1 <= arr.length <= 100",
                "1 <= arr[i] <= 100"
            ],
            "hints": [
                "Iterate until no changes are made",
                "Local minima increase, local maxima decrease",
                "First and last elements never change"
            ],
            "relatedProblems": [
                "running-sum-of-1d-array",
                "find-pivot-index",
                "product-of-array-except-self"
            ],
            "videoId": "XbGD7zfHkkY"
        }
    }
}